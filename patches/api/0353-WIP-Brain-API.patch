From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Mon, 29 Nov 2021 21:57:09 -0500
Subject: [PATCH] WIP Brain API


diff --git a/src/main/java/io/papermc/paper/entity/brain/BrainManager.java b/src/main/java/io/papermc/paper/entity/brain/BrainManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..80c5261de15f8c9770f8c5f5f221e5b47a8b5e60
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/BrainManager.java
@@ -0,0 +1,248 @@
+package io.papermc.paper.entity.brain;
+
+import io.papermc.paper.entity.brain.activity.ActivityKey;
+import io.papermc.paper.entity.brain.activity.behavior.Behavior;
+import io.papermc.paper.entity.brain.activity.behavior.BehaviorPair;
+import io.papermc.paper.entity.brain.memory.MemoryModuleType;
+import io.papermc.paper.entity.brain.memory.MemoryTypeStatus;
+import io.papermc.paper.entity.brain.memory.MemoryManager;
+import io.papermc.paper.entity.brain.memory.MemoryPair;
+import io.papermc.paper.entity.brain.sensor.Sensor;
+import io.papermc.paper.entity.brain.sensor.SensorKey;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.memory.MemoryKey;
+import org.jetbrains.annotations.NotNull;
+
+import javax.annotation.Nullable;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * A brain handler is used for modifying brains of living entities.
+ *
+ * It should be noted all living entities have a brain, but not all actually try to tick theirs.
+ */
+public interface BrainManager {
+
+    /**
+     * Finds the first activity that can start in the given collection and starts it.
+     * If none meet their criteria, nothing will happen.
+     *
+     * @param livingEntity given entity
+     * @param keys activities to try to start
+     */
+    void startFirstValidActivity(@NotNull LivingEntity livingEntity, @NotNull Collection<ActivityKey> keys);
+
+    /**
+     * Tries to start the providied activity.
+     * In the case that it cannot be run, the default activity will run instead.
+     *
+     * @param livingEntity given entity*
+     * @param key activity to attempt to start
+     */
+    void startActivity(@NotNull LivingEntity livingEntity, @NotNull ActivityKey key);
+
+    /**
+     * Stops the provided activity from executing further if it is currently active.
+     *
+     * @param livingEntity given entity
+     * @param key activity to stop
+     */
+    void stopActivity(@NotNull LivingEntity livingEntity, @NotNull ActivityKey key);
+
+    /**
+     * Clears all core and current active
+     * activities.
+     *
+     * @param livingEntity given entity
+     */
+    void clearActivities(@NotNull LivingEntity livingEntity);
+
+    /**
+     * Gets activities keyed by their priority
+     *
+     * @param livingEntity given entity
+     * @return keyed activities
+     */
+    @NotNull
+    Map<Integer, Collection<ActivityKey>> getPrioritizedActivities(@NotNull LivingEntity livingEntity);
+
+    /**
+     * Gets activities that are currently being run.
+     *
+     * @param livingEntity given entity
+     * @return activities being run
+     */
+    @NotNull
+    Collection<ActivityKey> getActiveActivities(@NotNull LivingEntity livingEntity);
+
+    /**
+     * Adds a custom activity.
+     * Activities represent a group of behaviors that can execute when the activity is marked as active.
+     * <p>
+     * This method assigns priority based on the order of the behaviors provided in the collection.
+     *
+     * @param livingEntity given entity
+     * @param key key of this activity
+     * @param beginningPriority the priority to begin the provided behaviors at
+     * @param behaviors behaviors of this activity ordered by priority
+     * @param <T> Entity type
+     */
+    default <T extends LivingEntity> void addActivity(@NotNull LivingEntity livingEntity, @NotNull ActivityKey key, int beginningPriority, @NotNull Collection<Behavior<? super T>> behaviors) {
+        List<BehaviorPair<? super T>> pairs = new ArrayList<>(behaviors.size());
+        for (Behavior<? super T> behavior : behaviors) {
+            pairs.add(new BehaviorPair<>(beginningPriority++, behavior));
+        }
+
+        this.addActivity(livingEntity, key, pairs);
+    }
+
+    /**
+     * Adds a custom activity.
+     * Activities represent a group of behaviors that can execute when the activity is marked as active.
+     * <p>
+     * This method assigns priority based on the order of the behaviors provided in the collection.
+     *
+     * @param livingEntity given entity
+     * @param key key of this activity
+     * @param beginningPriority the priority to begin the provided behaviors at
+     * @param behaviors behaviors of this activity ordered by priority
+     * @param requiredMemory present memory required for this activity to start
+     * @param <T> Entity type
+     */
+    default <T extends LivingEntity> void addActivity(@NotNull LivingEntity livingEntity, @NotNull ActivityKey key, int beginningPriority, @NotNull Collection<Behavior<? super T>> behaviors, @NotNull MemoryModuleType<?> requiredMemory) {
+        List<BehaviorPair<? super T>> pairs = new ArrayList<>(behaviors.size());
+        for (Behavior<? super T> behavior : behaviors) {
+            pairs.add(new BehaviorPair<>(beginningPriority++, behavior));
+        }
+
+        this.addActivity(livingEntity, key, pairs, List.of(new MemoryPair(MemoryTypeStatus.PRESENT, requiredMemory)));
+    }
+
+    /**
+     * Adds a custom activity.
+     * Activities represent a group of behaviors that can execute when the activity is marked as active.
+     *
+     * @param livingEntity given entity
+     * @param key key of this activity
+     * @param behaviorPairs the behaviors and priorities of this activity
+     * @param <T> Entity type
+     */
+    default <T extends LivingEntity> void addActivity(@NotNull LivingEntity livingEntity, @NotNull ActivityKey key, @NotNull Collection<BehaviorPair<? super T>> behaviorPairs) {
+        this.addActivity(livingEntity, key, behaviorPairs, Collections.emptyList(), Collections.emptyList());
+    }
+
+    /**
+     * Adds a custom activity.
+     * Activities represent a group of behaviors that can execute when the activity is marked as active.
+     *
+     * @param livingEntity given entity
+     * @param key key of this activity
+     * @param behaviorPairs the behaviors and priorities of this activity
+     * @param requiredMemories the memories required for this activity to run
+     * @param <T> Entity type
+     */
+    default <T extends LivingEntity> void addActivity(@NotNull LivingEntity livingEntity, @NotNull ActivityKey key, @NotNull Collection<BehaviorPair<? super T>> behaviorPairs, @NotNull Collection<MemoryPair> requiredMemories) {
+        this.addActivity(livingEntity, key, behaviorPairs, requiredMemories, Collections.emptyList());
+    }
+
+    // TODO: FIGURE OUT TICKING AND PROPERLY STARTING CUSTOM ACTIVITIES, READ THE PR FOR MORE INFORMATION
+    /**
+     * Adds a custom activity.
+     * Activities represent a group of behaviors that can execute when the activity is marked as active.
+     *
+     * @param livingEntity given entity
+     * @param key key of this activity
+     * @param behaviorPairs the behaviors and priorities of this activity
+     * @param requiredMemories the memories required for this activity to run
+     * @param keysToRemoveOnFinish memories that are removed when this activity is finished
+     * @param <T> Entity type
+     */
+    <T extends LivingEntity> void addActivity(@NotNull LivingEntity livingEntity, @NotNull ActivityKey key, @NotNull Collection<BehaviorPair<? super T>> behaviorPairs, @NotNull Collection<MemoryPair> requiredMemories, @NotNull Collection<MemoryModuleType<?>> keysToRemoveOnFinish);
+
+    /**
+     * Gets the default activity.
+     * This activity runs if no other activities are running, which for example is used for idling behavior.
+     *
+     * @param livingEntity given entity
+     * @return default activity
+     */
+    @NotNull
+    ActivityKey getDefaultActivity(@NotNull LivingEntity livingEntity);
+
+    /**
+     * Sets the default activity.
+     *
+     * @param livingEntity given entity
+     * @param key default activity
+     */
+    void setDefaultActivity(@NotNull LivingEntity livingEntity, @NotNull ActivityKey key);
+
+    /**
+     * Gets the core activities, these always are running.
+     *
+     * @param livingEntity given entity
+     * @return core activities
+     */
+    @NotNull
+    Collection<ActivityKey> getCoreActivities(@NotNull LivingEntity livingEntity);
+
+    /**
+     * Sets the core activities to always run.
+     *
+     * @param livingEntity given entity
+     * @param keys core activities
+     */
+    void setCoreActivities(@NotNull LivingEntity livingEntity, @NotNull Collection<ActivityKey> keys);
+
+    /**
+     * Adds a new sensor that is ticked periodically.
+     *
+     * @param livingEntity given entity
+     * @param key key of this sensor
+     * @param sensor sensor
+     * @param <T> Entity type
+     */
+    <T extends LivingEntity> void addSensor(@NotNull LivingEntity livingEntity, @NotNull SensorKey key, Sensor<? super T> sensor);
+
+    /**
+     * Clears all sensors.
+     *
+     * @param livingEntity given entity
+     */
+    void clearSensors(@NotNull LivingEntity livingEntity);
+
+    /**
+     * Removes a registered sensor.
+     *
+     * @param livingEntity given entity
+     * @param key sensor
+     */
+    void removeSensor(@NotNull LivingEntity livingEntity, @NotNull SensorKey key);
+
+    /**
+     * Gets a registered sensor.
+     *
+     * @param livingEntity given entity
+     * @param key key
+     * @return sensor if registered
+     */
+    @Nullable
+    Sensor<? extends LivingEntity> getSensor(@NotNull LivingEntity livingEntity, @NotNull SensorKey key);
+
+    /**
+     * Gets the current registered sensors.
+     *
+     * @param livingEntity given entity
+     * @return sensors
+     */
+    @NotNull
+    Collection<Sensor<? extends LivingEntity>> getSensors(@NotNull LivingEntity livingEntity);
+
+    @NotNull
+    MemoryManager getMemoryManager();
+
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/activity/ActivityKey.java b/src/main/java/io/papermc/paper/entity/brain/activity/ActivityKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..1aace077d112e409f7a90d0fe4797519898a212b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/activity/ActivityKey.java
@@ -0,0 +1,10 @@
+package io.papermc.paper.entity.brain.activity;
+
+import org.bukkit.Keyed;
+
+/**
+ * Represents a key for an activity.
+ */
+public interface ActivityKey extends Keyed {
+
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/activity/VanillaActivityKey.java b/src/main/java/io/papermc/paper/entity/brain/activity/VanillaActivityKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..6ce6980659358feca5973ea3f3709f6f65906509
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/activity/VanillaActivityKey.java
@@ -0,0 +1,60 @@
+package io.papermc.paper.entity.brain.activity;
+
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * Represents an activity used by minecraft.
+ */
+public final class VanillaActivityKey implements ActivityKey {
+
+    public static final Map<NamespacedKey, ActivityKey> ACTIVITY_KEYS = new HashMap<>();
+
+    public static final ActivityKey CORE = of("core");
+    public static final ActivityKey IDLE = of("idle");
+    public static final ActivityKey WORK = of("work");
+    public static final ActivityKey PLAY = of("play");
+    public static final ActivityKey REST = of("rest");
+    public static final ActivityKey MEET = of("meet");
+    public static final ActivityKey PANIC = of("panic");
+    public static final ActivityKey RAID = of("raid");
+    public static final ActivityKey PRE_RAID = of("pre_raid");
+    public static final ActivityKey HIDE = of("hide");
+    public static final ActivityKey FIGHT = of("fight");
+    public static final ActivityKey CELEBRATE = of("celebrate");
+    public static final ActivityKey ADMIRE_ITEM = of("admire_item");
+    public static final ActivityKey AVOID = of("avoid");
+    public static final ActivityKey RIDE = of("ride");
+    public static final ActivityKey PLAY_DEAD = of("play_dead");
+    public static final ActivityKey LONG_JUMP = of("long_jump");
+    public static final ActivityKey RAM = of("ram");
+
+
+    private static ActivityKey of(String key) {
+        NamespacedKey mcKey = NamespacedKey.minecraft(key);
+        ActivityKey activityKey = new VanillaActivityKey(mcKey);
+        ACTIVITY_KEYS.put(mcKey, activityKey);
+
+        return activityKey;
+    }
+
+    @Nullable
+    public static ActivityKey getByKey(@NotNull NamespacedKey namespacedKey) {
+        return ACTIVITY_KEYS.get(namespacedKey);
+    }
+
+    private final NamespacedKey key;
+
+    VanillaActivityKey(NamespacedKey key) {
+        this.key = key;
+    }
+
+    @Override
+    public @NotNull NamespacedKey getKey() {
+        return key;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/activity/behavior/Behavior.java b/src/main/java/io/papermc/paper/entity/brain/activity/behavior/Behavior.java
new file mode 100644
index 0000000000000000000000000000000000000000..bac6af1d8c6a050f84b0c9cf00c3a5ba56b98ffc
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/activity/behavior/Behavior.java
@@ -0,0 +1,76 @@
+package io.papermc.paper.entity.brain.activity.behavior;
+
+import io.papermc.paper.entity.brain.memory.MemoryPair;
+import org.bukkit.entity.LivingEntity;
+
+import java.util.Collection;
+
+
+/**
+ * Behaviors are similar to goals, except that they are bundled together in activities.
+ */
+public interface Behavior<T extends LivingEntity> {
+
+    /**
+     * Starts this behavior with the given entity.
+     *
+     * @param entity given entity
+     */
+    void start(T entity);
+
+    /**
+     * Ticks the behavior for the given entity.
+     *
+     * @param entity given entity
+     */
+    void tick(T entity);
+
+    /**
+     * Stops the ebhavior for the given entity.
+     *
+     * @param entity given entity
+     */
+    void stop(T entity);
+
+    /**
+     * Determines if the behavior can currently start.
+     *
+     * @param entity given entity
+     * @return can start or not
+     */
+    default boolean canStart(T entity) {
+        return true;
+    }
+
+    /**
+     * Gets the miniumum runtime in ticks that this behavior can run.
+     *
+     * @return time in ticks
+     */
+    int getMinRuntime();
+
+    /**
+     * Gets the maximum runtime in ticks that this behavior can run.
+     *
+     * @return time in ticks
+     */
+    int getMaxRuntime();
+
+    /**
+     * Gets if the behavior is still able to run.
+     * If false, this will stop the behavior.
+     *
+     * @return time in ticks
+     */
+    default boolean canStillRun(T entity) {
+        return true;
+    }
+
+    /**
+     * Gets the required memory pairs that this behavior needs inorder to start.
+     *
+     * @return required pairs
+     */
+    Collection<MemoryPair> getMemoryRequirements();
+
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/activity/behavior/BehaviorPair.java b/src/main/java/io/papermc/paper/entity/brain/activity/behavior/BehaviorPair.java
new file mode 100644
index 0000000000000000000000000000000000000000..5105005291e0f033d615c14fd449298ba758d573
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/activity/behavior/BehaviorPair.java
@@ -0,0 +1,9 @@
+package io.papermc.paper.entity.brain.activity.behavior;
+
+import org.bukkit.entity.LivingEntity;
+
+/**
+ * Represents a behavior with a priority, used for creating activities.
+ */
+public record BehaviorPair<T extends LivingEntity>(int priority, Behavior<T> behavior) {
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/memory/MemoryManager.java b/src/main/java/io/papermc/paper/entity/brain/memory/MemoryManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..60e60487b1f7189e21b33aaefbe219d371699586
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/memory/MemoryManager.java
@@ -0,0 +1,105 @@
+package io.papermc.paper.entity.brain.memory;
+
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.memory.MemoryKey;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Collection;
+import java.util.Optional;
+
+/**
+ * Manager of memories in entities, mainly a replacement for {@link LivingEntity#setMemory(MemoryKey, Object)} and {@link LivingEntity#getMemory(MemoryKey)}.
+ * But also provides additional methods for registering custom memory types and interacting with memories.
+ */
+public interface MemoryManager {
+    /**
+     * Registers a memory, this is required inorder to set
+     * memories that do not exist already.
+     * This is mostly useful if you are inserting custom memory keys.
+     *
+     * @param livingEntity given entity.
+     * @param memoryModuleType memory type to register.
+     */
+    void registerMemoryType(@NotNull LivingEntity livingEntity, @NotNull MemoryModuleType<?> memoryModuleType);
+
+    /**
+     * Unregisters the provided memory.
+     *
+     * @param livingEntity given entity
+     * @param memoryModuleType key
+     */
+    void unregisterMemoryType(@NotNull LivingEntity livingEntity, @NotNull MemoryModuleType<?> memoryModuleType);
+
+    /**
+     * Sets the memory value of the specified memory type for the given living entity.
+     * @param livingEntity living entity you want to set this memory value.
+     * @param memoryModuleType type of memory value you want to set.
+     * @param value memory value you want to set.
+     * @param <U> generic type of memory value.
+     */
+    <U> void setMemory(@NotNull LivingEntity livingEntity, @NotNull MemoryModuleType<U> memoryModuleType, @Nullable U value);
+
+    /**
+     * Sets the memory value of the specified memory type for the given living entity.
+     * @param livingEntity living entity you want to set this memory value.
+     * @param memoryModuleType type of memory value you want to set.
+     * @param value memory value you want to set.
+     * @param expiry time after which this memory value expires.
+     * @param <U> generic type of memory value.
+     */
+    <U> void setMemory(@NotNull LivingEntity livingEntity, @NotNull MemoryModuleType<U> memoryModuleType, @Nullable U value, long expiry);
+
+    /**
+     * Gets the memory of the specified memory type from the given living entity.
+     * @param livingEntity living entity you want to get this memory value.
+     * @param memoryModuleType type of memory value you want to get.
+     * @param <U> generic type of memory value.
+     * @return Optional with memory value if it exists in given living entity.
+     */
+    <U> Optional<U> getMemory(@NotNull LivingEntity livingEntity, @NotNull MemoryModuleType<U> memoryModuleType);
+
+    /**
+     * Gets the time until the given memory value of the given memory type expires.
+     * @param memoryModuleType Given memory type.
+     * @param <U> generic type of the
+     * @return time after which this memory value expires.
+     */
+    <U> long getTimeUntilExpiry(@NotNull LivingEntity livingEntity, @NotNull MemoryModuleType<U> memoryModuleType);
+
+    /**
+     * Returns true if the current memory type matches the given key status.
+     *
+     * @param livingEntity given entity.
+     * @param memoryModuleType memory type.
+     * @param status status.
+     * @return if the status is met.
+     */
+    boolean memoryStatusMatches(@NotNull LivingEntity livingEntity, @NotNull MemoryModuleType<?> memoryModuleType, @NotNull MemoryTypeStatus status);
+
+    /**
+     * Erases the provided memory, this is equivalent to setting the memory value to null.
+     * This will not unregister the memory.
+     *
+     * @param livingEntity given entity.
+     * @param memoryModuleType memory type.
+     */
+    void eraseMemory(@NotNull LivingEntity livingEntity, @NotNull MemoryModuleType<?> memoryModuleType);
+
+    /**
+     * Unregisters all memories.
+     *
+     * @param livingEntity given entity
+     */
+    void unregisterMemories(@NotNull LivingEntity livingEntity);
+
+    /**
+     * Gets the currently registered memory types.
+     *
+     * @param livingEntity given entity
+     * @return memory types
+     */
+    @NotNull
+    Collection<MemoryModuleType<?>> getMemoryTypes(@NotNull LivingEntity livingEntity);
+
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/memory/MemoryModuleType.java b/src/main/java/io/papermc/paper/entity/brain/memory/MemoryModuleType.java
new file mode 100644
index 0000000000000000000000000000000000000000..d1b6c60d30cbd5d1aa35f33ac4b9379d8e07413e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/memory/MemoryModuleType.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.entity.brain.memory;
+
+import org.bukkit.NamespacedKey;
+import org.bukkit.entity.memory.MemoryKey;
+
+import java.util.Optional;
+
+/**
+ * Represents type of memories with which Sensors store values and Activities operate.
+ * It has compatibility with Bukkit MemoryKey API {@link MemoryKey}.
+ * @param <U> Type of value which will stored in this memory.
+ */
+public interface MemoryModuleType<U> {
+    /**
+     *
+     * @return Optional containing MemoryKey if this memory module type associated with some vanilla memory key from bukkit API. {@link MemoryKey}
+     */
+    Optional<MemoryKey<U>> getMemoryKey();
+
+    /**
+     * Gets unique key for registering custom memory module types.
+     * @return key of this memory module type.
+     */
+    NamespacedKey getKey();
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/memory/MemoryPair.java b/src/main/java/io/papermc/paper/entity/brain/memory/MemoryPair.java
new file mode 100644
index 0000000000000000000000000000000000000000..db0be61b67cd16aee8aebdf8111c3c29a586c238
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/memory/MemoryPair.java
@@ -0,0 +1,9 @@
+package io.papermc.paper.entity.brain.memory;
+
+import org.bukkit.entity.memory.MemoryKey;
+
+/**
+ * A memory pair represents a memory and what key status it is required to have.
+ */
+public record MemoryPair(MemoryTypeStatus requiredStatus, MemoryModuleType<?> key) {
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/memory/MemoryTypeStatus.java b/src/main/java/io/papermc/paper/entity/brain/memory/MemoryTypeStatus.java
new file mode 100644
index 0000000000000000000000000000000000000000..7bb09e13eea46f031c1f19a33cc05964dc82e7e7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/memory/MemoryTypeStatus.java
@@ -0,0 +1,19 @@
+package io.papermc.paper.entity.brain.memory;
+
+/**
+ * Represents the current status that a memory type may be in.
+ */
+public enum MemoryTypeStatus {
+    /***
+     * Represents a memory type being only registered.
+     */
+    REGISTERED,
+    /***
+     * Represents a registered memory type with there currently not being a value present.
+     */
+    ABSENT,
+    /***
+     * Represents a registered memory type with there being a value present.
+     */
+    PRESENT
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/sensor/Sensor.java b/src/main/java/io/papermc/paper/entity/brain/sensor/Sensor.java
new file mode 100644
index 0000000000000000000000000000000000000000..e4086bb3b6b3c694cea6fc8dfe81340afc0d6ad1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/sensor/Sensor.java
@@ -0,0 +1,39 @@
+package io.papermc.paper.entity.brain.sensor;
+
+import io.papermc.paper.entity.brain.memory.MemoryModuleType;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.memory.MemoryKey;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Collection;
+import java.util.Set;
+
+/**
+ * Represents a brain sensor.
+ * These are periodically ticked depending on the given interval and
+ * are typically responsible for updating entity memories.
+ *
+ * @param <T> entity type
+ */
+public interface Sensor<T extends LivingEntity> {
+
+    /**
+     * @return the interval of this sensor.
+     */
+    int getInterval();
+
+    /**
+     * Ticks this sensor with the provided entity.
+     *
+     * @param entity provided entity
+     */
+    void tick(@NotNull T entity);
+
+    /**
+     * Gets the sensors that are required to be registered
+     * inorder for this sensor to normally be ticked.
+     * @return
+     */
+    @NotNull
+    Collection<MemoryModuleType<?>> requiredMemories();
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/sensor/SensorKey.java b/src/main/java/io/papermc/paper/entity/brain/sensor/SensorKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..3abd759c501ee9bc51b0504b07190e22d1097dd1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/sensor/SensorKey.java
@@ -0,0 +1,10 @@
+package io.papermc.paper.entity.brain.sensor;
+
+import org.bukkit.Keyed;
+
+/**
+ * Represents a key for a sensor.
+ */
+public interface SensorKey extends Keyed {
+
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/sensor/VanillaSensorKey.java b/src/main/java/io/papermc/paper/entity/brain/sensor/VanillaSensorKey.java
new file mode 100644
index 0000000000000000000000000000000000000000..ce883ff02a01cfe687369e370b6140638b21a39b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/sensor/VanillaSensorKey.java
@@ -0,0 +1,45 @@
+package io.papermc.paper.entity.brain.sensor;
+
+import org.bukkit.NamespacedKey;
+import org.bukkit.entity.memory.MemoryKey;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.HashMap;
+import java.util.Map;
+
+public final class VanillaSensorKey implements SensorKey {
+
+    public static final SensorKey NEAREST_ITEMS = of("nearest_items");
+    public static final SensorKey NEAREST_LIVING_ENTITIES = of("nearest_living_entities");
+    public static final SensorKey NEAREST_PLAYERS = of("nearest_players");
+    public static final SensorKey NEAREST_BED = of("nearest_bed");
+    public static final SensorKey HURT_BY = of("hurt_by");
+    public static final SensorKey VILLAGER_HOSTILES = of("villager_hostiles");
+    public static final SensorKey VILLAGER_BABIES = of("villager_babies");
+    public static final SensorKey SECONDARY_POIS = of("secondary_pois");
+    public static final SensorKey GOLEM_DETECTED = of("golem_detected");
+    public static final SensorKey PIGLIN_SPECIFIC_SENSOR = of("piglin_specific_sensor");
+    public static final SensorKey PIGLIN_BRUTE_SPECIFIC_SENSOR = of("piglin_brute_specific_sensor");
+    public static final SensorKey HOGLIN_SPECIFIC_SENSOR = of("hoglin_specific_sensor");
+    public static final SensorKey NEAREST_ADULT = of("nearest_adult");
+    public static final SensorKey AXOLOTL_ATTACKABLES = of("axolotl_attackables");
+    public static final SensorKey AXOLOTL_TEMPTATIONS = of("axolotl_temptations");
+    public static final SensorKey GOAT_TEMPTATIONS = of("goat_temptations");
+
+    private static SensorKey of(String key) {
+        return new VanillaSensorKey(NamespacedKey.minecraft(key));
+    }
+
+    private final NamespacedKey key;
+
+    VanillaSensorKey(NamespacedKey key) {
+        this.key = key;
+    }
+
+    @Override
+    public @NotNull NamespacedKey getKey() {
+        return key;
+    }
+
+}
diff --git a/src/main/java/org/bukkit/Bukkit.java b/src/main/java/org/bukkit/Bukkit.java
index 53c4e5ca208ee17c7c244e416c537c7b63edf194..e2af68fab17804faaba243f9de59c08c6fdaeeb5 100644
--- a/src/main/java/org/bukkit/Bukkit.java
+++ b/src/main/java/org/bukkit/Bukkit.java
@@ -52,6 +52,7 @@ import org.jetbrains.annotations.Contract;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import io.papermc.paper.util.JarManifests; // Paper
+import org.bukkit.entity.memory.MemoryKey;
 
 /**
  * Represents the Bukkit core, for version and Server singleton handling
@@ -2175,6 +2176,64 @@ public final class Bukkit {
     public static io.papermc.paper.datapack.DatapackManager getDatapackManager() {
         return server.getDatapackManager();
     }
+
+    /**
+     * Creates a custom activity key used in the mob brain api
+     * to register your own types.
+     *
+     * @param key activity identifier
+     * @return activity key
+     */
+    @NotNull
+    public static io.papermc.paper.entity.brain.activity.ActivityKey createActivityKey(@NotNull NamespacedKey key) {
+        return server.createActivityKey(key);
+    }
+
+    /**
+     * Creates a custom sensor key used in the mob brain api
+     * to register your own types.
+     *
+     * @param key sensor identifier
+     * @return sensor key
+     */
+    @NotNull
+    public static io.papermc.paper.entity.brain.sensor.SensorKey createSensorKey(@NotNull NamespacedKey key) {
+        return server.createSensorKey(key);
+    }
+
+    /**
+     * Creates a custom memory key used in the mob brain api
+     * to register your own types.
+     *
+     * @param key memory identifier
+     * @return memory key
+     */
+    @NotNull
+    public static <U> io.papermc.paper.entity.brain.memory.MemoryModuleType<U> createMemoryModuleType(@NotNull NamespacedKey key) {
+        return server.createMemoryModuleType(key);
+    }
+    
+    /**
+     * Creates a custom memory key used in the mob brain api
+     * to register your own types.
+     *
+     * @param key memory identifier
+     * @return memory key
+     */
+    @NotNull
+    public static <U> io.papermc.paper.entity.brain.memory.MemoryModuleType<U> createMemoryModuleType(@NotNull MemoryKey<U> key) {
+        return server.createMemoryModuleType(key);
+    }
+
+    /**
+     * Gets the brain manager.
+     *
+     * @return brain manager
+     */
+    @NotNull
+    public static io.papermc.paper.entity.brain.BrainManager getBrainManager() {
+        return server.getBrainManager();
+    }
     // Paper end
 
     @NotNull
diff --git a/src/main/java/org/bukkit/Server.java b/src/main/java/org/bukkit/Server.java
index e48af3822e9f118399c3a1c9358c56efae12e0da..24e0ed8b84bdd06fa2236dca6ad088a93b29242e 100644
--- a/src/main/java/org/bukkit/Server.java
+++ b/src/main/java/org/bukkit/Server.java
@@ -27,6 +27,7 @@ import org.bukkit.command.ConsoleCommandSender;
 import org.bukkit.command.PluginCommand;
 import org.bukkit.entity.Entity;
 import org.bukkit.entity.Player;
+import org.bukkit.entity.memory.MemoryKey;
 import org.bukkit.event.inventory.InventoryType;
 import org.bukkit.event.server.ServerListPingEvent;
 import org.bukkit.generator.ChunkGenerator;
@@ -1887,5 +1888,50 @@ public interface Server extends PluginMessageRecipient, net.kyori.adventure.audi
      */
     @NotNull
     io.papermc.paper.datapack.DatapackManager getDatapackManager();
+
+    /**
+     * Creates a custom activity key used in the mob brain api
+     * to register your own types.
+     *
+     * @param key activity identifier
+     * @return activity key
+     */
+    @NotNull
+    io.papermc.paper.entity.brain.activity.ActivityKey createActivityKey(@NotNull NamespacedKey key);
+
+    /**
+     * Creates a custom sensor key used in the mob brain api
+     * to register your own types.
+     *
+     * @param key sensor identifier
+     * @return sensor key
+     */
+    @NotNull
+    io.papermc.paper.entity.brain.sensor.SensorKey createSensorKey(@NotNull NamespacedKey key);
+
+    /**
+     * Creates a custom memory type used in the Mob Brain-API.
+     *
+     * @param key memory identifier
+     * @return memory key
+     */
+    @NotNull
+    <U> io.papermc.paper.entity.brain.memory.MemoryModuleType<U> createMemoryModuleType(@NotNull NamespacedKey key);
+
+    /**
+     * Creates a custom memory type used in the Mob Brain-API to register your own types.
+     *
+     * @param key memory identifier
+     * @return memory key
+     */
+    @NotNull
+    <U> io.papermc.paper.entity.brain.memory.MemoryModuleType<U> createMemoryModuleType(@NotNull MemoryKey<U> key);
+
+    /**
+     * Gets the brain manager.
+     * @return brain manager.
+     */
+    @NotNull
+    io.papermc.paper.entity.brain.BrainManager getBrainManager();
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/entity/Piglin.java b/src/main/java/org/bukkit/entity/Piglin.java
index 6fdc0e0bb62189dbf3cf9ce7a87b7fbb995956a3..cd45fa6c6d2ed183f1cd2f457bd7ff172704e1a7 100644
--- a/src/main/java/org/bukkit/entity/Piglin.java
+++ b/src/main/java/org/bukkit/entity/Piglin.java
@@ -8,7 +8,7 @@ import org.jetbrains.annotations.NotNull;
 /**
  * Represents a Piglin.
  */
-public interface Piglin extends PiglinAbstract, InventoryHolder, com.destroystokyo.paper.entity.RangedEntity { // Paper
+public interface Piglin extends PiglinAbstract, InventoryHolder, com.destroystokyo.paper.entity.RangedEntity {
 
     /**
      * Get whether the piglin is able to hunt hoglins.
diff --git a/src/main/java/org/bukkit/entity/Villager.java b/src/main/java/org/bukkit/entity/Villager.java
index 02ecc87a90bbd81e7d21279fac701ba41c74fd9f..ec171ff1de0f168abf38231ac546b586f30ff9f0 100644
--- a/src/main/java/org/bukkit/entity/Villager.java
+++ b/src/main/java/org/bukkit/entity/Villager.java
@@ -12,7 +12,7 @@ import org.jetbrains.annotations.Nullable; // Paper
 /**
  * Represents a villager NPC
  */
-public interface Villager extends AbstractVillager {
+public interface Villager extends AbstractVillager  {
 
     /**
      * Gets the current profession of this villager.
diff --git a/src/main/java/org/bukkit/entity/memory/MemoryKey.java b/src/main/java/org/bukkit/entity/memory/MemoryKey.java
index d023b6497c0f56ebcc8eeb4e3226ea9f974989ff..b45d3aef285a4262053317ab857f1278b37bbb78 100644
--- a/src/main/java/org/bukkit/entity/memory/MemoryKey.java
+++ b/src/main/java/org/bukkit/entity/memory/MemoryKey.java
@@ -17,11 +17,16 @@ import org.jetbrains.annotations.Nullable;
  *
  * @param <T> the class type of the memory value
  */
-public final class MemoryKey<T> implements Keyed {
+public class MemoryKey<T> implements Keyed {
 
     private final NamespacedKey namespacedKey;
     private final Class<T> tClass;
 
+    protected MemoryKey(NamespacedKey namespacedKey, Class<T> tClass, boolean dummy) {
+        this.namespacedKey = namespacedKey;
+        this.tClass = tClass;
+    }
+
     private MemoryKey(NamespacedKey namespacedKey, Class<T> tClass) {
         this.namespacedKey = namespacedKey;
         this.tClass = tClass;

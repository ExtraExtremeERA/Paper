From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Wed, 6 Jul 2022 23:00:36 -0400
Subject: [PATCH] Paper Plugins


diff --git a/build.gradle.kts b/build.gradle.kts
index 0660174a8c543b3e8ef317cfabcda88a6a53d844..9330ca21acf6f6a0e4caa6cc619d760aafc3a605 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -46,7 +46,7 @@ dependencies {
     implementation("org.ow2.asm:asm-commons:9.2")
     // Paper end
 
-    compileOnly("org.apache.maven:maven-resolver-provider:3.8.5")
+    api("org.apache.maven:maven-resolver-provider:3.8.5") // Paper, expose
     compileOnly("org.apache.maven.resolver:maven-resolver-connector-basic:1.7.3")
     compileOnly("org.apache.maven.resolver:maven-resolver-transport-http:1.7.3")
     compileOnly("com.google.code.findbugs:jsr305:1.3.9") // Paper
diff --git a/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java b/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java
index 76f2cb9cd99cad2a9484eab2becd8c36f1dd91b3..04cc721f95bfdf861f828cc853f7b8d12c9bbb1b 100644
--- a/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java
+++ b/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java
@@ -1,5 +1,6 @@
 package com.destroystokyo.paper.utils;
 
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
 import org.bukkit.plugin.PluginDescriptionFile;
 
 import java.util.logging.Level;
@@ -24,8 +25,21 @@ public class PaperPluginLogger extends Logger {
         return logger;
     }
 
-    private PaperPluginLogger(@NotNull PluginDescriptionFile description) {
-        super(description.getPrefix() != null ? description.getPrefix() : description.getName(), null);
+    // TODO
+    @NotNull
+    public static Logger getLogger(@NotNull PluginConfiguration configuration) {
+        Logger logger = new PaperPluginLogger(configuration);
+        if (!LogManager.getLogManager().addLogger(logger)) {
+            // Disable this if it's going to happen across reloads anyways...
+            //logger.log(Level.WARNING, "Could not insert plugin logger - one was already found: {}", LogManager.getLogManager().getLogger(this.getName()));
+            logger = LogManager.getLogManager().getLogger(configuration.getLoggingPrefix() != null ? configuration.getLoggingPrefix() : configuration.getIdentifier());
+        }
+
+        return logger;
+    }
+
+    private PaperPluginLogger(@NotNull PluginConfiguration description) {
+        super(description.getLoggingPrefix() != null ? description.getLoggingPrefix() : description.getIdentifier(), null);
     }
 
     @Override
diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrap.java b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrap.java
new file mode 100644
index 0000000000000000000000000000000000000000..721cdeacdbc74c23811fc0119e213e1d8df92275
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrap.java
@@ -0,0 +1,36 @@
+package io.papermc.paper.plugin.bootstrap;
+
+import io.papermc.paper.plugin.provider.util.ProviderUtil;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A plugin boostrap is meant for loading certain parts of the plugin before the server is loaded.
+ * <p>
+ * Plugin bootstrapping allows values to be initialized in certain parts of the server that might not be allowed
+ * when the server is running.
+ * <p>
+ * Your bootstrap class will be on the same classloader as your JavaPlugin.
+ * <p>
+ * <b>All calls to Bukkit may throw a NullPointerExceptions or return null unexpectedly. You should only call api methods that are explicitly documented to work in the bootstrapper</b>
+ */
+public interface PluginBootstrap {
+
+    /**
+     * Called by the server, allowing you to bootstrap with context that provides things like a logger and your shared plugin configuration file.
+     *
+     * @param context server provided context
+     */
+    void boostrap(@NotNull PluginBootstrapContext context);
+
+    /**
+     * Called by the server, allows you to create your own java plugin instance inorder to do things such as
+     * pass objects through the constructor.
+     * @param context server created bootstrap object
+     * @return java plugin instance
+     */
+    @NotNull
+    default JavaPlugin createPlugin(@NotNull PluginBootstrapContext context) {
+        return ProviderUtil.loadClass(context.getConfiguration().getMain(), JavaPlugin.class, this.getClass().getClassLoader());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContext.java b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContext.java
new file mode 100644
index 0000000000000000000000000000000000000000..110aff2466a861dc4a9d92d660c52d6ca326909c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContext.java
@@ -0,0 +1,46 @@
+package io.papermc.paper.plugin.bootstrap;
+
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+import java.util.logging.Logger;
+
+/**
+ * Contains context used for when a plugin's bootstrap class is executed.
+ */
+@ApiStatus.NonExtendable
+public interface PluginBootstrapContext {
+
+    /**
+     * Gets the plugin's configuration.
+     * @return configuration
+     */
+    @NotNull
+    PluginConfiguration getConfiguration();
+
+    /**
+     * Gets the path to the data directory for the plugin.
+     *
+     * @return plugin
+     */
+    @NotNull
+    Path getDataDirectory();
+
+    /**
+     * Gets the configuration file for this plugin.
+     *
+     * @return configuration file
+     */
+    @NotNull
+    Path getConfigurationFile();
+
+    /**
+     * Gets the logger used for this plugin.
+     *
+     * @return logger
+     */
+    @NotNull
+    Logger getLogger();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/loader/PluginLoader.java b/src/main/java/io/papermc/paper/plugin/loader/PluginLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..994bf078c5c6070f1ead31e28fd2ffd65774ed85
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/loader/PluginLoader.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.plugin.loader;
+
+import io.papermc.paper.plugin.provider.loader.PluginClasspathBuilder;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * A plugin loader is responsible for creating certain aspects of a plugin before it is created.
+ * <p>
+ * The goal of this is to allow certain configuration values to be moved and can instead be
+ * configured at run time inorder to make plugins a bit more dynamic.
+ * <p>
+ * It should be noted that this class will be called from a different classloader, this will cause any static values
+ * set in this class/any other classes loaded not to persist when the plugin loads.
+ */
+public interface PluginLoader {
+
+    /**
+     * Called by the server, allows you to configure the classpath that your plugin is run on.
+     * This allows you to configure dependencies for your plugin where jars can be downloaded or
+     * provided during runtime.
+     *
+     * @param classpathBuilder classpath builder
+     */
+    void classloader(@NotNull PluginClasspathBuilder classpathBuilder);
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/BukkitConfigurationWrapper.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/BukkitConfigurationWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..f5d3d758b1273647b054005d70414ac13a39c8cf
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/BukkitConfigurationWrapper.java
@@ -0,0 +1,132 @@
+package io.papermc.paper.plugin.provider.configuration;
+
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoadOrder;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+@ApiStatus.Internal
+public interface BukkitConfigurationWrapper extends PluginConfiguration {
+
+    /**
+     * Gets the bukkit configuration for this plugin configuration.
+     *
+     * @return bukkit configuration
+     */
+    PluginDescriptionFile spigotDescription();
+
+    @Override
+    default @NotNull String getIdentifier() {
+        return this.spigotDescription().getName();
+    }
+
+    @Override
+    default @NotNull String getVersion() {
+        return this.spigotDescription().getVersion();
+    }
+
+    @Override
+    default @NotNull String getMain() {
+        return this.spigotDescription().getMain();
+    }
+
+    @Override
+    default @NotNull String getDisplayName() {
+        return this.spigotDescription().getFullName();
+    }
+
+    @Override
+    default @NotNull String getLoggingPrefix() {
+        String prefix = this.spigotDescription().getPrefix();
+        if (prefix == null) {
+            return this.getIdentifier();
+        }
+
+        return prefix;
+    }
+
+    @Override
+    default @NotNull PluginLoadOrder getLoadPhase() {
+        return this.spigotDescription().getLoad();
+    }
+
+    @Override
+    default @NotNull List<String> getHardDependencies() {
+        return this.spigotDescription().getDepend();
+    }
+
+    @Override
+    default @NotNull List<String> getSoftDependencies() {
+        return this.spigotDescription().getSoftDepend();
+    }
+
+    @Override
+    default @NotNull List<String> getLoadBefore() {
+        return this.spigotDescription().getLoadBefore();
+    }
+
+    @Override
+    default @NotNull List<Permission> getPermissions() {
+        return this.spigotDescription().getPermissions();
+    }
+
+    @Override
+    default @NotNull PermissionDefault getDefaultPermission() {
+        return this.spigotDescription().getPermissionDefault();
+    }
+
+
+    @Override
+    default @NotNull String getApiVersion() {
+        String version = this.spigotDescription().getAPIVersion();
+        if (version == null) {
+            return "<1.13";
+        }
+
+        return version;
+    }
+
+    @Override
+    default @NotNull List<String> getProvides() {
+        return nullable(this.spigotDescription().getProvides());
+    }
+
+    @Override
+    default @Nullable String getWebsite() {
+        return this.spigotDescription().getWebsite();
+    }
+
+    // TODO
+    @Override
+    default boolean isTransitiveDependency(PluginConfiguration other) {
+        return true;
+    }
+
+    @Override
+    default @Nullable String getDescription() {
+        return this.spigotDescription().getDescription();
+    }
+
+    @Override
+    default @NotNull List<String> getAuthors() {
+        return nullable(this.spigotDescription().getAuthors());
+    }
+
+    @Override
+    default @NotNull List<String> getContributors() {
+        return nullable(this.spigotDescription().getContributors());
+    }
+
+    private static List<String> nullable(List<String> strings) {
+        if (strings == null) {
+            return List.of();
+        }
+
+        return nullable(strings);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/PluginConfiguration.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/PluginConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..18f418f67a9cfa1a53320ec5aa19b282552aaa09
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/PluginConfiguration.java
@@ -0,0 +1,178 @@
+package io.papermc.paper.plugin.provider.configuration;
+
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginLoadOrder;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.List;
+
+/**
+ * This class acts as an abstraction for a plugin configuration.
+ */
+public interface PluginConfiguration {
+
+    /**
+     * Gives the name of the plugin. This name is a unique identifier for
+     * plugins.
+     * <ul>
+     * <li>Will only contain alphanumeric characters, underscores, hyphon,
+     *     and period (a-z,A-Z,0-9,_.-).
+     * <li>Typically used for identifying the plugin data folder.
+     * <li>The is the token referenced in {@link #getHardDependencies()}, {@link
+     *     #getSoftDependencies()}, and {@link #getLoadBefore()}.
+     * </ul>
+     * <p>
+     * In the plugin.yml, this entry is named <code>name</code>.
+     * <p>
+     * Example:<blockquote><pre>name: MyPlugin</pre></blockquote>
+     *
+     * @return the name of the plugin
+     */
+    @NotNull
+    String getIdentifier();
+
+    /**
+     * Returns the name of a plugin, including the version.
+     *
+     * @return a descriptive name of the plugin and respective version
+     */
+    @NotNull
+    default String getDisplayName() {
+        return this.getIdentifier() + " v" + this.getVersion();
+    }
+
+    /**
+     * Gives the fully qualified name of the main class for a plugin.
+     * A {@link JavaPlugin} is expected at this location.
+     *
+     * @return the fully qualified main class for the plugin
+     */
+    @NotNull
+    String getMain();
+
+    /**
+     * Gives the phase of server startup that the plugin should be loaded.
+     *
+     * @return phase
+     */
+    @NotNull
+    PluginLoadOrder getLoadPhase();
+
+    /**
+     * Gets the version of this plugin
+     *
+     * @return version string
+     */
+    @NotNull
+    String getVersion();
+
+    /**
+     * Gets the prefix that should be used for the plugin logger.
+     *
+     * @return logger prefix
+     */
+    @NotNull
+    String getLoggingPrefix();
+
+    /**
+     * Gets a list of dependencies that are required for this plugin to load.
+     *
+     * @return immutable list of required dependencies
+     */
+    @NotNull
+    List<String> getHardDependencies();
+
+    /**
+     * Gets a list of dependencies that are used but not required for this plugin to load.
+     *
+     * @return immutable list of soft dependencies
+     */
+    @NotNull
+    List<String> getSoftDependencies();
+
+    /**
+     * Gets a list of dependencies that should be loaded before this plugin is loaded.
+     *
+     * @return immutable list of dependencies to load before
+     */
+    @NotNull
+    List<String> getLoadBefore();
+
+    /**
+     * Gets a list of plugins/dependencies that this plugin provides.
+     *
+     * @return immutable list of provided plugins/dependencies
+     */
+    @NotNull
+    List<String> getProvides();
+
+    /**
+     * Gives a list of authors that created this plugin.
+     *
+     * @return an immutable list of the plugin's authors
+     */
+    @NotNull
+    List<String> getAuthors();
+
+    /**
+     * Gets a list of contributors that created this plugin.
+     *
+     * @return an immutable list of the plugin's contributors
+     */
+    @NotNull
+    List<String> getContributors();
+
+    /**
+     * Gives a human-friendly description of the functionality the plugin
+     * provides.
+     *
+     * @return description or null if unset
+     */
+    @Nullable
+    String getDescription();
+
+    /**
+     * Gets the website for the plugin or the plugin's author.
+     *
+     * @return website or null if unset
+     */
+    @Nullable
+    String getWebsite();
+
+    /**
+     * Gets a list of permissions that are registered in this plugin configuration.
+     *
+     * @return an immutable list of permissions
+     */
+    // TODO: Do we even want this? Why not just use the bootstrapper
+    @NotNull
+    List<Permission> getPermissions();
+
+    /**
+     * Gets the default permission value for configured permissions.
+     *
+     * @return default permission
+     */
+    // TODO: Do we even want this? Why not just use the bootstrapper
+    @NotNull
+    PermissionDefault getDefaultPermission();
+
+    /**
+     * Gets the api version that this plugin supports.
+     *
+     * @return version
+     */
+    @NotNull
+    String getApiVersion();
+
+    /**
+     * Unfinished. // TODO:
+     *
+     * @param other
+     * @return
+     */
+    boolean isTransitiveDependency(@NotNull PluginConfiguration other);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/loader/PluginClasspathBuilder.java b/src/main/java/io/papermc/paper/plugin/provider/loader/PluginClasspathBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..ad54cffea1a34e14a374572b3b2b9ac8214d9172
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/loader/PluginClasspathBuilder.java
@@ -0,0 +1,31 @@
+package io.papermc.paper.plugin.provider.loader;
+
+import io.papermc.paper.plugin.provider.loader.library.ClassPathLibrary;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Class used for building classpath configurations in plugin loading.
+ */
+public interface PluginClasspathBuilder {
+
+    /**
+     * Adds a new classpath library to this classpath builder.
+     * <blockquote><pre>{@code
+     * public void classloader(PluginClasspathBuilder classpathBuilder) {
+     *     classpathBuilder.addLibrary(new JarLibrary(Path.of("bob.jar")));
+     *
+     *     MavenLibraryResolver resolver = new MavenLibraryResolver();
+     *     resolver.addDependency(new Dependency(new DefaultArtifact("namespace:identifier:version"), null));
+     *     resolver.addRepository(new RemoteRepository.Builder("my_repo", "default", "https://repo.mymavenrepo.com/repository/maven-public/").build());
+     *
+     *     classpathBuilder.addLibrary(resolver);
+     * }
+     *
+     * }</pre></blockquote>
+     *
+     * @param classPathLibrary library
+     * @return self
+     */
+    @NotNull
+    PluginClasspathBuilder addLibrary(@NotNull ClassPathLibrary classPathLibrary);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/loader/library/ClassPathLibrary.java b/src/main/java/io/papermc/paper/plugin/provider/loader/library/ClassPathLibrary.java
new file mode 100644
index 0000000000000000000000000000000000000000..446c38cbe75ad8993e77dcbd15c47058b682b414
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/loader/library/ClassPathLibrary.java
@@ -0,0 +1,17 @@
+package io.papermc.paper.plugin.provider.loader.library;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Responsible for loading libraries into the LibraryStore.
+ */
+public interface ClassPathLibrary {
+
+    /**
+     * Loads the correct jars into the librarystore.
+     *
+     * @param store library store
+     * @throws LibraryLoadingException if library loading failed for this classpath library
+     */
+    void addToLibraryStore(@NotNull LibraryStore store) throws LibraryLoadingException;
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/loader/library/LibraryLoadingException.java b/src/main/java/io/papermc/paper/plugin/provider/loader/library/LibraryLoadingException.java
new file mode 100644
index 0000000000000000000000000000000000000000..b4ede73e072a00830e0ceaf255aba069b21a757c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/loader/library/LibraryLoadingException.java
@@ -0,0 +1,15 @@
+package io.papermc.paper.plugin.provider.loader.library;
+
+/**
+ * Indicates that an exception has occured while loading a library.
+ */
+public class LibraryLoadingException extends RuntimeException {
+
+    public LibraryLoadingException(String s) {
+        super(s);
+    }
+
+    public LibraryLoadingException(String s, Exception e) {
+        super(s, e);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/loader/library/LibraryStore.java b/src/main/java/io/papermc/paper/plugin/provider/loader/library/LibraryStore.java
new file mode 100644
index 0000000000000000000000000000000000000000..6c67344660339b24568c1c30eed5ff3804c65bbc
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/loader/library/LibraryStore.java
@@ -0,0 +1,14 @@
+package io.papermc.paper.plugin.provider.loader.library;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+
+/**
+ * Represents a storage that stores library jars.
+ */
+public interface LibraryStore {
+
+    void addLibrary(@NotNull Path library);
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/loader/library/impl/JarLibrary.java b/src/main/java/io/papermc/paper/plugin/provider/loader/library/impl/JarLibrary.java
new file mode 100644
index 0000000000000000000000000000000000000000..8abdd019ea03e1ec1107c25dbaf83f6c81d74abd
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/loader/library/impl/JarLibrary.java
@@ -0,0 +1,34 @@
+package io.papermc.paper.plugin.provider.loader.library.impl;
+
+import io.papermc.paper.plugin.provider.loader.library.ClassPathLibrary;
+import io.papermc.paper.plugin.provider.loader.library.LibraryLoadingException;
+import io.papermc.paper.plugin.provider.loader.library.LibraryStore;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+/**
+ * A simple jar library, will error if the jar is not found.
+ */
+public class JarLibrary implements ClassPathLibrary {
+
+    private final Path path;
+
+    /**
+     * Creates a jar library with the given path.
+     *
+     * @param path given path
+     */
+    public JarLibrary(@NotNull Path path) {
+        this.path = path;
+    }
+
+    @Override
+    public void addToLibraryStore(@NotNull LibraryStore store) throws LibraryLoadingException {
+        if (Files.notExists(this.path)) {
+            throw new LibraryLoadingException("Could not find library at " + this.path);
+        }
+        store.addLibrary(this.path);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/loader/library/impl/maven/MavenLibraryResolver.java b/src/main/java/io/papermc/paper/plugin/provider/loader/library/impl/maven/MavenLibraryResolver.java
new file mode 100644
index 0000000000000000000000000000000000000000..59532a9c8440ae4303afe66dc0bc94b09041e3fc
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/loader/library/impl/maven/MavenLibraryResolver.java
@@ -0,0 +1,119 @@
+package io.papermc.paper.plugin.provider.loader.library.impl.maven;
+
+import io.papermc.paper.plugin.provider.loader.library.ClassPathLibrary;
+import io.papermc.paper.plugin.provider.loader.library.LibraryLoadingException;
+import io.papermc.paper.plugin.provider.loader.library.LibraryStore;
+import org.apache.maven.repository.internal.MavenRepositorySystemUtils;
+import org.eclipse.aether.DefaultRepositorySystemSession;
+import org.eclipse.aether.RepositorySystem;
+import org.eclipse.aether.collection.CollectRequest;
+import org.eclipse.aether.connector.basic.BasicRepositoryConnectorFactory;
+import org.eclipse.aether.graph.Dependency;
+import org.eclipse.aether.graph.DependencyFilter;
+import org.eclipse.aether.impl.DefaultServiceLocator;
+import org.eclipse.aether.repository.LocalRepository;
+import org.eclipse.aether.repository.RemoteRepository;
+import org.eclipse.aether.repository.RepositoryPolicy;
+import org.eclipse.aether.resolution.ArtifactResult;
+import org.eclipse.aether.resolution.DependencyRequest;
+import org.eclipse.aether.resolution.DependencyResolutionException;
+import org.eclipse.aether.resolution.DependencyResult;
+import org.eclipse.aether.spi.connector.RepositoryConnectorFactory;
+import org.eclipse.aether.spi.connector.transport.TransporterFactory;
+import org.eclipse.aether.transfer.AbstractTransferListener;
+import org.eclipse.aether.transfer.TransferCancelledException;
+import org.eclipse.aether.transfer.TransferEvent;
+import org.eclipse.aether.transport.http.HttpTransporterFactory;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * A maven library, this allows you to resolve jars from maven repositories.
+ * This class will automatically cache resolved libraries when needed into the libraries directory.
+ */
+public class MavenLibraryResolver implements ClassPathLibrary {
+
+    private static final Logger logger = Logger.getLogger("MavenLibraryResolver");
+
+    private final RepositorySystem repository;
+    private final DefaultRepositorySystemSession session;
+    private final List<RemoteRepository> repositories = new ArrayList<>();
+    private final List<Dependency> dependencies = new ArrayList<>();
+
+    private DependencyFilter filter = null;
+
+    public MavenLibraryResolver() {
+        DefaultServiceLocator locator = MavenRepositorySystemUtils.newServiceLocator();
+        locator.addService(RepositoryConnectorFactory.class, BasicRepositoryConnectorFactory.class);
+        locator.addService(TransporterFactory.class, HttpTransporterFactory.class);
+
+        this.repository = locator.getService(RepositorySystem.class);
+        this.session = MavenRepositorySystemUtils.newSession();
+
+        this.session.setChecksumPolicy(RepositoryPolicy.CHECKSUM_POLICY_FAIL);
+        this.session.setLocalRepositoryManager(this.repository.newLocalRepositoryManager(this.session, new LocalRepository("libraries")));
+        this.session.setTransferListener(new AbstractTransferListener() {
+            @Override
+            public void transferInitiated(@NotNull TransferEvent event) throws TransferCancelledException {
+                logger.log(Level.INFO, "Downloading {0}", event.getResource().getRepositoryUrl() + event.getResource().getResourceName());
+            }
+        });
+        this.session.setReadOnly();
+    }
+
+
+    /**
+     * Adds the provided dependency to the library resolver.
+     * The dependency from the first valid repository will be chosen.
+     *
+     * @param dependency provided dependency
+     * @see MavenLibraryResolver#addRepository(RemoteRepository)
+     */
+    public void addDependency(@NotNull Dependency dependency) {
+        this.dependencies.add(dependency);
+    }
+
+    /**
+     * Adds the provided repository to the library resolver.
+     * The order in which these are added does matter, as dependency resolving will start at the first added
+     * repository.
+     *
+     * @param remoteRepository provided repository
+     */
+    public void addRepository(@NotNull RemoteRepository remoteRepository) {
+        this.repositories.add(remoteRepository);
+    }
+
+    // Do we want this? We would need to do multiple resolveDependencies calls if we want a filter per repository.
+//    public void setFilter(DependencyFilter filter) {
+//        this.filter = filter;
+//    }
+
+    /**
+     * Resolves the provided dependencies and adds them to the library store.
+     *
+     * @param store library store
+     * @throws LibraryLoadingException if resolving a dependency failed
+     */
+    @Override
+    public void addToLibraryStore(@NotNull LibraryStore store) throws LibraryLoadingException {
+        List<RemoteRepository> repos = this.repository.newResolutionRepositories(this.session, this.repositories);
+
+        DependencyResult result;
+        try {
+            result = this.repository.resolveDependencies(this.session, new DependencyRequest(new CollectRequest((Dependency) null, this.dependencies, repos), this.filter));
+        } catch (DependencyResolutionException ex) {
+            throw new LibraryLoadingException("Error resolving libraries", ex);
+        }
+
+        for (ArtifactResult artifact : result.getArtifactResults()) {
+            File file = artifact.getArtifact().getFile();
+            store.addLibrary(file.toPath());
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/classloader/ConfiguredPluginClassLoader.java b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/ConfiguredPluginClassLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..56faf7465e47be62ba432f5368cda9f01f955507
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/ConfiguredPluginClassLoader.java
@@ -0,0 +1,16 @@
+package io.papermc.paper.plugin.provider.service.classloader;
+
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+@ApiStatus.Internal
+public interface ConfiguredPluginClassLoader {
+    PluginConfiguration getConfiguration();
+
+    Class<?> loadClass(@NotNull String name, boolean resolve, boolean checkGlobal, boolean checkLibraries) throws ClassNotFoundException;
+
+    // Called in the constructor, at the very top
+    void init(JavaPlugin plugin);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoaderStorage.java b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoaderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..f6a4842e67d3f12fb2e6b97b97139703263d472e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoaderStorage.java
@@ -0,0 +1,78 @@
+package io.papermc.paper.plugin.provider.service.classloader;
+
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+
+/**
+ * This is used for connecting multiple classloaders.
+ */
+@ApiStatus.Internal
+public final class PaperPluginClassLoaderStorage {
+
+    private static final boolean DISABLE_CLASS_PRIORITIZATION = Boolean.getBoolean("Paper.DisableClassPrioritization");
+
+    private final Map<String, ReentrantReadWriteLock> classLoadLock = new HashMap<>();
+    private final Map<String, Integer> classLoadLockCount = new HashMap<>();
+    public final List<ConfiguredPluginClassLoader> classLoaders = new CopyOnWriteArrayList<>();
+
+    public static final PaperPluginClassLoaderStorage INSTANCE = new PaperPluginClassLoaderStorage();
+
+    public PaperPluginClassLoaderStorage() {
+    }
+
+    public Class<?> getClassByName(String name, boolean resolve, PluginConfiguration pluginConfiguration, @Nullable ConfiguredPluginClassLoader requester) {
+        // make MT safe
+        java.util.concurrent.locks.ReentrantReadWriteLock lock;
+        synchronized (this.classLoadLock) {
+            lock = this.classLoadLock.computeIfAbsent(name, (x) -> new java.util.concurrent.locks.ReentrantReadWriteLock());
+            this.classLoadLockCount.compute(name, (x, prev) -> prev != null ? prev + 1 : 1);
+        }
+        lock.writeLock().lock();
+
+        try {
+            if (!DISABLE_CLASS_PRIORITIZATION && requester != null) {
+                try {
+                    return requester.loadClass(name, false, false, pluginConfiguration.isTransitiveDependency(requester.getConfiguration()));
+                } catch (ClassNotFoundException cnfe) {
+                }
+            }
+            for (ConfiguredPluginClassLoader loader : this.classLoaders) {
+                try {
+                    return loader.loadClass(name, resolve, false, pluginConfiguration.isTransitiveDependency(loader.getConfiguration()));
+                } catch (ClassNotFoundException cnfe) {
+                }
+            }
+        } finally {
+            synchronized (this.classLoadLock) {
+                lock.writeLock().unlock();
+                if (this.classLoadLockCount.get(name) == 1) {
+                    this.classLoadLock.remove(name);
+                    this.classLoadLockCount.remove(name);
+                } else {
+                    this.classLoadLockCount.compute(name, (x, prev) -> prev - 1);
+                }
+            }
+        }
+        return null;
+    }
+
+
+    public void add(ConfiguredPluginClassLoader classLoader) {
+        this.classLoaders.add(classLoader);
+    }
+
+    public void remove(ConfiguredPluginClassLoader loader) {
+        this.classLoaders.remove(loader);
+    }
+
+    public boolean contains(ConfiguredPluginClassLoader pluginLoader) {
+        return this.classLoaders.contains(pluginLoader);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/classloader/bytecode/ClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/bytecode/ClassloaderBytecodeModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..e58d18525fe590afaa4f5a305859c4ba3cf1578d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/bytecode/ClassloaderBytecodeModifier.java
@@ -0,0 +1,26 @@
+package io.papermc.paper.plugin.provider.service.classloader.bytecode;
+
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import org.jetbrains.annotations.ApiStatus;
+
+@ApiStatus.Internal
+public abstract class ClassloaderBytecodeModifier {
+
+    public static ClassloaderBytecodeModifier INSTANCE;
+
+    public static void setInstance(ClassloaderBytecodeModifier instance) {
+        if (INSTANCE != null)  {
+            throw new IllegalStateException();
+        }
+
+        INSTANCE = instance;
+    }
+
+    public static ClassloaderBytecodeModifier getInstance() {
+        return INSTANCE;
+    }
+
+
+    public abstract byte[] modify(PluginConfiguration config, byte[] bytecode);
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/util/NamespaceChecker.java b/src/main/java/io/papermc/paper/plugin/provider/util/NamespaceChecker.java
new file mode 100644
index 0000000000000000000000000000000000000000..1726825a808f77bef5a3d02fd89da1f717a03041
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/util/NamespaceChecker.java
@@ -0,0 +1,37 @@
+package io.papermc.paper.plugin.provider.util;
+
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+@ApiStatus.Internal
+public class NamespaceChecker {
+
+    private static final String[] QUICK_INVALID_NAMESPACES = {
+        "net.minecraft.",
+        "org.bukkit.",
+        "io.papermc.paper.",
+        "com.destroystokoyo.paper."
+    };
+
+    /**
+     * Used for a variety of namespaces that shouldn't be resolved and should instead be moved to
+     * other classloaders. We can assume this because only plugins should be using this classloader.
+     *
+     * @param name namespace
+     */
+    public static void validateNameSpaceForClassloading(@NotNull String name) throws ClassNotFoundException {
+        if (isValidNameSpace(name)) {
+            throw new ClassNotFoundException(name);
+        }
+    }
+
+    public static boolean isValidNameSpace(@NotNull String name) {
+        for (String string : QUICK_INVALID_NAMESPACES) {
+            if (name.startsWith(string)) {
+                return false;
+            }
+        }
+
+        return false;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/util/ProviderUtil.java b/src/main/java/io/papermc/paper/plugin/provider/util/ProviderUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..06fb087e8ee7f28b638a9f8819d3a0d272a65a9c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/util/ProviderUtil.java
@@ -0,0 +1,48 @@
+package io.papermc.paper.plugin.provider.util;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Consumer;
+
+@ApiStatus.Internal
+public class ProviderUtil {
+
+    public static <T> T loadClass(@NotNull String clazz, @NotNull Class<T> classType, @NotNull ClassLoader loader) {
+        return loadClass(clazz, classType, loader, null);
+    }
+
+    public static <T> T loadClass(@NotNull String clazz, @NotNull Class<T> classType, @NotNull ClassLoader loader, @NotNull Runnable onError) {
+        try {
+            T clazzInstance;
+
+            try {
+                Class<?> jarClass = Class.forName(clazz, true, loader);
+
+                Class<? extends T> pluginClass;
+                try {
+                    pluginClass = jarClass.asSubclass(classType);
+                } catch (ClassCastException ex) {
+                    throw new ClassCastException("class '%s' does not extend '%s'".formatted(clazz, classType));
+                }
+
+                clazzInstance = pluginClass.getDeclaredConstructor().newInstance();
+            } catch (IllegalAccessException exception) {
+                throw new RuntimeException("No public constructor");
+            } catch (InstantiationException exception) {
+                throw new RuntimeException("Abnormal plugin type", exception);
+            }
+
+            return clazzInstance;
+        } catch (Throwable e) {
+            if (onError != null) {
+                onError.run();
+            }
+            SneakyThrow.sneaky(e);
+        }
+
+        throw new AssertionError(); // Shouldn't happen
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/registry/RegistryAccess.java b/src/main/java/io/papermc/paper/registry/RegistryAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..ce66c664003e80087df88bded37ef17bd398bf85
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/RegistryAccess.java
@@ -0,0 +1,16 @@
+package io.papermc.paper.registry;
+
+import org.jetbrains.annotations.NotNull;
+
+public class RegistryAccess {
+
+    /**
+     * Stub
+     *
+     * @return
+     */
+    @NotNull
+    public static RegistryAccess getInstance() {
+        return new RegistryAccess();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/PluginCommand.java b/src/main/java/org/bukkit/command/PluginCommand.java
index 1dbbc244309043b18c1d71707c4fb066c0d0e02d..08d3ff24d5318b0c77d6467bcb705bffac202842 100644
--- a/src/main/java/org/bukkit/command/PluginCommand.java
+++ b/src/main/java/org/bukkit/command/PluginCommand.java
@@ -14,7 +14,7 @@ public final class PluginCommand extends Command implements PluginIdentifiableCo
     private CommandExecutor executor;
     private TabCompleter completer;
 
-    protected PluginCommand(@NotNull String name, @NotNull Plugin owner) {
+    public PluginCommand(@NotNull String name, @NotNull Plugin owner) { // Paper
         super(name);
         this.executor = owner;
         this.owningPlugin = owner;
diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
index b8623575b1c1b565560c2dd6438190716845a652..785952d60df7c0ab7b247ba81d1970b5a90e5340 100644
--- a/src/main/java/org/bukkit/command/SimpleCommandMap.java
+++ b/src/main/java/org/bukkit/command/SimpleCommandMap.java
@@ -33,7 +33,7 @@ public class SimpleCommandMap implements CommandMap {
     private void setDefaultCommands() {
         register("bukkit", new VersionCommand("version"));
         register("bukkit", new ReloadCommand("reload"));
-        register("bukkit", new PluginsCommand("plugins"));
+        //register("bukkit", new PluginsCommand("plugins")); Paper
         register("bukkit", new co.aikar.timings.TimingsCommand("timings")); // Paper
     }
 
diff --git a/src/main/java/org/bukkit/plugin/Plugin.java b/src/main/java/org/bukkit/plugin/Plugin.java
index 08aef59d8443038771704d9587e31f299e587307..6d3acdc3391495e7b05bcc52923ac9009e952e6e 100644
--- a/src/main/java/org/bukkit/plugin/Plugin.java
+++ b/src/main/java/org/bukkit/plugin/Plugin.java
@@ -30,10 +30,20 @@ public interface Plugin extends TabExecutor {
      * Returns the plugin.yaml file containing the details for this plugin
      *
      * @return Contents of the plugin.yaml file
+     * @deprecated May be inaccurate due to different plugin implementations.
+     * @see Plugin#getConfiguration()
      */
+    @Deprecated // Paper
     @NotNull
     public PluginDescriptionFile getDescription();
 
+    /**
+     * Gets the plugin configuration for this plugin.
+     * @return configuration
+     */
+    @NotNull
+    io.papermc.paper.plugin.provider.configuration.PluginConfiguration getConfiguration();
+
     /**
      * Gets a {@link FileConfiguration} for this plugin, read through
      * "config.yml"
diff --git a/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java b/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
index 0c9f4d1e9104fa6951114c1f9ec954dfcc749196..f570eb57b155b5f0f2302a365df483a0ce1d22d5 100644
--- a/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
+++ b/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
@@ -194,7 +194,7 @@ import org.yaml.snakeyaml.nodes.Tag;
  *      inferno.burningdeaths: true
  *</pre></blockquote>
  */
-public final class PluginDescriptionFile {
+public class PluginDescriptionFile implements io.papermc.paper.plugin.provider.configuration.BukkitConfigurationWrapper { // Paper
     private static final Pattern VALID_NAME = Pattern.compile("^[A-Za-z0-9 _.-]+$");
     private static final ThreadLocal<Yaml> YAML = new ThreadLocal<Yaml>() {
         @Override
@@ -254,6 +254,35 @@ public final class PluginDescriptionFile {
     private Set<PluginAwareness> awareness = ImmutableSet.of();
     private String apiVersion = null;
     private List<String> libraries = ImmutableList.of();
+    // Paper start - oh my goddddd
+    /**
+     * Don't use this.
+     */
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public PluginDescriptionFile(String rawName, String name, List<String> provides, String main, String classLoaderOf, List<String> depend, List<String> softDepend, List<String> loadBefore, String version, Map<String, Map<String, Object>> commands, String description, List<String> authors, List<String> contributors, String website, String prefix, PluginLoadOrder order, List<Permission> permissions, PermissionDefault defaultPerm, Set<PluginAwareness> awareness, String apiVersion, List<String> libraries) {
+        this.rawName = rawName;
+        this.name = name;
+        this.provides = provides;
+        this.main = main;
+        this.classLoaderOf = classLoaderOf;
+        this.depend = depend;
+        this.softDepend = softDepend;
+        this.loadBefore = loadBefore;
+        this.version = version;
+        this.commands = commands;
+        this.description = description;
+        this.authors = authors;
+        this.contributors = contributors;
+        this.website = website;
+        this.prefix = prefix;
+        this.order = order;
+        this.permissions = permissions;
+        this.defaultPerm = defaultPerm;
+        this.awareness = awareness;
+        this.apiVersion = apiVersion;
+        this.libraries = libraries;
+    }
+    // Paper end
 
     public PluginDescriptionFile(@NotNull final InputStream stream) throws InvalidDescriptionException {
         loadMap(asMap(YAML.get().load(stream)));
@@ -365,8 +394,7 @@ public final class PluginDescriptionFile {
      *
      * @return the version of the plugin
      */
-    @NotNull
-    public String getVersion() {
+    public @NotNull String getVersion() {
         return version;
     }
 
@@ -392,8 +420,7 @@ public final class PluginDescriptionFile {
      *
      * @return the fully qualified main class for the plugin
      */
-    @NotNull
-    public String getMain() {
+    public @NotNull String getMain() {
         return main;
     }
 
@@ -412,8 +439,7 @@ public final class PluginDescriptionFile {
      *
      * @return description of this plugin, or null if not specified
      */
-    @Nullable
-    public String getDescription() {
+    public @NotNull String getDescription() {
         return description;
     }
 
@@ -1270,4 +1296,11 @@ public final class PluginDescriptionFile {
     public String getRawName() {
         return rawName;
     }
+    // Paper
+    @NotNull
+    @Override
+    public PluginDescriptionFile spigotDescription() {
+        return this;
+    }
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/plugin/SimplePluginManager.java b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
index ed07f5820281b139739f673fa4e25171de81b894..19f40e389afce2ff8c8dc6820f3534882099d983 100644
--- a/src/main/java/org/bukkit/plugin/SimplePluginManager.java
+++ b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
@@ -55,6 +55,8 @@ public final class SimplePluginManager implements PluginManager {
     private final Map<String, Map<Permissible, Boolean>> permSubs = new HashMap<String, Map<Permissible, Boolean>>();
     private final Map<Boolean, Map<Permissible, Boolean>> defSubs = new HashMap<Boolean, Map<Permissible, Boolean>>();
     private boolean useTimings = false;
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public org.bukkit.plugin.java.JavaPluginLoader loader;
 
     public SimplePluginManager(@NotNull Server instance, @NotNull SimpleCommandMap commandMap) {
         server = instance;
@@ -81,6 +83,7 @@ public final class SimplePluginManager implements PluginManager {
             try {
                 constructor = loader.getConstructor(Server.class);
                 instance = constructor.newInstance(server);
+                if (instance instanceof org.bukkit.plugin.java.JavaPluginLoader javaPluginLoader) this.loader = javaPluginLoader; // Paper
             } catch (NoSuchMethodException ex) {
                 String className = loader.getName();
 
@@ -410,7 +413,12 @@ public final class SimplePluginManager implements PluginManager {
                 result = loader.loadPlugin(file);
             }
         }
-
+    // Paper start
+        return loadPlugin(result);
+    }
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public synchronized Plugin loadPlugin(@Nullable Plugin result) throws UnknownDependencyException {
+    // Paper end
         if (result != null) {
             plugins.add(result);
             lookupNames.put(result.getDescription().getName().toLowerCase(java.util.Locale.ENGLISH), result); // Paper
@@ -923,13 +931,17 @@ public final class SimplePluginManager implements PluginManager {
         return new HashSet<Permission>(permissions.values());
     }
 
-    public boolean isTransitiveDepend(@NotNull PluginDescriptionFile plugin, @NotNull PluginDescriptionFile depend) {
+    // Paper start
+    public boolean isTransitiveDepend(@NotNull io.papermc.paper.plugin.provider.configuration.PluginConfiguration plugin, @NotNull io.papermc.paper.plugin.provider.configuration.PluginConfiguration depend) {
+    // Paper end
         Preconditions.checkArgument(plugin != null, "plugin");
         Preconditions.checkArgument(depend != null, "depend");
 
-        if (dependencyGraph.nodes().contains(plugin.getName())) {
-            Set<String> reachableNodes = Graphs.reachableNodes(dependencyGraph, plugin.getName());
-            if (reachableNodes.contains(depend.getName())) {
+        // Paper start
+        if (dependencyGraph.nodes().contains(plugin.getIdentifier())) {
+            Set<String> reachableNodes = Graphs.reachableNodes(dependencyGraph, plugin.getIdentifier());
+            if (reachableNodes.contains(depend.getIdentifier())) {
+        // Paper end
                 return true;
             }
             for (String provided : depend.getProvides()) {
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
index 3bea5dd67ad0393160ccede4ac99a3c7baa1803b..1d14ce402a05749e45c62c9ed5faffb0b14cf143 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
@@ -38,19 +38,21 @@ public abstract class JavaPlugin extends PluginBase {
     private Server server = null;
     private File file = null;
     private PluginDescriptionFile description = null;
+    private io.papermc.paper.plugin.provider.configuration.PluginConfiguration pluginConfiguration = null;
     private File dataFolder = null;
     private ClassLoader classLoader = null;
     private boolean naggable = true;
     private FileConfiguration newConfig = null;
     private File configFile = null;
-    Logger logger = null; // Paper - PluginLogger -> Logger, package-private
+    public Logger logger = null; // Paper - PluginLogger -> Logger, package-private, public
 
     public JavaPlugin() {
-        final ClassLoader classLoader = this.getClass().getClassLoader();
-        if (!(classLoader instanceof PluginClassLoader)) {
-            throw new IllegalStateException("JavaPlugin requires " + PluginClassLoader.class.getName());
+        // Paper start
+        if (this.getClass().getClassLoader() instanceof io.papermc.paper.plugin.provider.service.classloader.ConfiguredPluginClassLoader configuredPluginClassLoader) {
+            configuredPluginClassLoader.init(this);
+        } else {
+            throw new IllegalStateException("JavaPlugin requires to be created by a valid classloader.");
         }
-        ((PluginClassLoader) classLoader).initialize(this);
     }
 
     protected JavaPlugin(@NotNull final JavaPluginLoader loader, @NotNull final PluginDescriptionFile description, @NotNull final File dataFolder, @NotNull final File file) {
@@ -127,6 +129,11 @@ public abstract class JavaPlugin extends PluginBase {
         return description;
     }
 
+    @Nullable
+    public final io.papermc.paper.plugin.provider.configuration.PluginConfiguration getConfiguration() {
+        return this.pluginConfiguration;
+    }
+
     @NotNull
     @Override
     public FileConfiguration getConfig() {
@@ -268,8 +275,12 @@ public abstract class JavaPlugin extends PluginBase {
         }
     }
 
-
-    final void init(@NotNull PluginLoader loader, @NotNull Server server, @NotNull PluginDescriptionFile description, @NotNull File dataFolder, @NotNull File file, @NotNull ClassLoader classLoader) {
+    // Paper start
+    public final void init(@NotNull PluginLoader loader, @NotNull Server server, @NotNull PluginDescriptionFile description, @NotNull File dataFolder, @NotNull File file, @NotNull ClassLoader classLoader) {
+        init(loader, server, description, dataFolder, file, classLoader, description);
+    }
+    public final void init(@NotNull PluginLoader loader, @NotNull Server server, @NotNull PluginDescriptionFile description, @NotNull File dataFolder, @NotNull File file, @NotNull ClassLoader classLoader, @Nullable io.papermc.paper.plugin.provider.configuration.PluginConfiguration configuration) {
+    // Paper end
         this.loader = loader;
         this.server = server;
         this.file = file;
@@ -281,6 +292,7 @@ public abstract class JavaPlugin extends PluginBase {
         if (this.logger == null) {
             this.logger = com.destroystokyo.paper.utils.PaperPluginLogger.getLogger(this.description);
         }
+        this.pluginConfiguration = configuration;
         // Paper end
     }
 
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
index 8ff78fad47f6086aa289e32590f4fbec24b3d500..e5578d90fc628028cb1edfb5af35d764bad807f8 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -5,27 +5,25 @@ import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
-import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
-import java.util.List;
 import java.util.Map;
 import java.util.Set;
-import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.jar.JarEntry;
 import java.util.jar.JarFile;
 import java.util.logging.Level;
 import java.util.regex.Pattern;
+
+import io.papermc.paper.plugin.provider.service.classloader.PaperPluginClassLoaderStorage;
 import org.bukkit.Server;
 import org.bukkit.Warning;
 import org.bukkit.Warning.WarningState;
 import org.bukkit.configuration.serialization.ConfigurationSerializable;
 import org.bukkit.configuration.serialization.ConfigurationSerialization;
 import org.bukkit.event.Event;
-import org.bukkit.event.EventException;
 import org.bukkit.event.EventHandler;
 import org.bukkit.event.Listener;
 import org.bukkit.event.server.PluginDisableEvent;
@@ -43,7 +41,6 @@ import org.bukkit.plugin.TimedRegisteredListener;
 import org.bukkit.plugin.UnknownDependencyException;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
-import org.spigotmc.CustomTimingsHandler; // Spigot
 import org.yaml.snakeyaml.error.YAMLException;
 
 /**
@@ -55,7 +52,7 @@ public final class JavaPluginLoader implements PluginLoader {
     private final Pattern[] fileFilters = new Pattern[]{Pattern.compile("\\.jar$")};
     private final Map<String, java.util.concurrent.locks.ReentrantReadWriteLock> classLoadLock = new java.util.HashMap<String, java.util.concurrent.locks.ReentrantReadWriteLock>(); // Paper
     private final Map<String, Integer> classLoadLockCount = new java.util.HashMap<String, Integer>(); // Paper
-    private final List<PluginClassLoader> loaders = new CopyOnWriteArrayList<PluginClassLoader>();
+    public final PaperPluginClassLoaderStorage loaders = PaperPluginClassLoaderStorage.INSTANCE; // Paper
     private final LibraryLoader libraryLoader;
 
     /**
@@ -93,6 +90,12 @@ public final class JavaPluginLoader implements PluginLoader {
         } catch (InvalidDescriptionException ex) {
             throw new InvalidPluginException(ex);
         }
+        // Paper start
+        return this.loadPlugin(description, file);
+    }
+    @NotNull
+    public Plugin loadPlugin(@NotNull final PluginDescriptionFile description, File file) throws InvalidPluginException {
+        // Paper end
 
         final File parentFile = this.server.getPluginsFolder(); // Paper
         final File dataFolder = new File(parentFile, description.getName());
@@ -214,6 +217,7 @@ public final class JavaPluginLoader implements PluginLoader {
         return getClassByName(name, resolve, description, null);
     }
     Class<?> getClassByName(final String name, boolean resolve, PluginDescriptionFile description, PluginClassLoader requester) {
+        if (true) return loaders.getClassByName(name, resolve, description, requester); // Paper
         // Paper end
         // Paper start - make MT safe
         java.util.concurrent.locks.ReentrantReadWriteLock lock;
@@ -230,12 +234,7 @@ public final class JavaPluginLoader implements PluginLoader {
             }
             // Paper end
         // Paper end
-        for (PluginClassLoader loader : loaders) {
-            try {
-                return loader.loadClass0(name, resolve, false, ((SimplePluginManager) server.getPluginManager()).isTransitiveDepend(description, loader.plugin.getDescription()));
-            } catch (ClassNotFoundException cnfe) {
-            }
-        }
+        // Paper - remove implementation
         // Paper start - make MT safe
         } finally {
             synchronized (classLoadLock) {
@@ -359,12 +358,14 @@ public final class JavaPluginLoader implements PluginLoader {
 
             JavaPlugin jPlugin = (JavaPlugin) plugin;
 
+            if (jPlugin.getClassLoader() instanceof PluginClassLoader) { // Paper
             PluginClassLoader pluginLoader = (PluginClassLoader) jPlugin.getClassLoader();
 
             if (!loaders.contains(pluginLoader)) {
                 loaders.add(pluginLoader);
                 server.getLogger().log(Level.WARNING, "Enabled plugin with unregistered PluginClassLoader " + plugin.getDescription().getFullName());
             }
+            } // Paper
 
             try {
                 jPlugin.setEnabled(true);
diff --git a/src/main/java/org/bukkit/plugin/java/LibraryLoader.java b/src/main/java/org/bukkit/plugin/java/LibraryLoader.java
index 6d634b0ea813ccb19f1562a7d0e5a59cea4eab21..4eec9316e4447701732c944fa84c64a009a5c394 100644
--- a/src/main/java/org/bukkit/plugin/java/LibraryLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/LibraryLoader.java
@@ -36,7 +36,7 @@ import org.eclipse.aether.transport.http.HttpTransporterFactory;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-class LibraryLoader
+public class LibraryLoader
 {
 
     private final Logger logger;
diff --git a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
index 345394132df70593800127d34a38f8f8a4dafe00..5ad4164889c06a2d49529bde1de0deb0d8cde2f4 100644
--- a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
@@ -29,7 +29,7 @@ import org.jetbrains.annotations.Nullable;
 /**
  * A ClassLoader for plugins, to allow shared classes across multiple plugins
  */
-public final class PluginClassLoader extends URLClassLoader { // Spigot
+public final class PluginClassLoader extends URLClassLoader implements io.papermc.paper.plugin.provider.service.classloader.ConfiguredPluginClassLoader { // Spigot // Paper
     public JavaPlugin getPlugin() { return plugin; } // Spigot
     private final JavaPluginLoader loader;
     private final Map<String, Class<?>> classes = new ConcurrentHashMap<String, Class<?>>();
@@ -97,6 +97,21 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
     public Enumeration<URL> getResources(String name) throws IOException {
         return findResources(name);
     }
+    // Paper start
+    @Override
+    public Class<?> loadClass(@NotNull String name, boolean resolve, boolean checkGlobal, boolean checkLibraries) throws ClassNotFoundException {
+        return this.loadClass0(name, resolve, checkGlobal, checkLibraries);
+    }
+    @Override
+    public io.papermc.paper.plugin.provider.configuration.PluginConfiguration getConfiguration() {
+        return this.description;
+    }
+
+    @Override
+    public void init(JavaPlugin plugin) {
+        this.initialize(plugin);
+    }
+    // Paper end
 
     @Override
     protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
@@ -222,7 +237,7 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
         return classes.values();
     }
 
-    synchronized void initialize(@NotNull JavaPlugin javaPlugin) {
+    public synchronized void initialize(@NotNull JavaPlugin javaPlugin) { // Paper
         Preconditions.checkArgument(javaPlugin != null, "Initializing plugin cannot be null");
         Preconditions.checkArgument(javaPlugin.getClass().getClassLoader() == this, "Cannot initialize plugin outside of this class loader");
         if (this.plugin != null || this.pluginInit != null) {
diff --git a/src/test/java/org/bukkit/plugin/TestPlugin.java b/src/test/java/org/bukkit/plugin/TestPlugin.java
index a8be3e23e3e280ad301d9530de50028515612966..5395da02ddcceacc4186647c8c87cfbc061f3aae 100644
--- a/src/test/java/org/bukkit/plugin/TestPlugin.java
+++ b/src/test/java/org/bukkit/plugin/TestPlugin.java
@@ -32,6 +32,12 @@ public class TestPlugin extends PluginBase {
     public PluginDescriptionFile getDescription() {
         return new PluginDescriptionFile(pluginName, "1.0", "test.test");
     }
+    // Paper start
+    @Override
+    public io.papermc.paper.plugin.provider.configuration.PluginConfiguration getConfiguration() {
+        return getDescription();
+    }
+    // Paper end
 
     @Override
     public FileConfiguration getConfig() {

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Wed, 6 Jul 2022 23:00:36 -0400
Subject: [PATCH] Paper Plugins


diff --git a/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java b/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java
index 76f2cb9cd99cad2a9484eab2becd8c36f1dd91b3..04cc721f95bfdf861f828cc853f7b8d12c9bbb1b 100644
--- a/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java
+++ b/src/main/java/com/destroystokyo/paper/utils/PaperPluginLogger.java
@@ -1,5 +1,6 @@
 package com.destroystokyo.paper.utils;
 
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
 import org.bukkit.plugin.PluginDescriptionFile;
 
 import java.util.logging.Level;
@@ -24,8 +25,21 @@ public class PaperPluginLogger extends Logger {
         return logger;
     }
 
-    private PaperPluginLogger(@NotNull PluginDescriptionFile description) {
-        super(description.getPrefix() != null ? description.getPrefix() : description.getName(), null);
+    // TODO
+    @NotNull
+    public static Logger getLogger(@NotNull PluginConfiguration configuration) {
+        Logger logger = new PaperPluginLogger(configuration);
+        if (!LogManager.getLogManager().addLogger(logger)) {
+            // Disable this if it's going to happen across reloads anyways...
+            //logger.log(Level.WARNING, "Could not insert plugin logger - one was already found: {}", LogManager.getLogManager().getLogger(this.getName()));
+            logger = LogManager.getLogManager().getLogger(configuration.getLoggingPrefix() != null ? configuration.getLoggingPrefix() : configuration.getIdentifier());
+        }
+
+        return logger;
+    }
+
+    private PaperPluginLogger(@NotNull PluginConfiguration description) {
+        super(description.getLoggingPrefix() != null ? description.getLoggingPrefix() : description.getIdentifier(), null);
     }
 
     @Override
diff --git a/src/main/java/io/papermc/paper/plugin/Initializer.java b/src/main/java/io/papermc/paper/plugin/Initializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..8c43fb9c04cf92e04f4ca6a1a02de7585764669e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/Initializer.java
@@ -0,0 +1,10 @@
+package io.papermc.paper.plugin;
+
+/**
+ *
+ */
+public interface Initializer {
+
+    void initialize();
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/PluginProvider.java b/src/main/java/io/papermc/paper/plugin/provider/PluginProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..35fc4d4f7cbf90e90115658c21ac0faf7e9c86f2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/PluginProvider.java
@@ -0,0 +1,29 @@
+package io.papermc.paper.plugin.provider;
+
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+import org.slf4j.Logger;
+
+import java.nio.file.Path;
+import java.util.jar.JarFile;
+
+/*
+Plugin providers are meant to be the initial pre-loading stage of a plugin.
+This allows the plugin to be interacted with without truly messing with it.
+ */
+@ApiStatus.Internal
+public interface PluginProvider<T> {
+
+    @NotNull
+    Path getSource();
+
+    JarFile file();
+
+    T createInstance();
+
+    PluginConfiguration getConfiguration();
+
+    Logger getLogger();
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/BukkitConfigurationWrapper.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/BukkitConfigurationWrapper.java
new file mode 100644
index 0000000000000000000000000000000000000000..6abb1aa03defe47c2194fe936eba08a8525c4192
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/BukkitConfigurationWrapper.java
@@ -0,0 +1,105 @@
+package io.papermc.paper.plugin.provider.configuration;
+
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoadOrder;
+
+import java.util.List;
+import java.util.Map;
+
+public interface BukkitConfigurationWrapper extends PluginConfiguration {
+
+    PluginDescriptionFile spigotDescription();
+
+    @Override
+    default String getIdentifier() {
+        return this.spigotDescription().getName();
+    }
+
+    @Override
+    default String getVersion() {
+        return this.spigotDescription().getVersion();
+    }
+
+    @Override
+    default String getMain() {
+        return this.spigotDescription().getMain();
+    }
+
+    @Override
+    default String getDisplayName() {
+        return this.spigotDescription().getFullName();
+    }
+
+    @Override
+    default String getLoggingPrefix() {
+        return this.spigotDescription().getPrefix();
+    }
+
+    @Override
+    default PluginLoadOrder getLoadOrder() {
+        return this.spigotDescription().getLoad();
+    }
+
+    @Override
+    default List<String> getHardDependencies() {
+        return this.spigotDescription().getDepend();
+    }
+
+    @Override
+    default List<String> getSoftDependencies() {
+        return this.spigotDescription().getSoftDepend();
+    }
+
+    @Override
+    default List<String> getLoadBefore() {
+        return null;
+    }
+
+    @Override
+    default PermissionDefault getDefaultPermission() {
+        return this.spigotDescription().getDefaultPermission();
+    }
+
+
+    @Override
+    default String getApiVersion() {
+        return this.spigotDescription().getAPIVersion();
+    }
+
+    @Override
+    default List<String> getProvides() {
+        return this.spigotDescription().getProvides();
+    }
+
+    @Override
+    default String getWebsite() {
+        return this.spigotDescription().getWebsite();
+    }
+
+    // TODO
+    @Override
+    default boolean isTransitiveDependency(PluginConfiguration other) {
+        return true;
+    }
+
+    @Override
+    default Map<String, Map<String, Object>> getRawCommands() {
+        return this.spigotDescription().getCommands();
+    }
+
+    @Override
+    default String getDescription() {
+        return this.spigotDescription().getDescription();
+    }
+
+    @Override
+    default List<String> getAuthors() {
+        return this.spigotDescription().getAuthors();
+    }
+
+    @Override
+    default List<String> getContributors() {
+        return this.spigotDescription().getContributors();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/PluginConfiguration.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/PluginConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..cc95602f3f2db155ef8c434b9ce30e02b8c4a39d
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/PluginConfiguration.java
@@ -0,0 +1,49 @@
+package io.papermc.paper.plugin.provider.configuration;
+
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginLoadOrder;
+
+import java.util.List;
+import java.util.Map;
+
+public interface PluginConfiguration {
+
+    String getIdentifier();
+
+    String getMain();
+
+    String getVersion();
+
+    String getDisplayName();
+
+    String getLoggingPrefix();
+
+    List<String> getHardDependencies();
+
+    List<String> getSoftDependencies();
+
+    List<String> getLoadBefore();
+
+    PluginLoadOrder getLoadOrder();
+
+    boolean isTransitiveDependency(PluginConfiguration other);
+
+
+    Map<String, Map<String, Object>> getRawCommands();
+
+    String getDescription();
+
+    List<String> getAuthors();
+
+    List<String> getContributors();
+
+    String getWebsite();
+
+    Map<?, ?> getLazyPermissions();
+
+    PermissionDefault getDefaultPermission();
+
+    String getApiVersion();
+
+    List<String> getProvides();
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoader.java b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..4f5c44b09d408b4c4e0f650b4b1a4b85bbb630f2
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoader.java
@@ -0,0 +1,252 @@
+package io.papermc.paper.plugin.provider.service.classloader;
+
+import com.google.common.io.ByteStreams;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.serialization.ConfigurationSerializable;
+import org.bukkit.configuration.serialization.ConfigurationSerialization;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoader;
+import org.bukkit.plugin.SimplePluginManager;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.security.CodeSigner;
+import java.security.CodeSource;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.jar.Manifest;
+
+public class PaperPluginClassLoader extends URLClassLoader {
+
+    private final PaperPluginClassLoaderStorage loader;
+
+    private final Map<String, Class<?>> loadedClasses = new ConcurrentHashMap<>();
+
+    private final PluginProvider<?> pluginProvider;
+    private final PluginConfiguration pluginConfiguration;
+    private final Manifest jarManifest;
+    private final URL jarUrl;
+
+    private final Set<String> seenIllegalAccess = Collections.newSetFromMap(new ConcurrentHashMap<>());
+    private final org.slf4j.Logger logger;
+
+    static {
+        ClassLoader.registerAsParallelCapable();
+    }
+
+    public PaperPluginClassLoader(@NotNull PaperPluginClassLoaderStorage loader, PluginProvider<?> pluginProvider, ClassLoader parentLoader) throws IOException {
+        super(pluginProvider.getSource().getFileName().toString(), new URL[]{pluginProvider.getSource().toUri().toURL()}, parentLoader);
+
+        this.loader = loader;
+
+        this.pluginProvider = pluginProvider;
+        // TODO: Are these needed? Want to avoid overhead by converting
+        this.pluginConfiguration = this.pluginProvider.getConfiguration();
+        this.jarManifest = this.pluginProvider.file().getManifest();
+        this.jarUrl = this.pluginProvider.getSource().toUri().toURL();
+
+        this.logger = pluginProvider.getLogger();
+    }
+
+    @Override
+    public URL getResource(String name) {
+        return this.findResource(name);
+    }
+
+    @Override
+    public Enumeration<URL> getResources(String name) throws IOException {
+        return this.findResources(name);
+    }
+
+    @Override
+    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
+        return this.loadClass(name, resolve, true);
+    }
+
+    // We do not use the library loader
+    public Class<?> loadClass(@NotNull String name, boolean resolve, boolean checkGlobal) throws ClassNotFoundException {
+        try {
+            Class<?> result = super.loadClass(name, resolve);
+
+            // SPIGOT-6749: Library classes will appear in the above, but we don't want to return them to other plugins
+            if (checkGlobal || result.getClassLoader() == this) {
+                return result;
+            }
+        } catch (ClassNotFoundException ex) {
+        }
+
+        if (checkGlobal) {
+            // This ignores the libraries of other plugins, unless they are transitive dependencies.
+            Class<?> result = this.loader.getClassByName(name, resolve, this.pluginConfiguration, this);  // Paper - prioritize self
+
+            if (result != null) {
+                // If the class was loaded from a library instead of a PluginClassLoader, we can assume that its associated plugin is a transitive dependency and can therefore skip this check.
+                if (result.getClassLoader() instanceof PaperPluginClassLoader existingClassLoader) {
+                    PluginConfiguration classLoaderConfig = existingClassLoader.pluginConfiguration;
+
+                    String identifier = classLoaderConfig.getIdentifier();
+                    if (classLoaderConfig != this.pluginConfiguration && !this.seenIllegalAccess.contains(identifier) && !this.pluginConfiguration.isTransitiveDependency(classLoaderConfig)) {
+                        this.seenIllegalAccess.add(identifier);
+                        if (this.pluginProvider != null) {
+                            this.logger.warn("Loaded class {} from {} which is not a depend or softdepend of this plugin.", name, classLoaderConfig.getDisplayName());
+                        }
+                    }
+                }
+
+                return result;
+            }
+        }
+
+        throw new ClassNotFoundException(name);
+    }
+
+    @Override
+    protected Class<?> findClass(String name) throws ClassNotFoundException {
+        if (name.startsWith("org.bukkit.") || name.startsWith("net.minecraft.")) {
+            throw new ClassNotFoundException(name);
+        }
+        Class<?> result = this.loadedClasses.get(name);
+
+        if (result == null) {
+            String path = name.replace('.', '/').concat(".class");
+            JarFile jar = this.pluginProvider.file();
+            JarEntry entry = jar.getJarEntry(path);
+
+            if (entry != null) {
+                byte[] classBytes;
+
+                try (InputStream is = jar.getInputStream(entry)) {
+                    classBytes = ByteStreams.toByteArray(is);
+                } catch (IOException ex) {
+                    throw new ClassNotFoundException(name, ex);
+                }
+
+                //classBytes = loader.server.getUnsafe().processClass(description, path, classBytes); TODO: Awful byte manipulation
+
+                int dot = name.lastIndexOf('.');
+                if (dot != -1) {
+                    String pkgName = name.substring(0, dot);
+                    // TODO: Do we want to use the deprecated package method here?
+                    //if (getPackage(pkgName) == null) {
+                    if (this.getDefinedPackage(pkgName) == null) {
+                        try {
+                            if (this.jarManifest != null) {
+                                this.definePackage(pkgName, this.jarManifest, this.jarUrl);
+                            } else {
+                                this.definePackage(pkgName, null, null, null, null, null, null, null);
+                            }
+                        } catch (IllegalArgumentException ex) {
+                            if (this.getDefinedPackage(pkgName) == null) {
+                                throw new IllegalStateException("Cannot find package " + pkgName);
+                            }
+                        }
+                    }
+                }
+
+                CodeSigner[] signers = entry.getCodeSigners();
+                CodeSource source = new CodeSource(this.jarUrl, signers);
+
+                result = this.defineClass(name, classBytes, 0, classBytes.length, source);
+            }
+
+            if (result == null) {
+                result = super.findClass(name);
+            }
+
+            this.setClass(result);
+            this.loadedClasses.put(name, result);
+        }
+
+        return result;
+    }
+
+    @Override
+    public void close() throws IOException {
+        for (Class<?> clazz : this.loadedClasses.values()) {
+            this.removeClass(clazz);
+        }
+
+        super.close();
+    }
+
+    @NotNull
+    Collection<Class<?>> getClasses() {
+        return this.loadedClasses.values();
+    }
+
+    @Override
+    public String toString() {
+        return "PaperPluginClassLoader{" +
+            "loader=" + this.loader +
+            ", loadedClasses=" + this.loadedClasses +
+            ", pluginProvider=" + this.pluginProvider +
+            ", pluginConfiguration=" + this.pluginConfiguration +
+            ", jarManifest=" + this.jarManifest +
+            ", jarUrl=" + this.jarUrl +
+            ", seenIllegalAccess=" + this.seenIllegalAccess +
+            '}';
+    }
+
+
+    // TODO: are we supporting this cringe?
+    private void setClass(@NotNull final Class<?> clazz) {
+        if (ConfigurationSerializable.class.isAssignableFrom(clazz)) {
+            Class<? extends ConfigurationSerializable> serializable = clazz.asSubclass(ConfigurationSerializable.class);
+            ConfigurationSerialization.registerClass(serializable);
+        }
+    }
+
+    private void removeClass(@NotNull Class<?> clazz) {
+        if (ConfigurationSerializable.class.isAssignableFrom(clazz)) {
+            Class<? extends ConfigurationSerializable> serializable = clazz.asSubclass(ConfigurationSerializable.class);
+            ConfigurationSerialization.unregisterClass(serializable);
+        }
+    }
+
+    public void handleLoadPlugin(JavaPlugin javaPlugin) {
+        PluginLoader pluginLoader = ((SimplePluginManager) Bukkit.getPluginManager()).loader;
+        //javaPlugin.logger = this.logger; // Paper - set logger
+        PluginConfiguration config = this.pluginConfiguration;
+        PluginDescriptionFile pluginDescriptionFile = new PluginDescriptionFile(
+            config.getIdentifier(),
+            config.getDisplayName(),
+            config.getProvides(),
+            config.getMain(),
+            "", // Classloader load order api
+            config.getHardDependencies(),
+            config.getSoftDependencies(),
+            config.getLoadBefore(),
+            config.getVersion(),
+            config.getRawCommands(),
+            config.getDescription(),
+            config.getAuthors(),
+            config.getContributors(),
+            config.getWebsite(),
+            config.getLoggingPrefix(),
+            config.getLoadOrder(),
+            config.getLazyPermissions(),
+            config.getDefaultPermission(),
+            Set.of(), // Aware api
+            config.getApiVersion(),
+            List.of() // Libraries
+        );
+
+        File dataFolder = new File(Bukkit.getPluginsFolder(), pluginDescriptionFile.getName());
+
+        javaPlugin.init(pluginLoader, Bukkit.getServer(), pluginDescriptionFile, dataFolder, this.pluginProvider.getSource().resolve(pluginDescriptionFile.getDisplayName()).toFile(), this, config);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoaderStorage.java b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoaderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..672d06cb5e3c4cfd584d0c868b24891aa36480ac
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoaderStorage.java
@@ -0,0 +1,107 @@
+package io.papermc.paper.plugin.provider.service.classloader;
+
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.SimplePluginManager;
+import org.bukkit.plugin.java.LibraryLoader;
+import org.bukkit.plugin.java.PluginClassLoader;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.logging.Logger;
+
+/**
+ * Holds classloaders that other plugin providers might be using.
+ */
+public final class PaperPluginClassLoaderStorage {
+
+    private static final Logger LOGGER = java.util.logging.Logger.getLogger("PaperClassLoader");
+
+    private final Map<String, ReentrantReadWriteLock> classLoadLock = new HashMap<>();
+    private final Map<String, Integer> classLoadLockCount = new HashMap<>();
+    public final List<PaperPluginClassLoader> classLoaders = new CopyOnWriteArrayList<>();
+    public final List<PluginClassLoader> spigotClassLoaders = new CopyOnWriteArrayList<>();
+    private final LibraryLoader libraryLoader;
+
+    public static final PaperPluginClassLoaderStorage INSTANCE = new PaperPluginClassLoaderStorage();
+
+    public PaperPluginClassLoaderStorage() {
+
+        LibraryLoader libraryLoader = null;
+        try {
+            libraryLoader = new LibraryLoader(LOGGER);
+        } catch (NoClassDefFoundError ex) {
+            // Provided depends were not added back
+            LOGGER.warning("Could not initialize LibraryLoader (missing dependencies?)");
+        }
+        this.libraryLoader = libraryLoader;
+    }
+
+    public Class<?> getClassByName(String name, boolean resolve, PluginConfiguration pluginConfiguration, @Nullable ClassLoader requester) {
+        // make MT safe
+        java.util.concurrent.locks.ReentrantReadWriteLock lock;
+        synchronized (this.classLoadLock) {
+            lock = this.classLoadLock.computeIfAbsent(name, (x) -> new java.util.concurrent.locks.ReentrantReadWriteLock());
+            this.classLoadLockCount.compute(name, (x, prev) -> prev != null ? prev + 1 : 1);
+        }
+        lock.writeLock().lock();
+
+        try {
+//            if (!DISABLE_CLASS_PRIORITIZATION && requester != null) {
+//                try {
+//                    return requester.loadClass0(name, false, false, ((SimplePluginManager) server.getPluginManager()).isTransitiveDepend(description, requester.getDescription()));
+//                } catch (ClassNotFoundException cnfe) {
+//                }
+//            }
+            // Paper end
+            for (PaperPluginClassLoader loader : this.classLoaders) {
+                try {
+                    return loader.loadClass(name, resolve, false);
+                } catch (ClassNotFoundException cnfe) {
+                }
+            }
+            SimplePluginManager manager = ((SimplePluginManager) Bukkit.getServer().getPluginManager());
+            for (PluginClassLoader loader : this.spigotClassLoaders) {
+                try {
+                    return loader.loadClass0(name, resolve, false, manager.isTransitiveDepend(pluginConfiguration, loader.getPlugin().getDescription()));
+                } catch (ClassNotFoundException cnfe) {
+                }
+            }
+        } finally {
+            synchronized (this.classLoadLock) {
+                lock.writeLock().unlock();
+                if (this.classLoadLockCount.get(name) == 1) {
+                    this.classLoadLock.remove(name);
+                    this.classLoadLockCount.remove(name);
+                } else {
+                    this.classLoadLockCount.compute(name, (x, prev) -> prev - 1);
+                }
+            }
+        }
+        return null;
+    }
+
+    public LibraryLoader getLibraryLoader() {
+        return this.libraryLoader;
+    }
+
+    public void add(PaperPluginClassLoader classLoader) {
+        this.classLoaders.add(classLoader);
+    }
+
+    public void add(PluginClassLoader classLoader) {
+        this.spigotClassLoaders.add(classLoader);
+    }
+
+    public void remove(PluginClassLoader loader) {
+        this.spigotClassLoaders.remove(loader);
+    }
+
+    public boolean contains(PluginClassLoader pluginLoader) {
+        return this.spigotClassLoaders.contains(pluginLoader);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/storage/ProviderStorage.java b/src/main/java/io/papermc/paper/plugin/provider/service/storage/ProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..2b2ea4e6d00039770380323242199f8d74392b01
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/storage/ProviderStorage.java
@@ -0,0 +1,13 @@
+package io.papermc.paper.plugin.provider.service.storage;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+import org.jetbrains.annotations.ApiStatus;
+
+public interface ProviderStorage<T> {
+
+    void register(PluginProvider<T> provider);
+
+    @ApiStatus.Internal
+    Iterable<PluginProvider<T>> getRegisteredProviders();
+
+}
diff --git a/src/main/java/io/papermc/paper/registry/RegistryAccess.java b/src/main/java/io/papermc/paper/registry/RegistryAccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..f26486d188fa8f120b5322ac568c422a881f584f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/registry/RegistryAccess.java
@@ -0,0 +1,8 @@
+package io.papermc.paper.registry;
+
+public class RegistryAccess {
+
+    public static RegistryAccess getInstance() {
+        return new RegistryAccess();
+    }
+}
diff --git a/src/main/java/org/bukkit/command/SimpleCommandMap.java b/src/main/java/org/bukkit/command/SimpleCommandMap.java
index b8623575b1c1b565560c2dd6438190716845a652..785952d60df7c0ab7b247ba81d1970b5a90e5340 100644
--- a/src/main/java/org/bukkit/command/SimpleCommandMap.java
+++ b/src/main/java/org/bukkit/command/SimpleCommandMap.java
@@ -33,7 +33,7 @@ public class SimpleCommandMap implements CommandMap {
     private void setDefaultCommands() {
         register("bukkit", new VersionCommand("version"));
         register("bukkit", new ReloadCommand("reload"));
-        register("bukkit", new PluginsCommand("plugins"));
+        //register("bukkit", new PluginsCommand("plugins")); Paper
         register("bukkit", new co.aikar.timings.TimingsCommand("timings")); // Paper
     }
 
diff --git a/src/main/java/org/bukkit/plugin/Plugin.java b/src/main/java/org/bukkit/plugin/Plugin.java
index 08aef59d8443038771704d9587e31f299e587307..3948cebb552ae1873421a8354c686a0b4afff3a7 100644
--- a/src/main/java/org/bukkit/plugin/Plugin.java
+++ b/src/main/java/org/bukkit/plugin/Plugin.java
@@ -34,6 +34,8 @@ public interface Plugin extends TabExecutor {
     @NotNull
     public PluginDescriptionFile getDescription();
 
+    io.papermc.paper.plugin.provider.configuration.PluginConfiguration getConfiguration();
+
     /**
      * Gets a {@link FileConfiguration} for this plugin, read through
      * "config.yml"
diff --git a/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java b/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
index 0c9f4d1e9104fa6951114c1f9ec954dfcc749196..f6193c406ee7ba6b7ed66d1aca20da35150bddad 100644
--- a/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
+++ b/src/main/java/org/bukkit/plugin/PluginDescriptionFile.java
@@ -194,7 +194,7 @@ import org.yaml.snakeyaml.nodes.Tag;
  *      inferno.burningdeaths: true
  *</pre></blockquote>
  */
-public final class PluginDescriptionFile {
+public class PluginDescriptionFile implements io.papermc.paper.plugin.provider.configuration.BukkitConfigurationWrapper { // Paper
     private static final Pattern VALID_NAME = Pattern.compile("^[A-Za-z0-9 _.-]+$");
     private static final ThreadLocal<Yaml> YAML = new ThreadLocal<Yaml>() {
         @Override
@@ -254,6 +254,31 @@ public final class PluginDescriptionFile {
     private Set<PluginAwareness> awareness = ImmutableSet.of();
     private String apiVersion = null;
     private List<String> libraries = ImmutableList.of();
+    // Paper start - oh my goddddd
+    public PluginDescriptionFile(String rawName, String name, List<String> provides, String main, String classLoaderOf, List<String> depend, List<String> softDepend, List<String> loadBefore, String version, Map<String, Map<String, Object>> commands, String description, List<String> authors, List<String> contributors, String website, String prefix, PluginLoadOrder order, Map<?, ?> lazyPermissions, PermissionDefault defaultPerm, Set<PluginAwareness> awareness, String apiVersion, List<String> libraries) {
+        this.rawName = rawName;
+        this.name = name;
+        this.provides = provides;
+        this.main = main;
+        this.classLoaderOf = classLoaderOf;
+        this.depend = depend;
+        this.softDepend = softDepend;
+        this.loadBefore = loadBefore;
+        this.version = version;
+        this.commands = commands;
+        this.description = description;
+        this.authors = authors;
+        this.contributors = contributors;
+        this.website = website;
+        this.prefix = prefix;
+        this.order = order;
+        this.lazyPermissions = lazyPermissions;
+        this.defaultPerm = defaultPerm;
+        this.awareness = awareness;
+        this.apiVersion = apiVersion;
+        this.libraries = libraries;
+    }
+    // Paper end
 
     public PluginDescriptionFile(@NotNull final InputStream stream) throws InvalidDescriptionException {
         loadMap(asMap(YAML.get().load(stream)));
@@ -1270,4 +1295,16 @@ public final class PluginDescriptionFile {
     public String getRawName() {
         return rawName;
     }
+    // Paper
+    @Override
+    public PluginDescriptionFile spigotDescription() {
+        return this;
+    }
+
+    @Override
+    public Map<?, ?> getLazyPermissions() {
+        return this.lazyPermissions;
+    }
+
+    // Paper end
 }
diff --git a/src/main/java/org/bukkit/plugin/SimplePluginManager.java b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
index ed07f5820281b139739f673fa4e25171de81b894..30a570424743b279931de1c0ba29cf94b47b2c01 100644
--- a/src/main/java/org/bukkit/plugin/SimplePluginManager.java
+++ b/src/main/java/org/bukkit/plugin/SimplePluginManager.java
@@ -55,6 +55,8 @@ public final class SimplePluginManager implements PluginManager {
     private final Map<String, Map<Permissible, Boolean>> permSubs = new HashMap<String, Map<Permissible, Boolean>>();
     private final Map<Boolean, Map<Permissible, Boolean>> defSubs = new HashMap<Boolean, Map<Permissible, Boolean>>();
     private boolean useTimings = false;
+    @org.jetbrains.annotations.ApiStatus.Internal
+    public org.bukkit.plugin.java.JavaPluginLoader loader;
 
     public SimplePluginManager(@NotNull Server instance, @NotNull SimpleCommandMap commandMap) {
         server = instance;
@@ -81,6 +83,7 @@ public final class SimplePluginManager implements PluginManager {
             try {
                 constructor = loader.getConstructor(Server.class);
                 instance = constructor.newInstance(server);
+                if (instance instanceof org.bukkit.plugin.java.JavaPluginLoader javaPluginLoader) this.loader = javaPluginLoader; // Paper
             } catch (NoSuchMethodException ex) {
                 String className = loader.getName();
 
@@ -410,7 +413,11 @@ public final class SimplePluginManager implements PluginManager {
                 result = loader.loadPlugin(file);
             }
         }
-
+    // Paper start
+        return loadPlugin(result);
+    }
+    public synchronized Plugin loadPlugin(@Nullable Plugin result) throws UnknownDependencyException {
+    // Paper end
         if (result != null) {
             plugins.add(result);
             lookupNames.put(result.getDescription().getName().toLowerCase(java.util.Locale.ENGLISH), result); // Paper
@@ -924,12 +931,19 @@ public final class SimplePluginManager implements PluginManager {
     }
 
     public boolean isTransitiveDepend(@NotNull PluginDescriptionFile plugin, @NotNull PluginDescriptionFile depend) {
+    // Paper start
+        return this.isTransitiveDepend(plugin, depend); // TODO: DO I need this? I don't wanna yuck the signature
+    }
+    public boolean isTransitiveDepend(@NotNull io.papermc.paper.plugin.provider.configuration.PluginConfiguration plugin, @NotNull io.papermc.paper.plugin.provider.configuration.PluginConfiguration depend) {
+    // Paper end
         Preconditions.checkArgument(plugin != null, "plugin");
         Preconditions.checkArgument(depend != null, "depend");
 
-        if (dependencyGraph.nodes().contains(plugin.getName())) {
-            Set<String> reachableNodes = Graphs.reachableNodes(dependencyGraph, plugin.getName());
-            if (reachableNodes.contains(depend.getName())) {
+        // Paper start
+        if (dependencyGraph.nodes().contains(plugin.getIdentifier())) {
+            Set<String> reachableNodes = Graphs.reachableNodes(dependencyGraph, plugin.getIdentifier());
+            if (reachableNodes.contains(depend.getIdentifier())) {
+        // Paper end
                 return true;
             }
             for (String provided : depend.getProvides()) {
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
index 3bea5dd67ad0393160ccede4ac99a3c7baa1803b..28d9c533260c77262628b6e52da73df001eed752 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPlugin.java
@@ -38,6 +38,7 @@ public abstract class JavaPlugin extends PluginBase {
     private Server server = null;
     private File file = null;
     private PluginDescriptionFile description = null;
+    private io.papermc.paper.plugin.provider.configuration.PluginConfiguration pluginConfiguration = null;
     private File dataFolder = null;
     private ClassLoader classLoader = null;
     private boolean naggable = true;
@@ -47,10 +48,16 @@ public abstract class JavaPlugin extends PluginBase {
 
     public JavaPlugin() {
         final ClassLoader classLoader = this.getClass().getClassLoader();
-        if (!(classLoader instanceof PluginClassLoader)) {
-            throw new IllegalStateException("JavaPlugin requires " + PluginClassLoader.class.getName());
+        // Paper start
+        // TODO Init paper plugins
+        if (classLoader instanceof PluginClassLoader pluginClassLoader) {
+            ((PluginClassLoader) classLoader).initialize(this);
+        } else if (classLoader instanceof io.papermc.paper.plugin.provider.service.classloader.PaperPluginClassLoader paperPluginClassLoader) {
+            paperPluginClassLoader.handleLoadPlugin(this);
+        } else {
+            throw new IllegalStateException("JavaPlugin requires to be created by a valid classloader.");
         }
-        ((PluginClassLoader) classLoader).initialize(this);
+        // Paper end
     }
 
     protected JavaPlugin(@NotNull final JavaPluginLoader loader, @NotNull final PluginDescriptionFile description, @NotNull final File dataFolder, @NotNull final File file) {
@@ -127,6 +134,11 @@ public abstract class JavaPlugin extends PluginBase {
         return description;
     }
 
+    @Nullable
+    public final io.papermc.paper.plugin.provider.configuration.PluginConfiguration getConfiguration() {
+        return this.pluginConfiguration;
+    }
+
     @NotNull
     @Override
     public FileConfiguration getConfig() {
@@ -268,8 +280,12 @@ public abstract class JavaPlugin extends PluginBase {
         }
     }
 
-
-    final void init(@NotNull PluginLoader loader, @NotNull Server server, @NotNull PluginDescriptionFile description, @NotNull File dataFolder, @NotNull File file, @NotNull ClassLoader classLoader) {
+    // Paper start
+    public final void init(@NotNull PluginLoader loader, @NotNull Server server, @NotNull PluginDescriptionFile description, @NotNull File dataFolder, @NotNull File file, @NotNull ClassLoader classLoader) {
+        init(loader, server, description, dataFolder, file, classLoader, description);
+    }
+    public final void init(@NotNull PluginLoader loader, @NotNull Server server, @NotNull PluginDescriptionFile description, @NotNull File dataFolder, @NotNull File file, @NotNull ClassLoader classLoader, @Nullable io.papermc.paper.plugin.provider.configuration.PluginConfiguration configuration) {
+    // Paper end
         this.loader = loader;
         this.server = server;
         this.file = file;
@@ -281,6 +297,7 @@ public abstract class JavaPlugin extends PluginBase {
         if (this.logger == null) {
             this.logger = com.destroystokyo.paper.utils.PaperPluginLogger.getLogger(this.description);
         }
+        this.pluginConfiguration = configuration;
         // Paper end
     }
 
diff --git a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
index 8ff78fad47f6086aa289e32590f4fbec24b3d500..6db99a156569da47d5ffba1bb50b6012f310fb19 100644
--- a/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/JavaPluginLoader.java
@@ -55,7 +55,7 @@ public final class JavaPluginLoader implements PluginLoader {
     private final Pattern[] fileFilters = new Pattern[]{Pattern.compile("\\.jar$")};
     private final Map<String, java.util.concurrent.locks.ReentrantReadWriteLock> classLoadLock = new java.util.HashMap<String, java.util.concurrent.locks.ReentrantReadWriteLock>(); // Paper
     private final Map<String, Integer> classLoadLockCount = new java.util.HashMap<String, Integer>(); // Paper
-    private final List<PluginClassLoader> loaders = new CopyOnWriteArrayList<PluginClassLoader>();
+    public final io.papermc.paper.plugin.provider.service.classloader.PaperPluginClassLoaderStorage loaders = io.papermc.paper.plugin.provider.service.classloader.PaperPluginClassLoaderStorage.INSTANCE; // Paper
     private final LibraryLoader libraryLoader;
 
     /**
@@ -93,6 +93,12 @@ public final class JavaPluginLoader implements PluginLoader {
         } catch (InvalidDescriptionException ex) {
             throw new InvalidPluginException(ex);
         }
+        // Paper start
+        return this.loadPlugin(description, file);
+    }
+    @NotNull
+    public Plugin loadPlugin(@NotNull final PluginDescriptionFile description, File file) throws InvalidPluginException {
+        // Paper end
 
         final File parentFile = this.server.getPluginsFolder(); // Paper
         final File dataFolder = new File(parentFile, description.getName());
@@ -214,6 +220,7 @@ public final class JavaPluginLoader implements PluginLoader {
         return getClassByName(name, resolve, description, null);
     }
     Class<?> getClassByName(final String name, boolean resolve, PluginDescriptionFile description, PluginClassLoader requester) {
+        if (true) return loaders.getClassByName(name, resolve, description, requester); // Paper
         // Paper end
         // Paper start - make MT safe
         java.util.concurrent.locks.ReentrantReadWriteLock lock;
@@ -230,12 +237,7 @@ public final class JavaPluginLoader implements PluginLoader {
             }
             // Paper end
         // Paper end
-        for (PluginClassLoader loader : loaders) {
-            try {
-                return loader.loadClass0(name, resolve, false, ((SimplePluginManager) server.getPluginManager()).isTransitiveDepend(description, loader.plugin.getDescription()));
-            } catch (ClassNotFoundException cnfe) {
-            }
-        }
+        // Paper - remove implementation
         // Paper start - make MT safe
         } finally {
             synchronized (classLoadLock) {
@@ -359,12 +361,14 @@ public final class JavaPluginLoader implements PluginLoader {
 
             JavaPlugin jPlugin = (JavaPlugin) plugin;
 
+            if (jPlugin.getClassLoader() instanceof PluginClassLoader) { // Paper
             PluginClassLoader pluginLoader = (PluginClassLoader) jPlugin.getClassLoader();
 
             if (!loaders.contains(pluginLoader)) {
                 loaders.add(pluginLoader);
                 server.getLogger().log(Level.WARNING, "Enabled plugin with unregistered PluginClassLoader " + plugin.getDescription().getFullName());
             }
+            } // Paper
 
             try {
                 jPlugin.setEnabled(true);
diff --git a/src/main/java/org/bukkit/plugin/java/LibraryLoader.java b/src/main/java/org/bukkit/plugin/java/LibraryLoader.java
index 6d634b0ea813ccb19f1562a7d0e5a59cea4eab21..4eec9316e4447701732c944fa84c64a009a5c394 100644
--- a/src/main/java/org/bukkit/plugin/java/LibraryLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/LibraryLoader.java
@@ -36,7 +36,7 @@ import org.eclipse.aether.transport.http.HttpTransporterFactory;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-class LibraryLoader
+public class LibraryLoader
 {
 
     private final Logger logger;
diff --git a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
index 345394132df70593800127d34a38f8f8a4dafe00..de2f360f4c5073406db9e80185fecc4bf5179126 100644
--- a/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
+++ b/src/main/java/org/bukkit/plugin/java/PluginClassLoader.java
@@ -103,7 +103,7 @@ public final class PluginClassLoader extends URLClassLoader { // Spigot
         return loadClass0(name, resolve, true, true);
     }
 
-    Class<?> loadClass0(@NotNull String name, boolean resolve, boolean checkGlobal, boolean checkLibraries) throws ClassNotFoundException {
+    public Class<?> loadClass0(@NotNull String name, boolean resolve, boolean checkGlobal, boolean checkLibraries) throws ClassNotFoundException { // Paper
         try {
             Class<?> result = super.loadClass(name, resolve);
 

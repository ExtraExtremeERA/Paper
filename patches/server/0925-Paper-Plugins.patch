From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Wed, 6 Jul 2022 23:00:31 -0400
Subject: [PATCH] Paper Plugins


diff --git a/src/main/java/io/papermc/paper/command/PaperCommands.java b/src/main/java/io/papermc/paper/command/PaperCommands.java
index 37d28625b9528bbe0cd6d9623e702bbbc2b07883..ab9a00b60eed9da7e61feda90a69563a7ae8d05c 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommands.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommands.java
@@ -23,5 +23,6 @@ public final class PaperCommands {
         COMMANDS.forEach((s, command) -> {
             server.server.getCommandMap().register(s, "Paper", command);
         });
+        server.server.getCommandMap().register("bukkit", new PaperPluginsCommand());
     }
 }
diff --git a/src/main/java/io/papermc/paper/command/PaperPluginsCommand.java b/src/main/java/io/papermc/paper/command/PaperPluginsCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..7a5ce1c898a550dd02f8cad3a8b3b874aa6b358c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/PaperPluginsCommand.java
@@ -0,0 +1,188 @@
+package io.papermc.paper.command;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.ProviderStatus;
+import io.papermc.paper.plugin.provider.ProviderStatusHolder;
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import io.papermc.paper.plugin.provider.service.storage.ServerPluginProviderStorage;
+import io.papermc.paper.plugin.provider.type.JavaPluginProvider;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginParentProvider;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginProvider;
+import io.papermc.paper.plugin.provider.type.spigot.SpigotPluginProvider;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.JoinConfiguration;
+import net.kyori.adventure.text.TextComponent;
+import net.kyori.adventure.text.event.ClickEvent;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextColor;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.defaults.BukkitCommand;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.TreeMap;
+
+public class PaperPluginsCommand extends BukkitCommand {
+
+    // TODO: LINK?
+    private static final Component SERVER_PLUGIN_INFO = Component.text("ℹ What is a server plugin?", TextColor.color(52, 159, 218))
+        .append(asPlainComponents("""
+            Server plugins can add new behavior to your server!
+            You can find new plugins on Paper's plugin repository, Hangar.
+                        
+            <link to hangar>
+            """));
+
+    private static final Component SERVER_INITIALIZER_INFO = Component.text("ℹ What is a server initializer?", TextColor.color(52, 159, 218))
+        .append(asPlainComponents("""
+            Server initializers are ran before your server
+            starts and are provided by paper plugins.
+            """));
+
+    private static final Component LEGACY_PLUGIN_INFO = Component.text("ℹ What is a legacy plugin?", TextColor.color(52, 159, 218))
+        .append(asPlainComponents("""
+            A legacy plugin is a plugin that was made on
+            very old unsupported versions of the game.
+                        
+            It is encouraged that you replace this plugin,
+            as they might not work in the future and may cause
+            performance issues.
+            """));
+
+    private static final Component LEGACY_PLUGIN_STAR = Component.text('*', TextColor.color(255, 212, 42))
+        .hoverEvent(LEGACY_PLUGIN_INFO);
+
+    private static final Component INFO_ICON_START = Component.text("ℹ ", TextColor.color(52, 159, 218));
+
+    private static final Component PAPER_HEADER = Component.text("Paper Plugins:", TextColor.color(2, 136, 209));
+    private static final Component BUKKIT_HEADER = Component.text("Bukkit Plugins:", TextColor.color(237, 129, 6));
+
+    private static final Component PLUGIN_TICK = Component.text(" - ", NamedTextColor.DARK_GRAY);
+
+    public PaperPluginsCommand() {
+        super("plugins");
+        this.description = "Gets a list of plugins running on the server";
+        this.usageMessage = "/plugins";
+        this.setPermission("bukkit.command.plugins");
+        this.setAliases(Arrays.asList("pl"));
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String currentAlias, @NotNull String[] args) {
+        if (!this.testPermission(sender)) return true;
+
+        // Plugins
+        {
+            TreeMap<String, PluginProvider<JavaPlugin>> paperPlugins = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
+            TreeMap<String, PluginProvider<JavaPlugin>> spigotPlugins = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
+
+            for (PluginProvider<JavaPlugin> provider : ServerPluginProviderStorage.INSTANCE.getRegisteredProviders()) {
+                PluginConfiguration configuration = provider.getConfiguration();
+
+                if (provider instanceof SpigotPluginProvider) {
+                    spigotPlugins.put(configuration.getDisplayName(), provider);
+                } else if (provider instanceof PaperPluginParentProvider.PaperServerPluginProvider) {
+                    paperPlugins.put(configuration.getDisplayName(), provider);
+                }
+            }
+
+            sender.sendMessage(INFO_ICON_START.hoverEvent(SERVER_PLUGIN_INFO).append(Component.text("Server Plugins (%s):".formatted(paperPlugins.size() + spigotPlugins.size()), NamedTextColor.WHITE)));
+            sender.sendMessage(PAPER_HEADER);
+            sender.sendMessage(formatProviders(paperPlugins));
+            sender.sendMessage(BUKKIT_HEADER);
+            sender.sendMessage(formatProviders(spigotPlugins));
+
+        }
+
+        // Providers
+        /*
+        {
+            TreeMap<String, PluginProvider<Initializer>> providers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
+            for (PluginProvider<Initializer> provider : PreInitProviderStorage.INSTANCE.getRegisteredProviders()) {
+                providers.put(provider.getConfiguration().getIdentifier(), provider);
+            }
+
+            sender.sendMessage(INFO_ICON_START.hoverEvent(SERVER_INITIALIZER_INFO).append(Component.text("Server Initializers (%s):".formatted(providers.size()), NamedTextColor.WHITE)));
+            sender.sendMessage(formatProviders(providers));
+
+        }
+         */
+        return true;
+    }
+
+    @NotNull
+    @Override
+    public List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) throws IllegalArgumentException {
+        return Collections.emptyList();
+    }
+
+    private static <T> Component formatProviders(TreeMap<String, PluginProvider<T>> plugins) {
+        List<Component> components = new ArrayList<>(plugins.size());
+        for (Map.Entry<String, PluginProvider<T>> entry : plugins.entrySet()) {
+            components.add(formatProvider(entry.getValue()));
+        }
+
+        return PLUGIN_TICK.append(Component.join(JoinConfiguration.commas(true), components).color(NamedTextColor.WHITE));
+    }
+
+    private static Component formatProvider(PluginProvider<?> provider) {
+        TextComponent.Builder builder = Component.text();
+        if (provider instanceof SpigotPluginProvider spigotPluginProvider && spigotPluginProvider.isLegacy()) {
+            builder.append(LEGACY_PLUGIN_STAR);
+        }
+
+        String name = provider.getConfiguration().getIdentifier();
+        Component pluginName = Component.text(name, fromStatus(provider))
+            .clickEvent(ClickEvent.runCommand("/version " + name));
+
+        builder.append(pluginName);
+
+        return builder.build();
+    }
+
+    private static Component asPlainComponents(String strings) {
+        net.kyori.adventure.text.TextComponent.Builder builder = Component.text();
+        for (String string : strings.split("\n")) {
+            builder.append(Component.newline());
+            builder.append(Component.text(string, NamedTextColor.WHITE));
+        }
+
+        return builder.build();
+    }
+
+    private static TextColor fromStatus(PluginProvider<?> provider) {
+        if (provider instanceof ProviderStatusHolder statusHolder && statusHolder.getLastProvidedStatus() != null) {
+            ProviderStatus status = statusHolder.getLastProvidedStatus();
+
+            // Handle enabled/disabled game plugins
+            if (status == ProviderStatus.INITIALIZED && provider instanceof JavaPluginProvider javaPluginProvider) {
+                Plugin plugin = Bukkit.getPluginManager().getPlugin(javaPluginProvider.getConfiguration().getIdentifier());
+                // Plugin doesn't exist? Could be due to it being removed.
+                if (plugin == null) {
+                    return NamedTextColor.RED;
+                }
+
+                return plugin.isEnabled() ? NamedTextColor.GREEN : NamedTextColor.RED;
+            }
+
+            return switch (status) {
+                case INITIALIZED -> NamedTextColor.GREEN;
+                case ERRORED -> NamedTextColor.RED;
+            };
+        } else if (provider instanceof PaperPluginParentProvider.PaperServerPluginProvider serverPluginProvider && serverPluginProvider.shouldSkipCreation()) {
+            // Paper plugins will be skipped if their provider is skipped due to their initializer failing.
+            // Show them as red
+            return NamedTextColor.RED;
+        } else {
+            return NamedTextColor.GRAY;
+        }
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/PluginProviders.java b/src/main/java/io/papermc/paper/plugin/provider/PluginProviders.java
new file mode 100644
index 0000000000000000000000000000000000000000..277e8b3802d5cb07893be91a27f31b8a349fc691
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/PluginProviders.java
@@ -0,0 +1,67 @@
+package io.papermc.paper.plugin.provider;
+
+import io.papermc.paper.plugin.provider.type.PluginFileType;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import java.io.IOException;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.jar.JarFile;
+
+/*
+Responsible for storing all the plugin files.
+ */
+public class PluginProviders {
+
+    public static final PluginProviders INSTANCE = new PluginProviders();
+    private static final Logger LOGGER = LoggerFactory.getLogger(PluginProviders.class);
+
+    public void handlePluginDirectory(Path toPath) throws IOException {
+        if (!Files.isDirectory(toPath)) { // Create if missing
+            Files.createDirectories(toPath);
+        }
+
+        this.addDirectory(toPath);
+    }
+
+    public void addDirectory(Path directory) {
+        try {
+            Files.walk(directory, 1).filter(Files::isRegularFile).forEach(this::addFile);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    // TODO: This will log invalid plugins in the directory, i'm guessing this wasn't the behavior before.
+    // TODO: Update this to properly do better warnings, whatever
+    public void addFile(Path source) {
+        if (Files.notExists(source)) {
+            LOGGER.warn("File '{}' specified through 'add-plugin' argument does not exist, cannot load a plugin from it!", source);
+            return;
+        }
+
+        if (!Files.isRegularFile(source)) {
+            LOGGER.warn("File '{}' specified through 'add-plugin' argument is not a file, cannot load a plugin from it!", source);
+            return;
+        }
+
+        if (!source.getFileName().toString().endsWith(".jar")) {
+            LOGGER.warn("File '{}' specified through 'add-plugin' argument is not a jar file, cannot load a plugin from it!", source);
+            return;
+        }
+
+        try {
+            JarFile file = new JarFile(source.toFile());
+            PluginFileType type = PluginFileType.guessType(file);
+            if (type == null) {
+                LOGGER.warn("File '{}' specified through 'add-plugin' argument is not a valid plugin file, cannot load a plugin from it!", source);
+                return;
+            }
+
+            type.register(file, source);
+        } catch (Exception exception) {
+            LOGGER.error("Could not load '%s' in folder '%s'.".formatted(source.getFileName(), source.getParent()), exception);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/ProviderStatus.java b/src/main/java/io/papermc/paper/plugin/provider/ProviderStatus.java
new file mode 100644
index 0000000000000000000000000000000000000000..3f29ba87ce732024f08c56347c98fc26bee99837
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/ProviderStatus.java
@@ -0,0 +1,10 @@
+package io.papermc.paper.plugin.provider;
+
+import org.jetbrains.annotations.ApiStatus;
+
+@ApiStatus.Internal
+public enum ProviderStatus {
+    INITIALIZED,
+    ERRORED,
+    ;
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/ProviderStatusHolder.java b/src/main/java/io/papermc/paper/plugin/provider/ProviderStatusHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..94023e8b7f5011d4962e7859dd8771ab02f6dc11
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/ProviderStatusHolder.java
@@ -0,0 +1,8 @@
+package io.papermc.paper.plugin.provider;
+
+public interface ProviderStatusHolder {
+
+    ProviderStatus getLastProvidedStatus();
+
+    void setStatus(ProviderStatus status);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/PaperPluginConfiguration.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/PaperPluginConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..dbd8c29ce95bdb36af4b897f5b476b83a72626a6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/PaperPluginConfiguration.java
@@ -0,0 +1,198 @@
+package io.papermc.paper.plugin.provider.configuration;
+
+import com.google.common.collect.ImmutableList;
+import io.papermc.paper.configuration.constraint.Constraint;
+import io.papermc.paper.configuration.serializer.EnumValueSerializer;
+import io.papermc.paper.configuration.serializer.collections.MapSerializer;
+import io.papermc.paper.plugin.provider.configuration.serializer.constraints.PluginConfigConstraints;
+import io.papermc.paper.plugin.provider.configuration.type.PaperCommandMap;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginLoadOrder;
+import org.spongepowered.configurate.CommentedConfigurationNode;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.loader.HeaderMode;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.ObjectMapper;
+import org.spongepowered.configurate.objectmapping.meta.Required;
+import org.spongepowered.configurate.yaml.NodeStyle;
+import org.spongepowered.configurate.yaml.YamlConfigurationLoader;
+
+import java.io.BufferedReader;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+@ConfigSerializable
+public class PaperPluginConfiguration implements PluginConfiguration {
+
+    @PluginConfigConstraints.PluginName
+    @Required
+    private String name = null;
+    private List<String> provides = List.of();
+    @Required
+    @PluginConfigConstraints.PluginNameSpace
+    private String main = null;
+    @PluginConfigConstraints.PluginNameSpace
+    private String boostrapper = null;
+    @PluginConfigConstraints.PluginNameSpace
+    private String loader = null;
+    private String classLoaderOf = null;
+    private List<String> depend = List.of();
+    private List<String> softDepend = List.of();
+    private List<String> loadBefore = List.of();
+    @Required
+    private String version = null;
+    private PaperCommandMap commandMap = new PaperCommandMap();
+    private String description = null;
+    private List<String> authors = List.of();
+    private List<String> contributors = List.of();
+    private String website = null;
+    private String prefix = null;
+    private PluginLoadOrder load = PluginLoadOrder.POSTWORLD;
+    //private List<Permission> permissions = null;
+    //private Map<?, ?> lazyPermissions = null;
+    private PermissionDefault defaultPerm = PermissionDefault.OP;
+    //private Set<PluginAwareness> awareness = ImmutableSet.of();
+    private String apiVersion = null;
+
+    private List<String> libraries = ImmutableList.of();
+
+    public static PaperPluginConfiguration create(BufferedReader reader) throws ConfigurateException {
+        YamlConfigurationLoader loader = YamlConfigurationLoader.builder()
+            .indent(2)
+            .nodeStyle(NodeStyle.BLOCK)
+            .headerMode(HeaderMode.NONE)
+            .source(() -> reader)
+            .defaultOptions((options) -> {
+                return options.serializers((serializers) -> {
+                    serializers
+                        .register(new EnumValueSerializer())
+                        .register(PaperCommandMap.SERIALIZER)
+                        .register(MapSerializer.TYPE, new MapSerializer(false))
+                        .registerAnnotatedObjects(
+                            ObjectMapper.factoryBuilder()
+                                .addConstraint(Constraint.class, new Constraint.Factory())
+                                .addConstraint(PluginConfigConstraints.PluginName.class, String.class, new PluginConfigConstraints.PluginName.Factory()).build()
+                        );
+                });
+            })
+            .build();
+        CommentedConfigurationNode node = loader.load();
+        PaperPluginConfiguration pluginConfiguration = node.require(PaperPluginConfiguration.class);
+
+        // TODO: a better way to do this?
+        if (node.getString("author") != null) {
+            if (pluginConfiguration.authors.isEmpty()) {
+                pluginConfiguration.authors = new ArrayList<>();
+            }
+
+            pluginConfiguration.authors.add(node.getString("author"));
+        }
+
+        return pluginConfiguration;
+    }
+
+
+    @Override
+    public String getIdentifier() {
+        return this.name;
+    }
+
+    @Override
+    public String getMain() {
+        return this.main;
+    }
+
+    @Override
+    public String getVersion() {
+        return this.version;
+    }
+
+    @Override
+    public String getDisplayName() {
+        return this.name.replaceAll("_", " ");
+    }
+
+    @Override
+    public String getLoggingPrefix() {
+        return this.prefix;
+    }
+
+    @Override
+    public List<String> getHardDependencies() {
+        return this.depend;
+    }
+
+    @Override
+    public List<String> getSoftDependencies() {
+        return this.softDepend;
+    }
+
+    @Override
+    public List<String> getLoadBefore() {
+        return this.loadBefore;
+    }
+
+    @Override
+    public PluginLoadOrder getLoadOrder() {
+        return this.load;
+    }
+
+    @Override
+    public boolean isTransitiveDependency(PluginConfiguration other) {
+        return true;
+    }
+
+    @Override
+    public Map<String, Map<String, Object>> getRawCommands() {
+        return this.commandMap.getMap();
+    }
+
+    @Override
+    public String getDescription() {
+        return this.description;
+    }
+
+    @Override
+    public List<String> getAuthors() {
+        return this.authors;
+    }
+
+    @Override
+    public List<String> getContributors() {
+        return this.contributors;
+    }
+
+    @Override
+    public String getWebsite() {
+        return this.website;
+    }
+
+    @Override
+    public Map<?, ?> getLazyPermissions() {
+        return Map.of();
+    }
+
+    @Override
+    public PermissionDefault getDefaultPermission() {
+        return this.defaultPerm;
+    }
+
+    @Override
+    public String getApiVersion() {
+        return this.apiVersion;
+    }
+
+    @Override
+    public List<String> getProvides() {
+        return this.provides;
+    }
+
+    public String getBoostrapper() {
+        return this.boostrapper;
+    }
+
+    public String getLoader() {
+        return this.loader;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
new file mode 100644
index 0000000000000000000000000000000000000000..faf027ea0dba4b98e43d6f86d9b81056cf85cf5b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
@@ -0,0 +1,53 @@
+package io.papermc.paper.plugin.provider.configuration.serializer.constraints;
+
+import org.spongepowered.configurate.objectmapping.meta.Constraint;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import java.util.regex.Pattern;
+
+public final class PluginConfigConstraints {
+
+    @Documented
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target(ElementType.FIELD)
+    public @interface PluginName {
+
+        final class Factory implements Constraint.Factory<PluginName, String> {
+
+            private static final Pattern VALID_NAME = Pattern.compile("^[A-Za-z0-9 _.-]+$");
+
+            @Override
+            public Constraint<String> make(PluginName data, Type type) {
+                return value -> {
+                    if (value != null && !VALID_NAME.matcher(value).matches()) {
+                        throw new SerializationException("name '" + value + "' contains invalid characters.");
+                    }
+                };
+            }
+        }
+    }
+
+    @Documented
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target(ElementType.FIELD)
+    public @interface PluginNameSpace {
+
+        final class Factory implements Constraint.Factory<PluginName, String> {
+
+            @Override
+            public Constraint<String> make(PluginName data, Type type) {
+                return value -> {
+                    if (value != null && value.startsWith("org.bukkit.")) {
+                        throw new SerializationException("main may not be within the org.bukkit namespace");
+                    }
+                };
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PaperCommandMap.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PaperCommandMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..314cfd14b0632e4b4f7f2ec1dbd977b0d1e331ff
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PaperCommandMap.java
@@ -0,0 +1,70 @@
+package io.papermc.paper.plugin.provider.configuration.type;
+
+import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableMap;
+import org.spongepowered.configurate.serialize.ScalarSerializer;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.reflect.Type;
+import java.util.Map;
+import java.util.function.Predicate;
+
+public class PaperCommandMap {
+
+    public static final Serializer SERIALIZER = new Serializer();
+
+    private final Map<String, Map<String, Object>> map;
+
+    public PaperCommandMap() {
+        this.map = Map.of();
+    }
+
+    public PaperCommandMap(Map<?, ?> data) throws SerializationException {
+        ImmutableMap.Builder<String, Map<String, Object>> commandsBuilder = ImmutableMap.builder();
+        try {
+            for (Map.Entry<?, ?> command : data.entrySet()) {
+                ImmutableMap.Builder<String, Object> commandBuilder = ImmutableMap.builder();
+                if (command.getValue() != null) {
+                    for (Map.Entry<?, ?> commandEntry : ((Map<?, ?>) command.getValue()).entrySet()) {
+                        if (commandEntry.getValue() instanceof Iterable) {
+                            // This prevents internal alias list changes
+                            ImmutableList.Builder<Object> commandSubList = ImmutableList.builder();
+                            for (Object commandSubListItem : (Iterable<?>) commandEntry.getValue()) {
+                                if (commandSubListItem != null) {
+                                    commandSubList.add(commandSubListItem);
+                                }
+                            }
+                            commandBuilder.put(commandEntry.getKey().toString(), commandSubList.build());
+                        } else if (commandEntry.getValue() != null) {
+                            commandBuilder.put(commandEntry.getKey().toString(), commandEntry.getValue());
+                        }
+                    }
+                }
+                commandsBuilder.put(command.getKey().toString(), commandBuilder.build());
+            }
+        } catch (ClassCastException ex) {
+            throw new SerializationException("commands are of wrong type");
+        }
+        this.map = commandsBuilder.build();
+    }
+
+    public Map<String, Map<String, Object>> getMap() {
+        return this.map;
+    }
+
+    private static final class Serializer extends ScalarSerializer<PaperCommandMap> {
+        private Serializer() {
+            super(PaperCommandMap.class);
+        }
+
+        @Override
+        public PaperCommandMap deserialize(Type type, Object obj) throws SerializationException {
+            return new PaperCommandMap((Map<?, ?>) obj);
+        }
+
+        @Override
+        protected Object serialize(PaperCommandMap item, Predicate<Class<?>> typeSupported) {
+            return item.getMap();
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/loader/PaperClasspathBuilder.java b/src/main/java/io/papermc/paper/plugin/provider/loader/PaperClasspathBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..af58d53c3249ef77b2e7cf92ff5d5bc1f6296169
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/loader/PaperClasspathBuilder.java
@@ -0,0 +1,51 @@
+package io.papermc.paper.plugin.provider.loader;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.loader.library.ClassPathLibrary;
+import io.papermc.paper.plugin.provider.loader.library.PaperLibraryStore;
+import io.papermc.paper.plugin.provider.service.classloader.PaperPluginClassLoader;
+import io.papermc.paper.plugin.provider.service.classloader.PaperPluginClassLoaderStorage;
+import org.bukkit.plugin.java.JavaPlugin;
+
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+
+public class PaperClasspathBuilder implements PluginClasspathBuilder {
+
+    private final List<ClassPathLibrary> libraries = new ArrayList<>();
+
+    @Override
+    public PluginClasspathBuilder addLibrary(ClassPathLibrary classPathLibrary) {
+        this.libraries.add(classPathLibrary);
+        return this;
+    }
+
+    public ClassLoader buildClassLoader(PluginProvider<?> provider) {
+        PaperLibraryStore paperLibraryStore = new PaperLibraryStore();
+        for (ClassPathLibrary library : this.libraries) {
+            library.addToLibraryStore(paperLibraryStore);
+        }
+
+        List<Path> paths = paperLibraryStore.getPaths();
+        URL[] urls = new URL[paths.size()];
+        for (int i = 0; i < paths.size(); i++) {
+            Path path = paperLibraryStore.getPaths().get(i);
+            try {
+                urls[i] = path.toUri().toURL();
+            } catch (MalformedURLException e) {
+                throw new AssertionError(e);
+            }
+        }
+
+        try {
+            return new PaperPluginClassLoader(PaperPluginClassLoaderStorage.INSTANCE, provider, this.getClass().getClassLoader(), new URLClassLoader(urls));
+        } catch (IOException exception) {
+            throw new RuntimeException(exception);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/loader/library/PaperLibraryStore.java b/src/main/java/io/papermc/paper/plugin/provider/loader/library/PaperLibraryStore.java
new file mode 100644
index 0000000000000000000000000000000000000000..a519e629d22a5a27d739aea8810a8eac926d09ce
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/loader/library/PaperLibraryStore.java
@@ -0,0 +1,19 @@
+package io.papermc.paper.plugin.provider.loader.library;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+
+public class PaperLibraryStore implements LibraryStore {
+
+    private final List<Path> paths = new ArrayList<>();
+
+    @Override
+    public void addLibrary(Path library) {
+        this.paths.add(library);
+    }
+
+    public List<Path> getPaths() {
+        return this.paths;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/storage/PreInitProviderStorage.java b/src/main/java/io/papermc/paper/plugin/provider/service/storage/PreInitProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..fa94167138f1f7975ed85ca82d1c0c70ce414dc1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/storage/PreInitProviderStorage.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.plugin.provider.service.storage;
+
+import io.papermc.paper.plugin.PluginBootstrap;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.ProviderStatus;
+import io.papermc.paper.plugin.provider.ProviderStatusHolder;
+
+public class PreInitProviderStorage extends SimpleProviderStorage<PluginBootstrap> {
+
+    public static final PreInitProviderStorage INSTANCE = new PreInitProviderStorage();
+
+
+    public void init() {
+        for (PluginProvider<PluginBootstrap> provider : this.providers) {
+            try {
+                provider.createInstance().boostrap();
+            } catch (Exception e) {
+                provider.getLogger().error("Failed to run initializer for %s in %s".formatted(provider.getSource().getFileName(), provider.getSource().getParent()), e);
+                if (provider instanceof ProviderStatusHolder statusHolder) {
+                    statusHolder.setStatus(ProviderStatus.ERRORED);
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/storage/ServerPluginProviderStorage.java b/src/main/java/io/papermc/paper/plugin/provider/service/storage/ServerPluginProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..3a9ebd0682f8dfb3b0fb22b0e2feac78b3b2364c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/storage/ServerPluginProviderStorage.java
@@ -0,0 +1,33 @@
+package io.papermc.paper.plugin.provider.service.storage;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginParentProvider;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginProvider;
+import org.bukkit.plugin.java.JavaPlugin;
+
+import java.nio.file.Path;
+
+public class ServerPluginProviderStorage extends SimpleProviderStorage<JavaPlugin> {
+
+    public static final ServerPluginProviderStorage INSTANCE = new ServerPluginProviderStorage();
+
+    public void loadAll() {
+        for (PluginProvider<JavaPlugin> provider : this.providers) {
+            Path path = provider.getSource();
+            try {
+                if (provider instanceof PaperPluginParentProvider.PaperServerPluginProvider pluginProvider && pluginProvider.shouldSkipCreation()) {
+                    continue;
+                }
+
+                JavaPlugin plugin = provider.createInstance();
+
+                plugin.getLogger().info(String.format("Loading server plugin %s", plugin.getDescription().getFullName()));
+                plugin.onLoad();
+
+            } catch (Throwable ex) {
+                provider.getLogger().error("Could not load server plugin '%s' in folder '%s' (Is it up to date?)".formatted(path.getFileName(), path.getParent()), ex);
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/storage/SimpleProviderStorage.java b/src/main/java/io/papermc/paper/plugin/provider/service/storage/SimpleProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..77e048d9292fe3b1b207504bac6fb9420cbef4a6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/storage/SimpleProviderStorage.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.plugin.provider.service.storage;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public abstract class SimpleProviderStorage<T> implements ProviderStorage<T> {
+
+    protected final List<PluginProvider<T>> providers = new ArrayList<>();
+
+    @Override
+    public void register(PluginProvider<T> provider) {
+        this.providers.add(provider);
+    }
+
+    public List<PluginProvider<T>> registered() {
+        return this.providers;
+    }
+
+    @Override
+    public Iterable<PluginProvider<T>> getRegisteredProviders() {
+        return this.providers;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/JavaPluginProvider.java b/src/main/java/io/papermc/paper/plugin/provider/type/JavaPluginProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..c7b16e25a140e51ef4dfbba3d036acf68dfb88b5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/JavaPluginProvider.java
@@ -0,0 +1,7 @@
+package io.papermc.paper.plugin.provider.type;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+import org.bukkit.plugin.java.JavaPlugin;
+
+public abstract class JavaPluginProvider implements PluginProvider<JavaPlugin> {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/PluginFileType.java b/src/main/java/io/papermc/paper/plugin/provider/type/PluginFileType.java
new file mode 100644
index 0000000000000000000000000000000000000000..302a884d0b4b02c4bb6079be363202fe9a2d8c83
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/PluginFileType.java
@@ -0,0 +1,65 @@
+package io.papermc.paper.plugin.provider.type;
+
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import io.papermc.paper.plugin.provider.service.storage.PreInitProviderStorage;
+import io.papermc.paper.plugin.provider.service.storage.ServerPluginProviderStorage;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginParentProvider;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginProvider;
+import io.papermc.paper.plugin.provider.type.spigot.SpigotPluginProvider;
+import org.jetbrains.annotations.Nullable;
+
+import java.nio.file.Path;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+
+public enum PluginFileType {
+
+    PAPER("paper-plugin.yml") {
+        @Override
+        protected void register(JarFile file, JarEntry config, Path source) throws Exception {
+            PaperPluginProvider pluginProvider = PaperPluginProvider.of(file, config, source);
+
+            PaperPluginParentProvider parent = pluginProvider.createInstance();
+            if (parent.shouldCreateBootstrap()) {
+                PaperPluginParentProvider.PaperBootstrapProvider bootstrapPluginProvider = parent.createBootstrapProvider();
+
+                PreInitProviderStorage.INSTANCE.register(bootstrapPluginProvider);
+                ServerPluginProviderStorage.INSTANCE.register(parent.createPluginProvider(bootstrapPluginProvider));
+            } else {
+                ServerPluginProviderStorage.INSTANCE.register(parent.createPluginProvider());
+            }
+        }
+    },
+    SPIGOT("plugin.yml") {
+        @Override
+        protected void register(JarFile file, JarEntry config, Path source) throws Exception {
+            ServerPluginProviderStorage.INSTANCE.register(SpigotPluginProvider.of(file, config, source));
+        }
+    };
+
+    private static final PluginFileType[] VALUES = values();
+    private final String config;
+
+    <T, C extends PluginConfiguration> PluginFileType(String config) {
+        this.config = config;
+    }
+
+    @Nullable
+    public static PluginFileType guessType(JarFile file) {
+        for (PluginFileType type : VALUES) {
+            JarEntry entry = file.getJarEntry(type.config);
+            if (entry != null) {
+                return type;
+            }
+        }
+
+        return null;
+    }
+
+    public final void register(JarFile file, Path pluginPath) throws Exception {
+        this.register(file, file.getJarEntry(this.config), pluginPath);
+    }
+
+    protected abstract void register(JarFile file, JarEntry config, Path source) throws Exception;
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPlugin.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPlugin.java
new file mode 100644
index 0000000000000000000000000000000000000000..da931ff6057d3429e3e56c3df3d7abeb4a4e9d86
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPlugin.java
@@ -0,0 +1,4 @@
+package io.papermc.paper.plugin.provider.type.paper;
+
+public interface PaperPlugin {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginParentProvider.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginParentProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..87acf0ac7662bb60186d0ad781ffd7b2f4bee6e0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginParentProvider.java
@@ -0,0 +1,191 @@
+package io.papermc.paper.plugin.provider.type.paper;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+import io.papermc.paper.plugin.PluginBootstrap;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.ProviderStatus;
+import io.papermc.paper.plugin.provider.ProviderStatusHolder;
+import io.papermc.paper.plugin.provider.configuration.PaperPluginConfiguration;
+import io.papermc.paper.plugin.provider.type.JavaPluginProvider;
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.InvalidPluginException;
+import org.bukkit.plugin.SimplePluginManager;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+import org.slf4j.Logger;
+
+import java.nio.file.Path;
+import java.util.jar.JarFile;
+
+public class PaperPluginParentProvider {
+
+    private ProviderStatus status;
+
+    private final Path path;
+    private final JarFile jarFile;
+
+    private final PaperPluginConfiguration description;
+    private final ClassLoader classLoader;
+
+    private final Logger logger;
+
+    public PaperPluginParentProvider(Path path, JarFile jarFile, PaperPluginConfiguration description, ClassLoader classLoader, Logger logger) {
+        this.path = path;
+        this.jarFile = jarFile;
+        this.description = description;
+        this.classLoader = classLoader;
+        this.logger = logger;
+    }
+
+    public boolean shouldCreateBootstrap() {
+        return this.description.getBoostrapper() != null;
+    }
+
+    public PaperBootstrapProvider createBootstrapProvider() {
+        return new PaperBootstrapProvider();
+    }
+
+    public class PaperBootstrapProvider implements PluginProvider<PluginBootstrap>, ProviderStatusHolder {
+
+        private ProviderStatus status;
+
+        @Override
+        public @NotNull Path getSource() {
+            return PaperPluginParentProvider.this.path;
+        }
+
+        @Override
+        public JarFile file() {
+            return PaperPluginParentProvider.this.jarFile;
+        }
+
+        @Override
+        public PluginBootstrap createInstance() {
+            PluginBootstrap bootstrap = ProviderUtil.loadClass(PaperPluginParentProvider.this.description.getBoostrapper(),
+                PluginBootstrap.class, PaperPluginParentProvider.this.classLoader, PluginBootstrap::boostrap, () -> this.status = ProviderStatus.ERRORED);
+            this.status = ProviderStatus.INITIALIZED;
+            return bootstrap;
+        }
+
+        @Override
+        public PaperPluginConfiguration getConfiguration() {
+            return PaperPluginParentProvider.this.description;
+        }
+
+        @Override
+        public Logger getLogger() {
+            return PaperPluginParentProvider.this.logger;
+        }
+
+        @Override
+        public ProviderStatus getLastProvidedStatus() {
+            return this.status;
+        }
+
+        @Override
+        public void setStatus(ProviderStatus status) {
+            this.status = status;
+        }
+
+    }
+
+    public PaperServerPluginProvider createPluginProvider() {
+        return new PaperServerPluginProvider(null);
+    }
+
+    public PaperServerPluginProvider createPluginProvider(PaperBootstrapProvider provider) {
+        return new PaperServerPluginProvider(provider);
+    }
+
+    public class PaperServerPluginProvider extends JavaPluginProvider implements ProviderStatusHolder {
+
+        private final PaperBootstrapProvider bootstrapProvider;
+
+        private ProviderStatus status;
+
+        PaperServerPluginProvider(PaperBootstrapProvider bootstrapProvider) {
+            this.bootstrapProvider = bootstrapProvider;
+        }
+
+        @Override
+        public @NotNull Path getSource() {
+            return PaperPluginParentProvider.this.path;
+        }
+
+        @Override
+        public JarFile file() {
+            return PaperPluginParentProvider.this.jarFile;
+        }
+
+        @Override
+        public JavaPlugin createInstance() {
+            try {
+                JavaPlugin plugin;
+                SimplePluginManager simplePluginManager = (SimplePluginManager) Bukkit.getPluginManager();
+
+                try {
+                    Class<?> jarClass;
+                    try {
+                        jarClass = Class.forName(PaperPluginParentProvider.this.description.getMain(), true, PaperPluginParentProvider.this.classLoader);
+                    } catch (ClassNotFoundException ex) {
+                        throw new InvalidPluginException("Cannot find main class '" + PaperPluginParentProvider.this.description.getMain() + "'");
+                    }
+
+                    Class<? extends JavaPlugin> pluginClass;
+                    try {
+                        pluginClass = jarClass.asSubclass(JavaPlugin.class);
+                    } catch (ClassCastException ex) {
+                        throw new InvalidPluginException("main class `" + PaperPluginParentProvider.this.description.getMain() + "' does not extend JavaPlugin");
+                    }
+
+                    plugin = pluginClass.getDeclaredConstructor().newInstance();
+                } catch (IllegalAccessException ex) {
+                    throw new InvalidPluginException("No public constructor", ex);
+                } catch (InstantiationException ex) {
+                    throw new InvalidPluginException("Abnormal plugin type", ex);
+                } catch (Throwable ex) {
+                    throw new InvalidPluginException(ex);
+                }
+
+                simplePluginManager.loadPlugin(plugin);
+                this.status = ProviderStatus.INITIALIZED;
+                return plugin;
+            } catch (InvalidPluginException ex) {
+                this.status = ProviderStatus.ERRORED;
+                SneakyThrow.sneaky(ex);
+            }
+
+            throw new AssertionError(); // Shouldn't reach this point
+        }
+
+        @Override
+        public PaperPluginConfiguration getConfiguration() {
+            return PaperPluginParentProvider.this.description;
+        }
+
+        @Override
+        public Logger getLogger() {
+            return PaperPluginParentProvider.this.logger;
+        }
+
+        @Override
+        public ProviderStatus getLastProvidedStatus() {
+            return this.status;
+        }
+
+        @Override
+        public void setStatus(ProviderStatus status) {
+            this.status = status;
+        }
+
+        public boolean shouldSkipCreation() {
+            if (this.bootstrapProvider == null) {
+                return false;
+            }
+
+            return this.bootstrapProvider.getLastProvidedStatus() == ProviderStatus.ERRORED;
+        }
+
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProvider.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..b13427169cc0e66faeed00eee8b8b5f0ae8e83d0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProvider.java
@@ -0,0 +1,91 @@
+package io.papermc.paper.plugin.provider.type.paper;
+
+import io.papermc.paper.plugin.PluginLoader;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.configuration.PaperPluginConfiguration;
+import io.papermc.paper.plugin.provider.loader.PaperClasspathBuilder;
+import io.papermc.paper.plugin.provider.service.classloader.PaperSimplePluginClassLoader;
+import org.bukkit.plugin.InvalidDescriptionException;
+import org.jetbrains.annotations.NotNull;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.yaml.snakeyaml.error.YAMLException;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.nio.file.Path;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+
+public class PaperPluginProvider implements PluginProvider<PaperPluginParentProvider> {
+
+    public static PaperPluginProvider of(JarFile file, JarEntry config, Path pluginPath) throws Exception {
+        try (InputStream inputStream = file.getInputStream(config);
+             InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
+             BufferedReader bufferedReader = new BufferedReader(inputStreamReader) // TODO: Is there a nicer way here?
+        ) {
+            return new PaperPluginProvider(pluginPath, file, PaperPluginConfiguration.create(bufferedReader));
+        } catch (IOException | YAMLException ex) {
+            throw new InvalidDescriptionException(ex);
+        }
+    }
+
+    private final Path path;
+    private final PaperPluginConfiguration description;
+    private final JarFile jarFile;
+
+    private final Logger logger;
+    /*
+    A classloader must be shared here, as this is used in a pre-initializer and the actual java plugin.y
+     */
+
+
+    private PaperPluginProvider(Path path, JarFile file, PaperPluginConfiguration description) throws IOException {
+        this.path = path;
+        this.jarFile = file;
+        this.description = description;
+        this.logger = LoggerFactory.getLogger(description.getLoggingPrefix() == null ? description.getIdentifier() : description.getLoggingPrefix());
+    }
+
+    @Override
+    public @NotNull Path getSource() {
+        return this.path;
+    }
+
+    @Override
+    public JarFile file() {
+        return this.jarFile;
+    }
+
+    @Override
+    public PaperPluginParentProvider createInstance() {
+        PaperClasspathBuilder builder = new PaperClasspathBuilder();
+
+        if (this.description.getLoader() != null) {
+            try (
+                PaperSimplePluginClassLoader simplePluginClassLoader = new PaperSimplePluginClassLoader(this, this.getClass().getClassLoader())
+            ) {
+                ProviderUtil.loadClass(this.description.getLoader(), PluginLoader.class, simplePluginClassLoader, (pluginLoader) -> {
+                    pluginLoader.classloader(builder);
+                });
+
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        return new PaperPluginParentProvider(this.path, this.jarFile, this.description, builder.buildClassLoader(this), this.logger);
+    }
+
+    public PaperPluginConfiguration getConfiguration() {
+        return this.description;
+    }
+
+    @Override
+    public Logger getLogger() {
+        return this.logger;
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/ProviderUtil.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/ProviderUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..0afb297d5eaca9b9b132cb668ee9582d1194ba24
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/ProviderUtil.java
@@ -0,0 +1,47 @@
+package io.papermc.paper.plugin.provider.type.paper;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+
+import java.util.function.Consumer;
+
+public class ProviderUtil {
+
+
+    public static <T> T loadClass(String clazz, Class<T> classType, ClassLoader loader, Consumer<T> runnable) {
+        return loadClass(clazz, classType, loader, runnable, null);
+    }
+
+    public static <T> T loadClass(String clazz, Class<T> classType, ClassLoader loader, Consumer<T> runnable, Runnable onError) {
+        try {
+            T clazzInstance;
+
+            try {
+                Class<?> jarClass = Class.forName(clazz, true, loader);
+
+                Class<? extends T> pluginClass;
+                try {
+                    pluginClass = jarClass.asSubclass(classType);
+                } catch (ClassCastException ex) {
+                    throw new ClassCastException("class '%s' does not extend '%s'".formatted(clazz, classType));
+                }
+
+                clazzInstance = pluginClass.getDeclaredConstructor().newInstance();
+            } catch (IllegalAccessException exception) {
+                throw new RuntimeException("No public constructor");
+            } catch (InstantiationException exception) {
+                throw new RuntimeException("Abnormal plugin type", exception);
+            }
+
+            runnable.accept(clazzInstance);
+            return clazzInstance;
+        } catch (Throwable e) {
+            if (onError != null) {
+                onError.run();
+            }
+            SneakyThrow.sneaky(e);
+        }
+
+        throw new AssertionError(); // Shouldn't happen
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProvider.java b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..77d81c3aa4fcfafa33bb7ee796c7558834815c3b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProvider.java
@@ -0,0 +1,118 @@
+package io.papermc.paper.plugin.provider.type.spigot;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+import io.papermc.paper.plugin.provider.ProviderStatus;
+import io.papermc.paper.plugin.provider.ProviderStatusHolder;
+import io.papermc.paper.plugin.provider.type.JavaPluginProvider;
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.InvalidDescriptionException;
+import org.bukkit.plugin.InvalidPluginException;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.SimplePluginManager;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import org.yaml.snakeyaml.error.YAMLException;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Path;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+
+public class SpigotPluginProvider extends JavaPluginProvider implements ProviderStatusHolder {
+
+    public static SpigotPluginProvider of(JarFile file, JarEntry config, Path pluginPath) throws Exception {
+        PluginDescriptionFile descriptionFile;
+        try (InputStream inputStream = file.getInputStream(config)) {
+            // throw new InvalidDescriptionException(new FileNotFoundException("Jar does not contain plugin.yml")); TODO: This will no longer happen. Fix this?
+            descriptionFile = new PluginDescriptionFile(inputStream);
+        } catch (IOException | YAMLException ex) {
+            throw new InvalidDescriptionException(ex);
+        }
+
+        // TODO ORIGINAL CODE: Should I keep logging it or should this be an exception?
+//        if (name.equalsIgnoreCase("bukkit") || name.equalsIgnoreCase("minecraft") || name.equalsIgnoreCase("mojang")) {
+//            server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + file.getParentFile().getPath() + "': Restricted Name"); // Paper
+//            continue;
+//        } else if (description.rawName.indexOf(' ') != -1) {
+//            server.getLogger().log(Level.SEVERE, "Could not load '" + file.getPath() + "' in folder '" + file.getParentFile().getPath() + "': uses the space-character (0x20) in its name"); // Paper
+//            continue;
+//        }
+
+        String name = descriptionFile.getIdentifier();
+        if (name.equalsIgnoreCase("bukkit") || name.equalsIgnoreCase("minecraft") || name.equalsIgnoreCase("mojang")) {
+            throw new InvalidDescriptionException("Restricted name, cannot use %s as a plugin name.".formatted(name));
+        } else if (descriptionFile.getRawName().indexOf(' ') != -1) {
+            throw new InvalidDescriptionException("Restricted name, cannot use 0x20 (space character) in a plugin name.");
+        }
+
+        return new SpigotPluginProvider(pluginPath, file, descriptionFile);
+    }
+
+    private ProviderStatus status;
+
+    private final Path path;
+    private final PluginDescriptionFile description;
+    private final JarFile jarFile;
+
+    private final Logger logger;
+
+    private SpigotPluginProvider(Path path, JarFile file, PluginDescriptionFile description) {
+        this.path = path;
+        this.jarFile = file;
+        this.description = description;
+        this.logger = LoggerFactory.getLogger(description.getLoggingPrefix() == null ? description.getIdentifier() : description.getLoggingPrefix());
+    }
+
+    @Override
+    public @NotNull Path getSource() {
+        return this.path;
+    }
+
+    @Override
+    public JarFile file() {
+        return this.jarFile;
+    }
+
+    @Override
+    public JavaPlugin createInstance() {
+        try {
+            SimplePluginManager simplePluginManager = (SimplePluginManager) Bukkit.getPluginManager();
+            JavaPlugin plugin = (JavaPlugin) simplePluginManager.loader.loadPlugin(this.description, this.path.toFile());
+            simplePluginManager.loadPlugin(plugin);
+            this.status = ProviderStatus.INITIALIZED;
+            return plugin;
+        } catch (InvalidPluginException ex) {
+            this.status = ProviderStatus.ERRORED;
+            SneakyThrow.sneaky(ex);
+        }
+
+        throw new IllegalStateException(); // Shouldn't happen
+    }
+
+    @Override
+    public PluginDescriptionFile getConfiguration() {
+        return this.description;
+    }
+
+    @Override
+    public Logger getLogger() {
+        return this.logger;
+    }
+
+    @Override
+    public ProviderStatus getLastProvidedStatus() {
+        return this.status;
+    }
+
+    @Override
+    public void setStatus(ProviderStatus status) {
+        this.status = status;
+    }
+
+    public boolean isLegacy() {
+        return !Bukkit.getUnsafe().isSupportedApiVersion(this.description.getAPIVersion());
+    }
+}
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 0a843e0afbcb1af8e2641515eb244b791b819b8c..61c9b66079feddd42704be20032fc869a506402a 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -105,6 +105,18 @@ public class Main {
             }
 
             Bootstrap.bootStrap();
+            // Paper start
+            io.papermc.paper.plugin.provider.PluginProviders provider = io.papermc.paper.plugin.provider.PluginProviders.INSTANCE;
+            File pluginfile = ((File) optionset.valueOf("plugins"));
+            provider.handlePluginDirectory(pluginfile.toPath());
+
+            @SuppressWarnings("unchecked")
+            java.util.List<File> files = (java.util.List<File>) optionset.valuesOf("add-plugin");
+            for (File file : files) {
+                provider.addFile(file.toPath());
+            }
+            io.papermc.paper.plugin.provider.service.storage.PreInitProviderStorage.INSTANCE.init();
+            // Paper end
             Bootstrap.validate();
             Util.startTimerHackThread();
             Path path = Paths.get("server.properties");
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index a8cf1ab9d7504dfdb2310f1dca82324a225bea7d..c0b2dc3c112d4692d001ee042326baea40a157a6 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -410,7 +410,8 @@ public final class CraftServer implements Server {
 
     public void loadPlugins() {
         this.pluginManager.registerInterface(JavaPluginLoader.class);
-
+        io.papermc.paper.plugin.provider.service.storage.ServerPluginProviderStorage.INSTANCE.loadAll();
+        if (true) return;
         File pluginFolder = this.getPluginsFolder(); // Paper
 
         // Paper start
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java b/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
index 909b2c98e7a9117d2f737245e4661792ffafb744..0aadfacf70adc48be64a8129e8a2f499f967abbc 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
@@ -42,6 +42,12 @@ public class MinecraftInternalPlugin extends PluginBase {
     public PluginDescriptionFile getDescription() {
         return pdf;
     }
+    // Paper start
+    @Override
+    public io.papermc.paper.plugin.provider.configuration.PluginConfiguration getConfiguration() {
+        return pdf;
+    }
+    // Paper end
 
     @Override
     public FileConfiguration getConfig() {

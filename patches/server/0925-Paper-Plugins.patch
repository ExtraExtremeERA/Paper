From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Wed, 6 Jul 2022 23:00:31 -0400
Subject: [PATCH] Paper Plugins


diff --git a/src/main/java/io/papermc/paper/command/PaperCommands.java b/src/main/java/io/papermc/paper/command/PaperCommands.java
index 37d28625b9528bbe0cd6d9623e702bbbc2b07883..ab9a00b60eed9da7e61feda90a69563a7ae8d05c 100644
--- a/src/main/java/io/papermc/paper/command/PaperCommands.java
+++ b/src/main/java/io/papermc/paper/command/PaperCommands.java
@@ -23,5 +23,6 @@ public final class PaperCommands {
         COMMANDS.forEach((s, command) -> {
             server.server.getCommandMap().register(s, "Paper", command);
         });
+        server.server.getCommandMap().register("bukkit", new PaperPluginsCommand());
     }
 }
diff --git a/src/main/java/io/papermc/paper/command/PaperPluginsCommand.java b/src/main/java/io/papermc/paper/command/PaperPluginsCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..4c9175686717132e529fbb4bd900a1d58dca3100
--- /dev/null
+++ b/src/main/java/io/papermc/paper/command/PaperPluginsCommand.java
@@ -0,0 +1,216 @@
+package io.papermc.paper.command;
+
+import com.google.common.collect.Lists;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.ProviderStatus;
+import io.papermc.paper.plugin.provider.ProviderStatusHolder;
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import io.papermc.paper.plugin.provider.service.storage.plugin.ServerPluginProviderStorage;
+import io.papermc.paper.plugin.provider.type.JavaPluginProvider;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginProvider;
+import io.papermc.paper.plugin.provider.type.spigot.SpigotPluginProvider;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.JoinConfiguration;
+import net.kyori.adventure.text.TextComponent;
+import net.kyori.adventure.text.event.ClickEvent;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextColor;
+import org.bukkit.Bukkit;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.defaults.BukkitCommand;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.TreeMap;
+
+public class PaperPluginsCommand extends BukkitCommand {
+
+    private static final TextColor INFO_COLOR = TextColor.color(52, 159, 218);
+
+    // TODO: LINK?
+    private static final Component SERVER_PLUGIN_INFO = Component.text("ℹ What is a server plugin?", INFO_COLOR)
+        .append(asPlainComponents("""
+            Server plugins can add new behavior to your server!
+            You can find new plugins on Paper's plugin repository, Hangar.
+                        
+            <link to hangar>
+            """));
+
+    private static final Component SERVER_INITIALIZER_INFO = Component.text("ℹ What is a server initializer?", INFO_COLOR)
+        .append(asPlainComponents("""
+            Server initializers are ran before your server
+            starts and are provided by paper plugins.
+            """));
+
+    private static final Component LEGACY_PLUGIN_INFO = Component.text("ℹ What is a legacy plugin?", INFO_COLOR)
+        .append(asPlainComponents("""
+            A legacy plugin is a plugin that was made on
+            very old unsupported versions of the game.
+                        
+            It is encouraged that you replace this plugin,
+            as they might not work in the future and may cause
+            performance issues.
+            """));
+
+    private static final Component INFO_ICON_START = Component.text("ℹ ", INFO_COLOR);
+
+    private static final Component PAPER_HEADER = Component.text("Paper Plugins:", TextColor.color(2, 136, 209));
+    private static final Component BUKKIT_HEADER = Component.text("Bukkit Plugins:", TextColor.color(237, 129, 6));
+
+    private static final Component PLUGIN_TICK = Component.text("- ", NamedTextColor.DARK_GRAY);
+    private static final Component PLUGIN_TICK_EMPTY = Component.text(" ");
+
+    private static final Component LEGACY_PLUGIN_STAR = Component.text('*', TextColor.color(255, 212, 42))
+        .hoverEvent(LEGACY_PLUGIN_INFO);
+
+    public PaperPluginsCommand() {
+        super("plugins");
+        this.description = "Gets a list of plugins running on the server";
+        this.usageMessage = "/plugins";
+        this.setPermission("bukkit.command.plugins");
+        this.setAliases(Arrays.asList("pl"));
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String currentAlias, @NotNull String[] args) {
+        if (!this.testPermission(sender)) return true;
+
+        // Plugins
+        {
+            TreeMap<String, PluginProvider<JavaPlugin>> paperPlugins = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
+            TreeMap<String, PluginProvider<JavaPlugin>> spigotPlugins = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
+
+            for (PluginProvider<JavaPlugin> provider : ServerPluginProviderStorage.INSTANCE.getRegisteredProviders()) {
+                PluginConfiguration configuration = provider.getConfiguration();
+
+                if (provider instanceof SpigotPluginProvider) {
+                    spigotPlugins.put(configuration.getDisplayName(), provider);
+                } else if (provider instanceof PaperPluginProvider.PaperServerPluginProvider) {
+                    paperPlugins.put(configuration.getDisplayName(), provider);
+                }
+            }
+
+            sender.sendMessage(INFO_ICON_START.hoverEvent(SERVER_PLUGIN_INFO).append(Component.text("Server Plugins (%s):".formatted(paperPlugins.size() + spigotPlugins.size()), NamedTextColor.WHITE)));
+            sender.sendMessage(PAPER_HEADER);
+            for (Component component : formatProviders(paperPlugins)) {
+                sender.sendMessage(component);
+            }
+            sender.sendMessage(BUKKIT_HEADER);
+            for (Component component : formatProviders(spigotPlugins)) {
+                sender.sendMessage(component);
+            }
+
+        }
+
+        // Providers
+        /*
+        {
+            TreeMap<String, PluginProvider<Initializer>> providers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);
+            for (PluginProvider<Initializer> provider : PreInitProviderStorage.INSTANCE.getRegisteredProviders()) {
+                providers.put(provider.getConfiguration().getIdentifier(), provider);
+            }
+
+            sender.sendMessage(INFO_ICON_START.hoverEvent(SERVER_INITIALIZER_INFO).append(Component.text("Server Initializers (%s):".formatted(providers.size()), NamedTextColor.WHITE)));
+            sender.sendMessage(formatProviders(providers));
+
+        }
+         */
+        return true;
+    }
+
+    @NotNull
+    @Override
+    public List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, @NotNull String[] args) throws IllegalArgumentException {
+        return Collections.emptyList();
+    }
+
+    private static <T> List<Component> formatProviders(TreeMap<String, PluginProvider<T>> plugins) {
+        List<Component> components = new ArrayList<>(plugins.size());
+        for (PluginProvider<T> entry : plugins.values()) {
+            components.add(formatProvider(entry));
+        }
+
+        boolean isFirst = true;
+        List<Component> formattedSublists = new ArrayList<>();
+        /*
+        Split up the plugin list for each 10 plugins to get size down
+
+        Plugin List:
+        - Plugin 1, Plugin 2, .... Plugin 10,
+          Plugin 11, Plugin 12 ... Plugin 20,
+         */
+        for (List<Component> componentSublist : Lists.partition(components, 10)) {
+            Component component = Component.space();
+            if (isFirst) {
+                component = component.append(PLUGIN_TICK);
+                isFirst = false;
+            } else {
+                component = PLUGIN_TICK_EMPTY;
+                //formattedSublists.add(Component.empty()); // Add an empty line, the auto chat wrapping and this makes it quite jarring.
+            }
+
+            formattedSublists.add(component.append(Component.join(JoinConfiguration.commas(true), componentSublist)));
+        }
+
+        return formattedSublists;
+    }
+
+    private static Component formatProvider(PluginProvider<?> provider) {
+        TextComponent.Builder builder = Component.text();
+        if (provider instanceof SpigotPluginProvider spigotPluginProvider && spigotPluginProvider.isLegacy()) {
+            builder.append(LEGACY_PLUGIN_STAR);
+        }
+
+        String name = provider.getConfiguration().getIdentifier();
+        Component pluginName = Component.text(name, fromStatus(provider))
+            .clickEvent(ClickEvent.runCommand("/version " + name));
+
+        builder.append(pluginName);
+
+        return builder.build();
+    }
+
+    private static Component asPlainComponents(String strings) {
+        net.kyori.adventure.text.TextComponent.Builder builder = Component.text();
+        for (String string : strings.split("\n")) {
+            builder.append(Component.newline());
+            builder.append(Component.text(string, NamedTextColor.WHITE));
+        }
+
+        return builder.build();
+    }
+
+    private static TextColor fromStatus(PluginProvider<?> provider) {
+        if (provider instanceof ProviderStatusHolder statusHolder && statusHolder.getLastProvidedStatus() != null) {
+            ProviderStatus status = statusHolder.getLastProvidedStatus();
+
+            // Handle enabled/disabled game plugins
+            if (status == ProviderStatus.INITIALIZED && provider instanceof JavaPluginProvider javaPluginProvider) {
+                Plugin plugin = Bukkit.getPluginManager().getPlugin(javaPluginProvider.getConfiguration().getIdentifier());
+                // Plugin doesn't exist? Could be due to it being removed.
+                if (plugin == null) {
+                    return NamedTextColor.RED;
+                }
+
+                return plugin.isEnabled() ? NamedTextColor.GREEN : NamedTextColor.RED;
+            }
+
+            return switch (status) {
+                case INITIALIZED -> NamedTextColor.GREEN;
+                case ERRORED -> NamedTextColor.RED;
+            };
+        } else if (provider instanceof PaperPluginProvider.PaperServerPluginProvider serverPluginProvider && serverPluginProvider.shouldSkipCreation()) {
+            // Paper plugins will be skipped if their provider is skipped due to their initializer failing.
+            // Show them as red
+            return NamedTextColor.RED;
+        } else {
+            return NamedTextColor.GRAY;
+        }
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContextImpl.java b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContextImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..f0d0d45266ca4115db31fbf44200d2c43f47394a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/bootstrap/PluginBootstrapContextImpl.java
@@ -0,0 +1,38 @@
+package io.papermc.paper.plugin.bootstrap;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+import java.util.logging.Logger;
+
+public record PluginBootstrapContextImpl(PluginProvider<?> provider,
+                                         Path dataFolder) implements PluginBootstrapContext {
+
+    public static PluginBootstrapContextImpl of(PluginProvider<?> provider, Path pluginFolder) {
+        Path dataFolder = pluginFolder.resolve(provider.getConfiguration().getDisplayName());
+
+        return new PluginBootstrapContextImpl(provider, dataFolder);
+    }
+
+    @Override
+    public @NotNull PluginConfiguration getConfiguration() {
+        return this.provider.getConfiguration();
+    }
+
+    @Override
+    public @NotNull Path getDataDirectory() {
+        return this.dataFolder;
+    }
+
+    @Override
+    public @NotNull Path getConfigurationFile() {
+        return this.dataFolder.resolve("config.yml");
+    }
+
+    @Override
+    public @NotNull Logger getLogger() {
+        return this.provider.getLogger();
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/PluginProvider.java b/src/main/java/io/papermc/paper/plugin/provider/PluginProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..412d392f667e4a6d53c41e8162239c5e80eece90
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/PluginProvider.java
@@ -0,0 +1,33 @@
+package io.papermc.paper.plugin.provider;
+
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import org.jetbrains.annotations.ApiStatus;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+import java.util.jar.JarFile;
+import java.util.logging.Logger;
+
+@ApiStatus.Internal
+public interface PluginProvider<T> {
+
+    @NotNull
+    Path getSource();
+
+    default Path getFileName() {
+        return this.getSource().getFileName();
+    }
+
+    default Path getParentSource() {
+        return this.getSource().getParent();
+    }
+
+    JarFile file();
+
+    T createInstance();
+
+    PluginConfiguration getConfiguration();
+
+    Logger getLogger();
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/ProviderStatus.java b/src/main/java/io/papermc/paper/plugin/provider/ProviderStatus.java
new file mode 100644
index 0000000000000000000000000000000000000000..3f29ba87ce732024f08c56347c98fc26bee99837
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/ProviderStatus.java
@@ -0,0 +1,10 @@
+package io.papermc.paper.plugin.provider;
+
+import org.jetbrains.annotations.ApiStatus;
+
+@ApiStatus.Internal
+public enum ProviderStatus {
+    INITIALIZED,
+    ERRORED,
+    ;
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/ProviderStatusHolder.java b/src/main/java/io/papermc/paper/plugin/provider/ProviderStatusHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..94023e8b7f5011d4962e7859dd8771ab02f6dc11
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/ProviderStatusHolder.java
@@ -0,0 +1,8 @@
+package io.papermc.paper.plugin.provider;
+
+public interface ProviderStatusHolder {
+
+    ProviderStatus getLastProvidedStatus();
+
+    void setStatus(ProviderStatus status);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/FlattenedResolver.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/FlattenedResolver.java
new file mode 100644
index 0000000000000000000000000000000000000000..6ba3bcc468c0a60c76d6d0f0243bda661c737f2f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/FlattenedResolver.java
@@ -0,0 +1,29 @@
+package io.papermc.paper.plugin.provider.configuration;
+
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.objectmapping.meta.NodeResolver;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.lang.reflect.AnnotatedElement;
+
+@Retention(RetentionPolicy.RUNTIME)
+@Target(ElementType.FIELD)
+public @interface FlattenedResolver {
+
+    final class Factory implements NodeResolver.Factory {
+
+        @Override
+        public @Nullable NodeResolver make(String name, AnnotatedElement element) {
+            if (element.isAnnotationPresent(FlattenedResolver.class)) {
+                return (node) -> node;
+            } else {
+                return null;
+            }
+        }
+    }
+
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/PaperPluginConfiguration.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/PaperPluginConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..87a93b47be68cd75fb81579dee88939f8791ffb7
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/PaperPluginConfiguration.java
@@ -0,0 +1,210 @@
+package io.papermc.paper.plugin.provider.configuration;
+
+import com.google.common.collect.ImmutableList;
+import io.leangen.geantyref.TypeToken;
+import io.papermc.paper.configuration.constraint.Constraint;
+import io.papermc.paper.configuration.serializer.ComponentSerializer;
+import io.papermc.paper.configuration.serializer.EnumValueSerializer;
+import io.papermc.paper.configuration.serializer.collections.MapSerializer;
+import io.papermc.paper.plugin.provider.configuration.serializer.ImmutableListSerializer;
+import io.papermc.paper.plugin.provider.configuration.serializer.PermissionConfigurationSerializer;
+import io.papermc.paper.plugin.provider.configuration.serializer.constraints.PluginConfigConstraints;
+import io.papermc.paper.plugin.provider.configuration.type.PaperCommandMap;
+import io.papermc.paper.plugin.provider.configuration.type.PermissionConfiguration;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.bukkit.plugin.PluginLoadOrder;
+import org.jetbrains.annotations.NotNull;
+import org.spongepowered.configurate.CommentedConfigurationNode;
+import org.spongepowered.configurate.ConfigurateException;
+import org.spongepowered.configurate.loader.HeaderMode;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+import org.spongepowered.configurate.objectmapping.ObjectMapper;
+import org.spongepowered.configurate.objectmapping.meta.Required;
+import org.spongepowered.configurate.yaml.NodeStyle;
+import org.spongepowered.configurate.yaml.YamlConfigurationLoader;
+
+import java.io.BufferedReader;
+import java.util.List;
+import java.util.Map;
+
+@ConfigSerializable
+public class PaperPluginConfiguration implements PluginConfiguration {
+
+    @PluginConfigConstraints.PluginName
+    @Required
+    private String name = null;
+    @Required
+    @PluginConfigConstraints.PluginNameSpace
+    private String main = null;
+    @PluginConfigConstraints.PluginNameSpace
+    private String bootstrapper = null;
+    @PluginConfigConstraints.PluginNameSpace
+    private String loader = null;
+    private List<String> depend = List.of();
+    private List<String> softDepend = List.of();
+    private List<String> loadBefore = List.of();
+    private List<String> provides = List.of();
+    @Required
+    private String version = null;
+    @FlattenedResolver
+    private PaperCommandMap commandMap = new PaperCommandMap(Map.of());
+    private String description = null;
+    private List<String> authors = List.of();
+    private List<String> contributors = List.of();
+    private String website = null;
+    private String prefix = null;
+    private PluginLoadOrder load = PluginLoadOrder.POSTWORLD;
+    @FlattenedResolver
+    private PermissionConfiguration permissionConfiguration = new PermissionConfiguration(PermissionDefault.OP, List.of());
+    private String apiVersion = null;
+
+    private transient String displayName;
+
+    public static PaperPluginConfiguration create(BufferedReader reader) throws ConfigurateException {
+        YamlConfigurationLoader loader = YamlConfigurationLoader.builder()
+            .indent(2)
+            .nodeStyle(NodeStyle.BLOCK)
+            .headerMode(HeaderMode.NONE)
+            .source(() -> reader)
+            .defaultOptions((options) -> {
+
+                return options.serializers((serializers) -> {
+                    serializers
+                        .register(new EnumValueSerializer())
+                        .register(MapSerializer.TYPE, new MapSerializer(false))
+                        .register(new TypeToken<List<?>>() {}, new ImmutableListSerializer())
+                        .register(PermissionConfiguration.class, PermissionConfigurationSerializer.SERIALIZER)
+                        .register(new ComponentSerializer())
+                        .registerAnnotatedObjects(
+                            ObjectMapper.factoryBuilder()
+                                .addConstraint(Constraint.class, new Constraint.Factory())
+                                .addConstraint(PluginConfigConstraints.PluginName.class, String.class, new PluginConfigConstraints.PluginName.Factory())
+                                .addNodeResolver(new FlattenedResolver.Factory())
+                                .build()
+                        );
+
+                });
+            })
+            .build();
+        CommentedConfigurationNode node = loader.load();
+        PaperPluginConfiguration pluginConfiguration = node.require(PaperPluginConfiguration.class);
+
+        // TODO: a better way to do this?
+        if (node.getString("author") != null) {
+            pluginConfiguration.authors = ImmutableList.<String>builder()
+                .addAll(pluginConfiguration.authors)
+                .add(node.getString("author"))
+                .build();
+        }
+
+        pluginConfiguration.displayName = pluginConfiguration.name.replace('_', ' ');
+
+        return pluginConfiguration;
+    }
+
+    public PaperPluginConfiguration() {
+    }
+
+    @Override
+    public @NotNull String getIdentifier() {
+        return this.name;
+    }
+
+    @Override
+    public @NotNull String getMain() {
+        return this.main;
+    }
+
+    @Override
+    public @NotNull String getVersion() {
+        return this.version;
+    }
+
+    @Override
+    public @NotNull String getDisplayName() {
+        return this.displayName;
+    }
+
+    @Override
+    public @NotNull String getLoggingPrefix() {
+        return this.prefix;
+    }
+
+    @Override
+    public @NotNull List<String> getHardDependencies() {
+        return this.depend;
+    }
+
+    @Override
+    public @NotNull List<String> getSoftDependencies() {
+        return this.softDepend;
+    }
+
+    @Override
+    public @NotNull List<String> getLoadBefore() {
+        return this.loadBefore;
+    }
+
+    @Override
+    public @NotNull PluginLoadOrder getLoadPhase() {
+        return this.load;
+    }
+
+    @Override
+    public boolean isTransitiveDependency(PluginConfiguration other) {
+        return true;
+    }
+
+    @Override
+    public @NotNull String getDescription() {
+        return this.description;
+    }
+
+    @Override
+    public @NotNull List<String> getAuthors() {
+        return this.authors;
+    }
+
+    @Override
+    public @NotNull List<String> getContributors() {
+        return this.contributors;
+    }
+
+    @Override
+    public String getWebsite() {
+        return this.website;
+    }
+
+    @Override
+    public @NotNull List<Permission> getPermissions() {
+        return this.permissionConfiguration.permissions();
+    }
+
+    @Override
+    public @NotNull PermissionDefault getDefaultPermission() {
+        return this.permissionConfiguration.defaultPerm();
+    }
+
+    @Override
+    public @NotNull String getApiVersion() {
+        return this.apiVersion;
+    }
+
+    @Override
+    public @NotNull List<String> getProvides() {
+        return this.provides;
+    }
+
+    public String getBootstrapper() {
+        return this.bootstrapper;
+    }
+
+    public String getLoader() {
+        return this.loader;
+    }
+
+    public PaperCommandMap getCommandMap() {
+        return this.commandMap;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/ImmutableCollectionSerializer.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/ImmutableCollectionSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..b47064eafe4f9445baa09e74f4c89804a34187f4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/ImmutableCollectionSerializer.java
@@ -0,0 +1,90 @@
+package io.papermc.paper.plugin.provider.configuration.serializer;
+
+import com.google.common.collect.ImmutableCollection;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.ConfigurationOptions;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.serialize.TypeSerializer;
+import org.spongepowered.configurate.util.CheckedConsumer;
+
+import java.lang.reflect.Type;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+@SuppressWarnings("unchecked")
+public abstract class ImmutableCollectionSerializer<B extends ImmutableCollection.Builder<?>, T extends Collection<?>> implements TypeSerializer<T> {
+
+    protected ImmutableCollectionSerializer() {
+    }
+
+    @Override
+    public final T deserialize(final Type type, final ConfigurationNode node) throws SerializationException {
+        final Type entryType = this.elementType(type);
+        final @Nullable TypeSerializer<?> entrySerial = node.options().serializers().get(entryType);
+        if (entrySerial == null) {
+            throw new SerializationException(node, entryType, "No applicable type serializer for type");
+        }
+
+        if (node.isList()) {
+            final List<? extends ConfigurationNode> values = node.childrenList();
+            final B builder = this.createNew(values.size());
+            for (int i = 0; i < values.size(); ++i) {
+                try {
+                    this.deserializeSingle(i, builder, entrySerial.deserialize(entryType, values.get(i)));
+                } catch (final SerializationException ex) {
+                    ex.initPath(values.get(i)::path);
+                    throw ex;
+                }
+            }
+            return (T) builder.build();
+        } else {
+            final @Nullable Object unwrappedVal = node.raw();
+            if (unwrappedVal != null) {
+                final B builder = this.createNew(1);
+                this.deserializeSingle(0, builder, entrySerial.deserialize(entryType, node));
+                return (T) builder.build();
+            }
+        }
+        return this.emptyValue(type, null);
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    @Override
+    public final void serialize(final Type type, final @Nullable T obj, final ConfigurationNode node) throws SerializationException {
+        final Type entryType = this.elementType(type);
+        final @Nullable TypeSerializer entrySerial = node.options().serializers().get(entryType);
+        if (entrySerial == null) {
+            throw new SerializationException(node, entryType, "No applicable type serializer for type");
+        }
+
+        node.raw(Collections.emptyList());
+        if (obj != null) {
+            this.forEachElement(obj, el -> {
+                final ConfigurationNode child = node.appendListNode();
+                try {
+                    entrySerial.serialize(entryType, el, child);
+                } catch (final SerializationException ex) {
+                    ex.initPath(child::path);
+                    throw ex;
+                }
+            });
+        }
+    }
+
+    @SuppressWarnings({"unchecked"})
+    @Override
+    public @Nullable T emptyValue(final Type specificType, final ConfigurationOptions options) {
+        return (T) this.createNew(0).build();
+    }
+
+    protected abstract Type elementType(Type containerType) throws SerializationException;
+
+    protected abstract B createNew(int size);
+
+    protected abstract void forEachElement(T collection, CheckedConsumer<Object, SerializationException> action) throws SerializationException;
+
+    protected abstract void deserializeSingle(int index, B builder, @Nullable Object deserialized) throws SerializationException;
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/ImmutableListSerializer.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/ImmutableListSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..0742f9bb757708c30f64ab0887c53543750830da
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/ImmutableListSerializer.java
@@ -0,0 +1,43 @@
+package io.papermc.paper.plugin.provider.configuration.serializer;
+
+import com.google.common.collect.ImmutableList;
+import org.checkerframework.checker.nullness.qual.Nullable;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.util.CheckedConsumer;
+
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+import java.util.List;
+
+public class ImmutableListSerializer extends ImmutableCollectionSerializer<ImmutableList.Builder<?>, List<?>> {
+
+    @Override
+    protected Type elementType(Type containerType) throws SerializationException {
+        if (!(containerType instanceof ParameterizedType)) {
+            throw new SerializationException(containerType, "Raw types are not supported for collections");
+        }
+        return ((ParameterizedType) containerType).getActualTypeArguments()[0];
+    }
+
+    @Override
+    protected ImmutableList.Builder<?> createNew(int size) {
+        return ImmutableList.builderWithExpectedSize(size);
+    }
+
+    @Override
+    protected void forEachElement(List<?> collection, CheckedConsumer<Object, SerializationException> action) throws SerializationException {
+        for (Object obj : collection) {
+            action.accept(obj);
+        }
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    @Override
+    protected void deserializeSingle(int index, ImmutableList.Builder<?> builder, @Nullable Object deserialized) throws SerializationException {
+        if (deserialized == null) {
+            return;
+        }
+
+        ((ImmutableList.Builder) builder).add(deserialized);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/PermissionConfigurationSerializer.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/PermissionConfigurationSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..d1088e4b7fa5f8e689f23b150b83645ce1ae5a0e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/PermissionConfigurationSerializer.java
@@ -0,0 +1,56 @@
+package io.papermc.paper.plugin.provider.configuration.serializer;
+
+import io.papermc.paper.plugin.provider.configuration.type.PermissionConfiguration;
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.spongepowered.configurate.ConfigurationNode;
+import org.spongepowered.configurate.serialize.SerializationException;
+import org.spongepowered.configurate.serialize.TypeSerializer;
+
+import java.lang.reflect.Type;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+public class PermissionConfigurationSerializer {
+
+    public static final Serializer SERIALIZER = new Serializer();
+
+    private static final class Serializer implements TypeSerializer<PermissionConfiguration> {
+        private Serializer() {
+            super();
+        }
+
+        @Override
+        public PermissionConfiguration deserialize(Type type, ConfigurationNode node) throws SerializationException {
+            Map<?, ?> map = (Map<?, ?>) node.node("permissions").raw();
+
+            PermissionDefault permissionDefault;
+            ConfigurationNode permNode = node.node("defaultPerm");
+            if (permNode.virtual()) {
+                permissionDefault = PermissionDefault.OP;
+            } else {
+                permissionDefault = PermissionDefault.getByName(permNode.getString());
+            }
+
+            List<Permission> result = new ArrayList<>();
+            if (map != null) {
+                for (Map.Entry<?, ?> entry : map.entrySet()) {
+                    try {
+                        result.add(Permission.loadPermission(entry.getKey().toString(), (Map<?, ?>) entry.getValue(), permissionDefault, result));
+                    } catch (Throwable ex) {
+                        throw new SerializationException(null, "Error loading permission %s".formatted(entry.getKey()), ex);
+                    }
+                }
+            }
+
+            return new PermissionConfiguration(permissionDefault, List.copyOf(result));
+        }
+
+        @Override
+        public void serialize(Type type, @org.checkerframework.checker.nullness.qual.Nullable PermissionConfiguration obj, ConfigurationNode node) throws SerializationException {
+
+        }
+
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
new file mode 100644
index 0000000000000000000000000000000000000000..f49eece73240b195528ecf8cac686b3c3553c103
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/serializer/constraints/PluginConfigConstraints.java
@@ -0,0 +1,67 @@
+package io.papermc.paper.plugin.provider.configuration.serializer.constraints;
+
+import io.papermc.paper.plugin.provider.util.NamespaceChecker;
+import org.spongepowered.configurate.objectmapping.meta.Constraint;
+import org.spongepowered.configurate.serialize.SerializationException;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+import java.lang.reflect.Type;
+import java.util.Locale;
+import java.util.Set;
+import java.util.regex.Pattern;
+
+public final class PluginConfigConstraints {
+
+    public static final Set<String> RESERVED_KEYS = Set.of("bukkit", "minecraft", "mojang", "spigot", "paper");
+
+    @Documented
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target(ElementType.FIELD)
+    public @interface PluginName {
+
+        final class Factory implements Constraint.Factory<PluginName, String> {
+
+            private static final Pattern VALID_NAME = Pattern.compile("^[A-Za-z0-9 _.-]+$");
+
+            @Override
+            public Constraint<String> make(PluginName data, Type type) {
+                return value -> {
+                    if (value != null) {
+                        if (RESERVED_KEYS.contains(value.toLowerCase(Locale.ROOT))) {
+                            throw new SerializationException("Restricted name, cannot use '%s' as a plugin name.".formatted(data));
+                        } else if (value.indexOf(' ') != -1) {
+                            // For legacy reasons, the space condition has a separate exception message.
+                            throw new SerializationException("Restricted name, cannot use 0x20 (space character) in a plugin name.");
+                        }
+
+                        if (!VALID_NAME.matcher(value).matches()) {
+                            throw new SerializationException("name '" + value + "' contains invalid characters.");
+                        }
+                    }
+                };
+            }
+        }
+    }
+
+    @Documented
+    @Retention(RetentionPolicy.RUNTIME)
+    @Target(ElementType.FIELD)
+    public @interface PluginNameSpace {
+
+        final class Factory implements Constraint.Factory<PluginName, String> {
+
+            @Override
+            public Constraint<String> make(PluginName data, Type type) {
+                return value -> {
+                    if (value != null && !NamespaceChecker.isValidNameSpace(value)) {
+                        throw new SerializationException("provided class '%s' is in an invalid namespace.".formatted(value));
+                    }
+                };
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PaperCommand.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PaperCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..824f32258c2cc6a2908eca573fa14ea6756116e1
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PaperCommand.java
@@ -0,0 +1,16 @@
+package io.papermc.paper.plugin.provider.configuration.type;
+
+import net.kyori.adventure.text.Component;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+import java.util.List;
+
+@ConfigSerializable
+public record PaperCommand(
+    String description,
+    String usage,
+    List<String> aliases,
+    String permission,
+    Component permissionMessage
+) {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PaperCommandMap.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PaperCommandMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..f00fa0e630687b58fbb783b3fb0231102012878a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PaperCommandMap.java
@@ -0,0 +1,23 @@
+package io.papermc.paper.plugin.provider.configuration.type;
+
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+import java.util.Map;
+
+@ConfigSerializable
+public class PaperCommandMap {
+
+    private Map<String, PaperCommand> commands;
+
+    public PaperCommandMap() {
+    }
+
+    public PaperCommandMap(Map<String, PaperCommand> commands) {
+        this.commands = commands;
+    }
+
+    public Map<String, PaperCommand> getCommands() {
+        return this.commands;
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PermissionConfiguration.java b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PermissionConfiguration.java
new file mode 100644
index 0000000000000000000000000000000000000000..a180612a1ec395202dbae1ca5b97ec01382097e4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/configuration/type/PermissionConfiguration.java
@@ -0,0 +1,14 @@
+package io.papermc.paper.plugin.provider.configuration.type;
+
+import org.bukkit.permissions.Permission;
+import org.bukkit.permissions.PermissionDefault;
+import org.spongepowered.configurate.objectmapping.ConfigSerializable;
+
+import java.util.List;
+
+// Record components used for deserialization!!!!
+@ConfigSerializable
+public record PermissionConfiguration(
+    PermissionDefault defaultPerm,
+    List<Permission> permissions) {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/loader/PaperClasspathBuilder.java b/src/main/java/io/papermc/paper/plugin/provider/loader/PaperClasspathBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..bbb805adaaa230be0d285795b5b0487b33dca377
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/loader/PaperClasspathBuilder.java
@@ -0,0 +1,50 @@
+package io.papermc.paper.plugin.provider.loader;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.loader.library.ClassPathLibrary;
+import io.papermc.paper.plugin.provider.loader.library.PaperLibraryStore;
+import io.papermc.paper.plugin.provider.service.classloader.PaperPluginClassLoader;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+
+public class PaperClasspathBuilder implements PluginClasspathBuilder {
+
+    private final List<ClassPathLibrary> libraries = new ArrayList<>();
+
+    @Override
+    public @NotNull PluginClasspathBuilder addLibrary(@NotNull ClassPathLibrary classPathLibrary) {
+        this.libraries.add(classPathLibrary);
+        return this;
+    }
+
+    public PaperPluginClassLoader buildClassLoader(PluginProvider<?> provider) {
+        PaperLibraryStore paperLibraryStore = new PaperLibraryStore();
+        for (ClassPathLibrary library : this.libraries) {
+            library.addToLibraryStore(paperLibraryStore);
+        }
+
+        List<Path> paths = paperLibraryStore.getPaths();
+        URL[] urls = new URL[paths.size()];
+        for (int i = 0; i < paths.size(); i++) {
+            Path path = paperLibraryStore.getPaths().get(i);
+            try {
+                urls[i] = path.toUri().toURL();
+            } catch (MalformedURLException e) {
+                throw new AssertionError(e);
+            }
+        }
+
+        try {
+            return new PaperPluginClassLoader(provider.getLogger(), provider.getSource(), provider.file(), provider.getConfiguration(), this.getClass().getClassLoader(), new URLClassLoader(urls));
+        } catch (IOException exception) {
+            throw new RuntimeException(exception);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/loader/library/PaperLibraryStore.java b/src/main/java/io/papermc/paper/plugin/provider/loader/library/PaperLibraryStore.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b801f40d82df4d2a80c4c44e149d84389c5e064
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/loader/library/PaperLibraryStore.java
@@ -0,0 +1,21 @@
+package io.papermc.paper.plugin.provider.loader.library;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+
+public class PaperLibraryStore implements LibraryStore {
+
+    private final List<Path> paths = new ArrayList<>();
+
+    @Override
+    public void addLibrary(@NotNull Path library) {
+        this.paths.add(library);
+    }
+
+    public List<Path> getPaths() {
+        return this.paths;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperClassloaderBytecodeModifier.java b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperClassloaderBytecodeModifier.java
new file mode 100644
index 0000000000000000000000000000000000000000..a0a3fc2886c2381bf42468797ea1e64d39e2d4d0
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperClassloaderBytecodeModifier.java
@@ -0,0 +1,17 @@
+package io.papermc.paper.plugin.provider.service.classloader;
+
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import io.papermc.paper.plugin.provider.service.classloader.bytecode.ClassloaderBytecodeModifier;
+
+// Stub, implement in future.
+public class PaperClassloaderBytecodeModifier extends ClassloaderBytecodeModifier {
+
+    public static void init() {
+        ClassloaderBytecodeModifier.setInstance(new PaperClassloaderBytecodeModifier());
+    }
+
+    @Override
+    public byte[] modify(PluginConfiguration configuration, byte[] bytecode) {
+        return bytecode;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoader.java b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..a645cce8b66cc5319a21c050e3902f141a50273a
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperPluginClassLoader.java
@@ -0,0 +1,193 @@
+package io.papermc.paper.plugin.provider.service.classloader;
+
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.serialization.ConfigurationSerializable;
+import org.bukkit.configuration.serialization.ConfigurationSerialization;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoader;
+import org.bukkit.plugin.SimplePluginManager;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.URL;
+import java.nio.file.Path;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.jar.JarFile;
+import java.util.logging.Logger;
+
+public class PaperPluginClassLoader extends PaperSimplePluginClassLoader implements ConfiguredPluginClassLoader {
+
+    private final PaperPluginClassLoaderStorage loader;
+    private final ClassLoader libraryLoader;
+
+    private final Map<String, Class<?>> loadedClasses = new ConcurrentHashMap<>();
+
+    private final Set<String> seenIllegalAccess = Collections.newSetFromMap(new ConcurrentHashMap<>());
+    private final Logger logger;
+
+    static {
+        registerAsParallelCapable();
+    }
+
+    public PaperPluginClassLoader(Logger logger, Path source, JarFile file, PluginConfiguration configuration, ClassLoader parentLoader, ClassLoader libraryLoader) throws IOException {
+        super(source, file, configuration, parentLoader);
+        this.loader = PaperPluginClassLoaderStorage.INSTANCE;
+        this.libraryLoader = libraryLoader;
+
+        this.logger = logger;
+    }
+
+    @Override
+    public URL getResource(String name) {
+        return this.findResource(name);
+    }
+
+    @Override
+    public Enumeration<URL> getResources(String name) throws IOException {
+        return this.findResources(name);
+    }
+
+    @Override
+    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
+        return this.loadClass(name, resolve, true, true);
+    }
+
+    @Override
+    public PluginConfiguration getConfiguration() {
+        return this.configuration;
+    }
+
+    // TODO: ((SimplePluginManager) server.getPluginManager()).isTransitiveDepend(description, requester.getDescription())
+    @Override
+    public Class<?> loadClass(@NotNull String name, boolean resolve, boolean checkGlobal, boolean checkLibraries) throws ClassNotFoundException {
+        try {
+            Class<?> result = super.loadClass(name, resolve);
+
+            // SPIGOT-6749: Library classes will appear in the above, but we don't want to return them to other plugins
+            if (checkGlobal || result.getClassLoader() == this) {
+                return result;
+            }
+        } catch (ClassNotFoundException ex) {
+        }
+
+        if (checkLibraries) {
+            try {
+                return this.libraryLoader.loadClass(name);
+            } catch (ClassNotFoundException ex) {
+            }
+        }
+
+        if (checkGlobal) {
+            // This ignores the libraries of other plugins, unless they are transitive dependencies.
+            Class<?> result = this.loader.getClassByName(name, resolve, this.configuration, this);  // Paper - prioritize self
+
+            if (result != null) {
+                // If the class was loaded from a library instead of a PluginClassLoader, we can assume that its associated plugin is a transitive dependency and can therefore skip this check.
+                if (result.getClassLoader() instanceof PaperPluginClassLoader existingClassLoader) {
+                    PluginConfiguration classLoaderConfig = existingClassLoader.configuration;
+
+                    String identifier = classLoaderConfig.getIdentifier();
+                    if (classLoaderConfig != this.configuration && !this.seenIllegalAccess.contains(identifier) && !this.configuration.isTransitiveDependency(classLoaderConfig)) {
+                        this.seenIllegalAccess.add(identifier);
+                        if (this.logger != null) {
+                            this.logger.warning("Loaded class '%s' from '%s' which is not a depend or softdepend of this plugin.".formatted(name, classLoaderConfig.getDisplayName()));
+                        }
+                    }
+                }
+
+                return result;
+            }
+        }
+
+        throw new ClassNotFoundException(name);
+    }
+
+    @Override
+    public void init(JavaPlugin plugin) {
+        PluginLoader pluginLoader = ((SimplePluginManager) Bukkit.getPluginManager()).loader;
+        PluginConfiguration config = this.configuration;
+        PluginDescriptionFile pluginDescriptionFile = new PluginDescriptionFile(
+            config.getIdentifier(),
+            config.getDisplayName(),
+            config.getProvides(),
+            config.getMain(),
+            "", // Classloader load order api
+            config.getHardDependencies(),
+            config.getSoftDependencies(),
+            config.getLoadBefore(),
+            config.getVersion(),
+            Map.of(), // Commands, we use a separate system
+            config.getDescription(),
+            config.getAuthors(),
+            config.getContributors(),
+            config.getWebsite(),
+            config.getLoggingPrefix(),
+            config.getLoadPhase(),
+            config.getPermissions(),
+            config.getDefaultPermission(),
+            Set.of(), // Aware api
+            config.getApiVersion(),
+            List.of() // Libraries
+        );
+
+        File dataFolder = new File(Bukkit.getPluginsFolder(), pluginDescriptionFile.getName());
+        PaperPluginClassLoaderStorage.INSTANCE.add(this);
+        plugin.init(pluginLoader, Bukkit.getServer(), pluginDescriptionFile, dataFolder, this.source.toFile(), this, config);
+        plugin.logger = this.logger; // Paper - set logger
+    }
+
+    @Override
+    protected Class<?> findClass(String name) throws ClassNotFoundException {
+        Class<?> clazz = super.findClass(name);
+        this.setClass(clazz);
+
+        return clazz;
+    }
+
+    @Override
+    public void close() throws IOException {
+        for (Class<?> clazz : this.loadedClasses.values()) {
+            this.removeClass(clazz);
+        }
+
+        super.close();
+    }
+
+    // TODO: are we supporting this cringe?
+    private void setClass(@NotNull final Class<?> clazz) {
+        if (ConfigurationSerializable.class.isAssignableFrom(clazz)) {
+            Class<? extends ConfigurationSerializable> serializable = clazz.asSubclass(ConfigurationSerializable.class);
+            ConfigurationSerialization.registerClass(serializable);
+        }
+    }
+
+    private void removeClass(@NotNull Class<?> clazz) {
+        if (ConfigurationSerializable.class.isAssignableFrom(clazz)) {
+            Class<? extends ConfigurationSerializable> serializable = clazz.asSubclass(ConfigurationSerializable.class);
+            ConfigurationSerialization.unregisterClass(serializable);
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "PaperPluginClassLoader{" +
+            "loader=" + this.loader +
+            ", libraryLoader=" + this.libraryLoader +
+            ", loadedClasses=" + this.loadedClasses +
+            ", seenIllegalAccess=" + this.seenIllegalAccess +
+            ", configuration=" + this.configuration +
+            ", source=" + this.source +
+            ", jarManifest=" + this.jarManifest +
+            ", jarUrl=" + this.jarUrl +
+            ", jar=" + this.jar +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperSimplePluginClassLoader.java b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperSimplePluginClassLoader.java
new file mode 100644
index 0000000000000000000000000000000000000000..fb470d0956c8c5b94d8aa868357f59fcdcb835ed
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PaperSimplePluginClassLoader.java
@@ -0,0 +1,120 @@
+package io.papermc.paper.plugin.provider.service.classloader;
+
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import io.papermc.paper.plugin.provider.service.classloader.bytecode.ClassloaderBytecodeModifier;
+import io.papermc.paper.plugin.provider.util.NamespaceChecker;
+import org.jetbrains.annotations.ApiStatus;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Path;
+import java.security.CodeSigner;
+import java.security.CodeSource;
+import java.util.Enumeration;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+import java.util.jar.Manifest;
+
+/**
+ * Simple classloader used for plugin loaders.
+ * Supports bytecode manipulation
+ */
+@ApiStatus.Internal
+public class PaperSimplePluginClassLoader extends URLClassLoader {
+
+    protected final PluginConfiguration configuration;
+
+    protected final Path source;
+
+    protected final Manifest jarManifest;
+    protected final URL jarUrl;
+
+    protected final JarFile jar;
+
+    static {
+        ClassLoader.registerAsParallelCapable();
+    }
+
+    public PaperSimplePluginClassLoader(Path source, JarFile file, PluginConfiguration configuration, ClassLoader parentLoader) throws IOException {
+        super(source.getFileName().toString(), new URL[]{source.toUri().toURL()}, parentLoader);
+
+        this.source = source;
+        this.jarManifest = file.getManifest();
+        this.jarUrl = source.toUri().toURL();
+        this.configuration = configuration;
+        this.jar = file;
+    }
+
+    @Override
+    public URL getResource(String name) {
+        return this.findResource(name);
+    }
+
+    @Override
+    public Enumeration<URL> getResources(String name) throws IOException {
+        return this.findResources(name);
+    }
+
+    // Bytecode modification supported loader
+    protected Class<?> findClass(String name) throws ClassNotFoundException {
+        NamespaceChecker.validateNameSpaceForClassloading(name);
+
+        // See UrlClassLoader#findClass(String)
+        String path = name.replace('.', '/').concat(".class");
+        JarEntry entry = this.jar.getJarEntry(path);
+        if (entry == null) {
+            throw new ClassNotFoundException();
+        }
+
+        // See URLClassLoader#defineClass(String, Resource)
+        byte[] classBytes;
+
+        try (InputStream is = this.jar.getInputStream(entry)) {
+            classBytes = is.readAllBytes();
+        } catch (IOException ex) {
+            throw new ClassNotFoundException(name, ex);
+        }
+
+        classBytes = ClassloaderBytecodeModifier.INSTANCE.modify(this.configuration, classBytes);
+
+        int dot = name.lastIndexOf('.');
+        if (dot != -1) {
+            String pkgName = name.substring(0, dot);
+            // Get defined package does not correctly handle sealed packages.
+            if (this.getDefinedPackage(pkgName) == null) {
+                try {
+                    if (this.jarManifest != null) {
+                        this.definePackage(pkgName, this.jarManifest, this.jarUrl);
+                    } else {
+                        this.definePackage(pkgName, null, null, null, null, null, null, null);
+                    }
+                } catch (IllegalArgumentException ex) {
+                    // parallel-capable class loaders: re-verify in case of a
+                    // race condition
+                    if (this.getDefinedPackage(pkgName) == null) {
+                        // Should never happen
+                        throw new IllegalStateException("Cannot find package " + pkgName);
+                    }
+                }
+            }
+        }
+
+        CodeSigner[] signers = entry.getCodeSigners();
+        CodeSource source = new CodeSource(this.jarUrl, signers);
+
+        return this.defineClass(name, classBytes, 0, classBytes.length, source);
+    }
+
+    @Override
+    public String toString() {
+        return "PaperSimplePluginClassLoader{" +
+            "configuration=" + this.configuration +
+            ", source=" + this.source +
+            ", jarManifest=" + this.jarManifest +
+            ", jarUrl=" + this.jarUrl +
+            ", jar=" +this. jar +
+            '}';
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PluginClassloader.java b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PluginClassloader.java
new file mode 100644
index 0000000000000000000000000000000000000000..f059030ab0fc2dc2327b5d1f874c7a098ab6b30e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/classloader/PluginClassloader.java
@@ -0,0 +1,7 @@
+package io.papermc.paper.plugin.provider.service.classloader;
+
+import org.jetbrains.annotations.ApiStatus;
+
+@ApiStatus.Internal
+public interface PluginClassloader {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/storage/PreInitProviderStorage.java b/src/main/java/io/papermc/paper/plugin/provider/service/storage/PreInitProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..f017c6d86178bec6cad016892b07ade2dd264edb
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/storage/PreInitProviderStorage.java
@@ -0,0 +1,32 @@
+package io.papermc.paper.plugin.provider.service.storage;
+
+import io.papermc.paper.plugin.bootstrap.PluginBootstrap;
+import io.papermc.paper.plugin.bootstrap.PluginBootstrapContext;
+import io.papermc.paper.plugin.bootstrap.PluginBootstrapContextImpl;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.ProviderStatus;
+import io.papermc.paper.plugin.provider.ProviderStatusHolder;
+
+import java.nio.file.Path;
+import java.util.logging.Level;
+
+public class PreInitProviderStorage extends SimpleProviderStorage<PluginBootstrap> {
+
+    public static final PreInitProviderStorage INSTANCE = new PreInitProviderStorage();
+
+
+    public void init(Path pluginFolder) {
+        for (PluginProvider<PluginBootstrap> provider : this.providers) {
+            try {
+                PluginBootstrapContext context = PluginBootstrapContextImpl.of(provider, pluginFolder);
+                PluginBootstrap bootstrap = provider.createInstance();
+                bootstrap.boostrap(context);
+            } catch (Exception e) {
+                provider.getLogger().log(Level.SEVERE, "Failed to run initializer for %s in %s. This plugin will not be loaded.".formatted(provider.getFileName(), provider.getParentSource()), e);
+                if (provider instanceof ProviderStatusHolder statusHolder) {
+                    statusHolder.setStatus(ProviderStatus.ERRORED);
+                }
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/storage/ProviderStorage.java b/src/main/java/io/papermc/paper/plugin/provider/service/storage/ProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..a629439a956bf046f3bddfcabb85c4ebc21c903f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/storage/ProviderStorage.java
@@ -0,0 +1,16 @@
+package io.papermc.paper.plugin.provider.service.storage;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+import org.jetbrains.annotations.ApiStatus;
+
+/**
+ * A provider storage is meant to be a singleton that stores providers.
+ * @param <T> provider type
+ */
+public interface ProviderStorage<T> {
+
+    void register(PluginProvider<T> provider);
+
+    Iterable<PluginProvider<T>> getRegisteredProviders();
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/storage/SimpleProviderStorage.java b/src/main/java/io/papermc/paper/plugin/provider/service/storage/SimpleProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..77e048d9292fe3b1b207504bac6fb9420cbef4a6
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/storage/SimpleProviderStorage.java
@@ -0,0 +1,25 @@
+package io.papermc.paper.plugin.provider.service.storage;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public abstract class SimpleProviderStorage<T> implements ProviderStorage<T> {
+
+    protected final List<PluginProvider<T>> providers = new ArrayList<>();
+
+    @Override
+    public void register(PluginProvider<T> provider) {
+        this.providers.add(provider);
+    }
+
+    public List<PluginProvider<T>> registered() {
+        return this.providers;
+    }
+
+    @Override
+    public Iterable<PluginProvider<T>> getRegisteredProviders() {
+        return this.providers;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/ServerPluginProviderStorage.java b/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/ServerPluginProviderStorage.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b5c5667a3c733f04bff35466ea24af097de810f
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/ServerPluginProviderStorage.java
@@ -0,0 +1,76 @@
+package io.papermc.paper.plugin.provider.service.storage.plugin;
+
+import io.papermc.paper.configuration.GlobalConfiguration;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.configuration.PaperPluginConfiguration;
+import io.papermc.paper.plugin.provider.configuration.type.PaperCommand;
+import io.papermc.paper.plugin.provider.configuration.type.PaperCommandMap;
+import io.papermc.paper.plugin.provider.service.storage.SimpleProviderStorage;
+import io.papermc.paper.plugin.provider.service.storage.plugin.strategy.PluginLoadingStrategy;
+import io.papermc.paper.plugin.provider.service.storage.plugin.strategy.impl.legacy.LegacyPluginLoadingStrategy;
+import io.papermc.paper.plugin.provider.service.storage.plugin.strategy.impl.modern.ModernPluginLoadingStrategy;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginProvider;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.command.PluginCommand;
+import org.bukkit.plugin.SimplePluginManager;
+import org.bukkit.plugin.java.JavaPlugin;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+public class ServerPluginProviderStorage extends SimpleProviderStorage<JavaPlugin> {
+
+    public static final ServerPluginProviderStorage INSTANCE = new ServerPluginProviderStorage();
+
+    public void loadAll() {
+        PluginLoadingStrategy strategy = switch (GlobalConfiguration.get().misc.pluginLoadingStrategy) {
+            case MODERN -> ModernPluginLoadingStrategy.INSTANCE;
+            case LEGACY -> LegacyPluginLoadingStrategy.INSTANCE;
+        };
+
+        List<PluginProvider<JavaPlugin>> providerList = new ArrayList<>(this.providers);
+        /*
+        Have to do this to prevent loading plugin providers that have failed initializers.
+        This is a hack and a better solution here would be to store failed plugin providers elsewhere.
+         */
+        providerList.removeIf((provider) -> (provider instanceof PaperPluginProvider.PaperServerPluginProvider pluginProvider && pluginProvider.shouldSkipCreation()));
+
+        // Load paper plugin commands after they are loaded
+        // We have to use our own separate process
+        for (JavaPlugin plugin : strategy.loadPlugins(providerList)) {
+            if (plugin.getConfiguration() instanceof PaperPluginConfiguration paperPluginConfiguration) {
+                PaperCommandMap commandMap = paperPluginConfiguration.getCommandMap();
+
+                for (Map.Entry<String, PaperCommand> entry : commandMap.getCommands().entrySet()) {
+                    Command newCmd = new PluginCommand(entry.getKey(), plugin);
+
+                    PaperCommand command = entry.getValue();
+
+                    String description = command.description();
+                    if (description != null) {
+                        newCmd.setDescription(description);
+                    }
+                    String usage = command.usage();
+                    if (usage != null) {
+                        newCmd.setUsage(usage);
+                    }
+                    String permission = command.permission();
+                    if (permission != null) {
+                        newCmd.setPermission(permission);
+                    }
+
+                    newCmd.setAliases(command.aliases());
+                    newCmd.permissionMessage(command.permissionMessage());
+
+                    Bukkit.getCommandMap().register(paperPluginConfiguration.getIdentifier(), newCmd);
+                }
+            }
+
+
+            ((SimplePluginManager) Bukkit.getPluginManager()).loadPlugin(plugin);
+        }
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/PluginLoadingStrategy.java b/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/PluginLoadingStrategy.java
new file mode 100644
index 0000000000000000000000000000000000000000..37d3f39300361c2df890109d80bba475232b6383
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/PluginLoadingStrategy.java
@@ -0,0 +1,11 @@
+package io.papermc.paper.plugin.provider.service.storage.plugin.strategy;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+import org.bukkit.plugin.java.JavaPlugin;
+
+import java.util.List;
+
+public interface PluginLoadingStrategy {
+
+    List<JavaPlugin> loadPlugins(List<PluginProvider<JavaPlugin>> plugins);
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/legacy/LegacyPluginLoadingStrategy.java b/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/legacy/LegacyPluginLoadingStrategy.java
new file mode 100644
index 0000000000000000000000000000000000000000..6d744c007455ef1630a92837b845e8d5da789a38
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/legacy/LegacyPluginLoadingStrategy.java
@@ -0,0 +1,253 @@
+package io.papermc.paper.plugin.provider.service.storage.plugin.strategy.impl.legacy;
+
+import com.google.common.graph.GraphBuilder;
+import com.google.common.graph.MutableGraph;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import io.papermc.paper.plugin.provider.service.storage.plugin.strategy.PluginLoadingStrategy;
+import org.bukkit.plugin.UnknownDependencyException;
+import org.bukkit.plugin.java.JavaPlugin;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class LegacyPluginLoadingStrategy implements PluginLoadingStrategy {
+
+    private static final Logger LOGGER = Logger.getLogger("LegacyPluginLoadingStrategy");
+    public static final LegacyPluginLoadingStrategy INSTANCE = new LegacyPluginLoadingStrategy();
+
+    @Override
+    public List<JavaPlugin> loadPlugins(List<PluginProvider<JavaPlugin>> providers) {
+        List<JavaPlugin> javapluginsLoaded = new ArrayList<>();
+        MutableGraph<String> dependencyGraph = GraphBuilder.directed().build();
+
+        Map<String, PluginProvider<JavaPlugin>> providersToLoad = new HashMap<>();
+        Set<String> loadedPlugins = new HashSet<>();
+        Map<String, String> pluginsProvided = new HashMap<>();
+        Map<String, Collection<String>> dependencies = new HashMap<>();
+        Map<String, Collection<String>> softDependencies = new HashMap<>();
+
+        for (PluginProvider<JavaPlugin> provider : providers) {
+            PluginConfiguration configuration = provider.getConfiguration();
+
+            PluginProvider<JavaPlugin> replacedProvider = providersToLoad.put(configuration.getIdentifier(), provider);
+            if (replacedProvider != null) {
+                LOGGER.severe(String.format(
+                    "Ambiguous plugin name `%s' for files `%s' and `%s' in `%s'",
+                    configuration.getIdentifier(),
+                    provider.getSource(),
+                    replacedProvider.getSource(),
+                    replacedProvider.getParentSource()
+                ));
+            }
+
+            String removedProvided = pluginsProvided.remove(configuration.getIdentifier());
+            if (removedProvided != null) {
+                LOGGER.warning(String.format(
+                    "Ambiguous plugin name `%s'. It is also provided by `%s'",
+                    configuration.getIdentifier(),
+                    removedProvided
+                ));
+            }
+
+            for (String provided : configuration.getProvides()) {
+                PluginProvider<JavaPlugin> pluginProvider = providersToLoad.get(provided);
+
+                if (pluginProvider != null) {
+                    LOGGER.warning(String.format(
+                        "`%s provides `%s' while this is also the name of `%s' in `%s'",
+                        provider.getSource(),
+                        provided,
+                        pluginProvider.getSource(),
+                        provider.getParentSource()
+                    ));
+                } else {
+                    String replacedPlugin = pluginsProvided.put(provided, configuration.getIdentifier());
+                    if (replacedPlugin != null) {
+                        LOGGER.warning(String.format(
+                            "`%s' is provided by both `%s' and `%s'",
+                            provided,
+                            configuration.getIdentifier(),
+                            replacedPlugin
+                        ));
+                    }
+                }
+            }
+
+            Collection<String> softDependencySet = configuration.getSoftDependencies();
+            if (softDependencySet != null && !softDependencySet.isEmpty()) {
+                if (softDependencies.containsKey(configuration.getIdentifier())) {
+                    // Duplicates do not matter, they will be removed together if applicable
+                    softDependencies.get(configuration.getIdentifier()).addAll(softDependencySet);
+                } else {
+                    softDependencies.put(configuration.getIdentifier(), new LinkedList<String>(softDependencySet));
+                }
+
+                for (String depend : softDependencySet) {
+                    dependencyGraph.putEdge(configuration.getIdentifier(), depend);
+                }
+            }
+
+            Collection<String> dependencySet = configuration.getHardDependencies();
+            if (dependencySet != null && !dependencySet.isEmpty()) {
+                dependencies.put(configuration.getIdentifier(), new LinkedList<String>(dependencySet));
+
+                for (String depend : dependencySet) {
+                    dependencyGraph.putEdge(configuration.getIdentifier(), depend);
+                }
+            }
+
+            Collection<String> loadBeforeSet = configuration.getLoadBefore();
+            if (loadBeforeSet != null && !loadBeforeSet.isEmpty()) {
+                for (String loadBeforeTarget : loadBeforeSet) {
+                    if (softDependencies.containsKey(loadBeforeTarget)) {
+                        softDependencies.get(loadBeforeTarget).add(configuration.getIdentifier());
+                    } else {
+                        // softDependencies is never iterated, so 'ghost' plugins aren't an issue
+                        Collection<String> shortSoftDependency = new LinkedList<String>();
+                        shortSoftDependency.add(configuration.getIdentifier());
+                        softDependencies.put(loadBeforeTarget, shortSoftDependency);
+                    }
+
+                    dependencyGraph.putEdge(loadBeforeTarget, configuration.getIdentifier());
+                }
+            }
+        }
+
+        while (!providersToLoad.isEmpty()) {
+            boolean missingDependency = true;
+            Iterator<Map.Entry<String, PluginProvider<JavaPlugin>>> providerIterator = providersToLoad.entrySet().iterator();
+
+            while (providerIterator.hasNext()) {
+                Map.Entry<String, PluginProvider<JavaPlugin>> entry = providerIterator.next();
+                String providerIdentifier = entry.getKey();
+
+                if (dependencies.containsKey(providerIdentifier)) {
+                    Iterator<String> dependencyIterator = dependencies.get(providerIdentifier).iterator();
+                    final Set<String> missingHardDependencies = new HashSet<>(dependencies.get(providerIdentifier).size()); // Paper - list all missing hard depends
+
+                    while (dependencyIterator.hasNext()) {
+                        String dependency = dependencyIterator.next();
+
+                        // Dependency loaded
+                        if (loadedPlugins.contains(dependency)) {
+                            dependencyIterator.remove();
+
+                            // We have a dependency not found
+                        } else if (!providersToLoad.containsKey(dependency) && !pluginsProvided.containsKey(dependency)) {
+                            // Paper start
+                            missingHardDependencies.add(dependency);
+                        }
+                    }
+                    if (!missingHardDependencies.isEmpty()) {
+                        // Paper end
+                        missingDependency = false;
+                        providerIterator.remove();
+                        pluginsProvided.values().removeIf(s -> s.equals(providerIdentifier)); // Paper - remove provided plugins
+                        softDependencies.remove(providerIdentifier);
+                        dependencies.remove(providerIdentifier);
+
+                        LOGGER.log(
+                            Level.SEVERE,
+                            "Could not load '" + entry.getValue().getSource() + "' in folder '" + entry.getValue().getParentSource() + "'", // Paper
+                            new UnknownDependencyException(missingHardDependencies, providerIdentifier)); // Paper
+                    }
+
+                    if (dependencies.containsKey(providerIdentifier) && dependencies.get(providerIdentifier).isEmpty()) {
+                        dependencies.remove(providerIdentifier);
+                    }
+                }
+                if (softDependencies.containsKey(providerIdentifier)) {
+                    Iterator<String> softDependencyIterator = softDependencies.get(providerIdentifier).iterator();
+
+                    while (softDependencyIterator.hasNext()) {
+                        String softDependency = softDependencyIterator.next();
+
+                        // Soft depend is no longer around
+                        if (!providersToLoad.containsKey(softDependency) && !pluginsProvided.containsKey(softDependency)) {
+                            softDependencyIterator.remove();
+                        }
+                    }
+
+                    if (softDependencies.get(providerIdentifier).isEmpty()) {
+                        softDependencies.remove(providerIdentifier);
+                    }
+                }
+                if (!(dependencies.containsKey(providerIdentifier) || softDependencies.containsKey(providerIdentifier)) && providersToLoad.containsKey(providerIdentifier)) {
+                    // We're clear to load, no more soft or hard dependencies left
+                    PluginProvider<JavaPlugin> file = providersToLoad.get(providerIdentifier);
+                    providerIterator.remove();
+                    pluginsProvided.values().removeIf(s -> s.equals(providerIdentifier)); // Paper - remove provided plugins
+                    missingDependency = false;
+
+                    try {
+                        JavaPlugin loadedPlugin = file.createInstance();
+
+                        LOGGER.info(String.format("Loading server plugin %s", file.getConfiguration().getDisplayName()));
+                        loadedPlugins.add(loadedPlugin.getConfiguration().getIdentifier());
+                        loadedPlugins.addAll(loadedPlugin.getDescription().getProvides());
+                        loadedPlugin.onLoad();
+                        javapluginsLoaded.add(loadedPlugin);
+                        continue;
+                    } catch (Exception ex) {
+                        LOGGER.log(Level.SEVERE, "Could not load '" + file.getSource() + "' in folder '" + file.getParentSource() + "'", ex); // Paper
+                    }
+                }
+            }
+
+            if (missingDependency) {
+                // We now iterate over plugins until something loads
+                // This loop will ignore soft dependencies
+                providerIterator = providersToLoad.entrySet().iterator();
+
+                while (providerIterator.hasNext()) {
+                    Map.Entry<String, PluginProvider<JavaPlugin>> entry = providerIterator.next();
+                    String plugin = entry.getKey();
+
+                    if (!dependencies.containsKey(plugin)) {
+                        softDependencies.remove(plugin);
+                        missingDependency = false;
+                        PluginProvider<JavaPlugin> file = entry.getValue();
+                        providerIterator.remove();
+
+                        try {
+                            JavaPlugin loadedPlugin = file.createInstance();
+
+                            LOGGER.info(String.format("Loading server plugin %s", file.getConfiguration().getDisplayName()));
+                            loadedPlugins.add(loadedPlugin.getConfiguration().getIdentifier());
+                            loadedPlugins.addAll(loadedPlugin.getDescription().getProvides());
+                            loadedPlugin.onLoad();
+                            javapluginsLoaded.add(loadedPlugin);
+                            break;
+                        } catch (Exception ex) {
+                            LOGGER.log(Level.SEVERE, "Could not load '" + file.getSource() + "' in folder '" + file.getParentSource() + "'", ex); // Paper
+                        }
+                    }
+                }
+                // We have no plugins left without a depend
+                if (missingDependency) {
+                    softDependencies.clear();
+                    dependencies.clear();
+                    Iterator<PluginProvider<JavaPlugin>> failedPluginIterator = providersToLoad.values().iterator();
+
+                    while (failedPluginIterator.hasNext()) {
+                        PluginProvider<JavaPlugin> file = failedPluginIterator.next();
+                        failedPluginIterator.remove();
+                        LOGGER.log(Level.SEVERE, "Could not load '" + file.getSource() + "' in folder '" + file.getParentSource() + "': circular dependency detected"); // Paper
+                    }
+                }
+            }
+        }
+
+        return javapluginsLoaded;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/modern/GraphCycleException.java b/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/modern/GraphCycleException.java
new file mode 100644
index 0000000000000000000000000000000000000000..545652791ba1d3a2f7f0dc97d90f8c971d12d650
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/modern/GraphCycleException.java
@@ -0,0 +1,4 @@
+package io.papermc.paper.plugin.provider.service.storage.plugin.strategy.impl.modern;
+
+public class GraphCycleException extends Exception {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/modern/JohnsonSimpleCycles.java b/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/modern/JohnsonSimpleCycles.java
new file mode 100644
index 0000000000000000000000000000000000000000..847112105029a8ae96664ca8d6d1c73d61bb333c
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/modern/JohnsonSimpleCycles.java
@@ -0,0 +1,344 @@
+/*
+ * (C) Copyright 2013-2021, by Nikolay Ognyanov and Contributors.
+ *
+ * JGraphT : a free Java graph-theory library
+ *
+ * See the CONTRIBUTORS.md file distributed with this work for additional
+ * information regarding copyright ownership.
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0, or the
+ * GNU Lesser General Public License v2.1 or later
+ * which is available at
+ * http://www.gnu.org/licenses/old-licenses/lgpl-2.1-standalone.html.
+ *
+ * SPDX-License-Identifier: EPL-2.0 OR LGPL-2.1-or-later
+ */
+
+// MODIFICATIONS:
+// - Modified to use a guava graph directly
+
+package io.papermc.paper.plugin.provider.service.storage.plugin.strategy.impl.modern;
+
+import com.google.common.base.Preconditions;
+import com.google.common.graph.Graph;
+import com.google.common.graph.GraphBuilder;
+import com.google.common.graph.MutableGraph;
+import com.mojang.datafixers.util.Pair;
+
+import java.util.*;
+import java.util.function.Consumer;
+
+/**
+ * Find all simple cycles of a directed graph using the Johnson's algorithm.
+ *
+ * <p>
+ * See:<br>
+ * D.B.Johnson, Finding all the elementary circuits of a directed graph, SIAM J. Comput., 4 (1975),
+ * pp. 77-84.
+ *
+ * @param <V> the vertex type.
+ *
+ * @author Nikolay Ognyanov
+ */
+public class JohnsonSimpleCycles<V>
+{
+    // The graph.
+    private Graph<V> graph;
+
+    // The main state of the algorithm.
+    private Consumer<List<V>> cycleConsumer = null;
+    private V[] iToV = null;
+    private Map<V, Integer> vToI = null;
+    private Set<V> blocked = null;
+    private Map<V, Set<V>> bSets = null;
+    private ArrayDeque<V> stack = null;
+
+    // The state of the embedded Tarjan SCC algorithm.
+    private List<Set<V>> foundSCCs = null;
+    private int index = 0;
+    private Map<V, Integer> vIndex = null;
+    private Map<V, Integer> vLowlink = null;
+    private ArrayDeque<V> path = null;
+    private Set<V> pathSet = null;
+
+    /**
+     * Create a simple cycle finder for the specified graph.
+     *
+     * @param graph - the DirectedGraph in which to find cycles.
+     *
+     * @throws IllegalArgumentException if the graph argument is <code>
+     * null</code>.
+     */
+    public JohnsonSimpleCycles(Graph<V> graph)
+    {
+        Preconditions.checkState(graph.isDirected(), "Graph must be directed");
+        this.graph = graph;
+    }
+
+    /**
+     * Find the simple cycles of the graph.
+     *
+     * @return The list of all simple cycles. Possibly empty but never <code>null</code>.
+     */
+    public List<List<V>> findSimpleCycles()
+    {
+        List<List<V>> result = new ArrayList<>();
+        findSimpleCycles(result::add);
+        return result;
+    }
+
+    /**
+     * Find the simple cycles of the graph.
+     *
+     * @param consumer Consumer that will be called with each cycle found.
+     */
+    public void findSimpleCycles(Consumer<List<V>> consumer)
+    {
+        if (graph == null) {
+            throw new IllegalArgumentException("Null graph.");
+        }
+        initState(consumer);
+
+        int startIndex = 0;
+        int size = graph.nodes().size();
+        while (startIndex < size) {
+            Pair<Graph<V>, Integer> minSCCGResult = findMinSCSG(startIndex);
+            if (minSCCGResult != null) {
+                startIndex = minSCCGResult.getSecond();
+                Graph<V> scg = minSCCGResult.getFirst();
+                V startV = toV(startIndex);
+                for (V v : scg.successors(startV)) {
+                    blocked.remove(v);
+                    getBSet(v).clear();
+                }
+                findCyclesInSCG(startIndex, startIndex, scg);
+                startIndex++;
+            } else {
+                break;
+            }
+        }
+
+        clearState();
+    }
+
+    private Pair<Graph<V>, Integer> findMinSCSG(int startIndex)
+    {
+        /*
+         * Per Johnson : "adjacency structure of strong component $K$ with least vertex in subgraph
+         * of $G$ induced by $(s, s + 1, n)$". Or in contemporary terms: the strongly connected
+         * component of the subgraph induced by $(v_1, \dotso ,v_n)$ which contains the minimum
+         * (among those SCCs) vertex index. We return that index together with the graph.
+         */
+        initMinSCGState();
+
+        List<Set<V>> foundSCCs = findSCCS(startIndex);
+
+        // find the SCC with the minimum index
+        int minIndexFound = Integer.MAX_VALUE;
+        Set<V> minSCC = null;
+        for (Set<V> scc : foundSCCs) {
+            for (V v : scc) {
+                int t = toI(v);
+                if (t < minIndexFound) {
+                    minIndexFound = t;
+                    minSCC = scc;
+                }
+            }
+        }
+        if (minSCC == null) {
+            return null;
+        }
+
+        // build a graph for the SCC found
+        MutableGraph<V> dependencyGraph = GraphBuilder.directed().allowsSelfLoops(true).build();
+
+        for (V v : minSCC) {
+            for (V w : minSCC) {
+                if (graph.hasEdgeConnecting(v, w)) {
+                    dependencyGraph.putEdge(v, w);
+                }
+            }
+        }
+
+        Pair<Graph<V>, Integer> result = Pair.of(dependencyGraph, minIndexFound);
+        clearMinSCCState();
+        return result;
+    }
+
+    private List<Set<V>> findSCCS(int startIndex)
+    {
+        // Find SCCs in the subgraph induced
+        // by vertices startIndex and beyond.
+        // A call to StrongConnectivityAlgorithm
+        // would be too expensive because of the
+        // need to materialize the subgraph.
+        // So - do a local search by the Tarjan's
+        // algorithm and pretend that vertices
+        // with an index smaller than startIndex
+        // do not exist.
+        for (V v : graph.nodes()) {
+            int vI = toI(v);
+            if (vI < startIndex) {
+                continue;
+            }
+            if (!vIndex.containsKey(v)) {
+                getSCCs(startIndex, vI);
+            }
+        }
+        List<Set<V>> result = foundSCCs;
+        foundSCCs = null;
+        return result;
+    }
+
+    private void getSCCs(int startIndex, int vertexIndex)
+    {
+        V vertex = toV(vertexIndex);
+        vIndex.put(vertex, index);
+        vLowlink.put(vertex, index);
+        index++;
+        path.push(vertex);
+        pathSet.add(vertex);
+
+        Set<V> edges = graph.successors(vertex);
+        for (V successor : edges) {
+            int successorIndex = toI(successor);
+            if (successorIndex < startIndex) {
+                continue;
+            }
+            if (!vIndex.containsKey(successor)) {
+                getSCCs(startIndex, successorIndex);
+                vLowlink.put(vertex, Math.min(vLowlink.get(vertex), vLowlink.get(successor)));
+            } else if (pathSet.contains(successor)) {
+                vLowlink.put(vertex, Math.min(vLowlink.get(vertex), vIndex.get(successor)));
+            }
+        }
+        if (vLowlink.get(vertex).equals(vIndex.get(vertex))) {
+            Set<V> result = new HashSet<>();
+            V temp;
+            do {
+                temp = path.pop();
+                pathSet.remove(temp);
+                result.add(temp);
+            } while (!vertex.equals(temp));
+            if (result.size() == 1) {
+                V v = result.iterator().next();
+                if (graph.edges().contains(vertex)) {
+                    foundSCCs.add(result);
+                }
+            } else {
+                foundSCCs.add(result);
+            }
+        }
+    }
+
+    private boolean findCyclesInSCG(int startIndex, int vertexIndex, Graph<V> scg)
+    {
+        /*
+         * Find cycles in a strongly connected graph per Johnson.
+         */
+        boolean foundCycle = false;
+        V vertex = toV(vertexIndex);
+        stack.push(vertex);
+        blocked.add(vertex);
+
+        for (V successor : scg.successors(vertex)) {
+            int successorIndex = toI(successor);
+            if (successorIndex == startIndex) {
+                List<V> cycle = new ArrayList<>(stack.size());
+                stack.descendingIterator().forEachRemaining(cycle::add);
+                cycleConsumer.accept(cycle);
+                foundCycle = true;
+            } else if (!blocked.contains(successor)) {
+                boolean gotCycle = findCyclesInSCG(startIndex, successorIndex, scg);
+                foundCycle = foundCycle || gotCycle;
+            }
+        }
+        if (foundCycle) {
+            unblock(vertex);
+        } else {
+            for (V w : scg.successors(vertex)) {
+                Set<V> bSet = getBSet(w);
+                bSet.add(vertex);
+            }
+        }
+        stack.pop();
+        return foundCycle;
+    }
+
+    private void unblock(V vertex)
+    {
+        blocked.remove(vertex);
+        Set<V> bSet = getBSet(vertex);
+        while (bSet.size() > 0) {
+            V w = bSet.iterator().next();
+            bSet.remove(w);
+            if (blocked.contains(w)) {
+                unblock(w);
+            }
+        }
+    }
+
+    @SuppressWarnings("unchecked")
+    private void initState(Consumer<List<V>> consumer)
+    {
+        cycleConsumer = consumer;
+        iToV = (V[]) graph.nodes().toArray();
+        vToI = new HashMap<>();
+        blocked = new HashSet<>();
+        bSets = new HashMap<>();
+        stack = new ArrayDeque<>();
+
+        for (int i = 0; i < iToV.length; i++) {
+            vToI.put(iToV[i], i);
+        }
+    }
+
+    private void clearState()
+    {
+        cycleConsumer = null;
+        iToV = null;
+        vToI = null;
+        blocked = null;
+        bSets = null;
+        stack = null;
+    }
+
+    private void initMinSCGState()
+    {
+        index = 0;
+        foundSCCs = new ArrayList<>();
+        vIndex = new HashMap<>();
+        vLowlink = new HashMap<>();
+        path = new ArrayDeque<>();
+        pathSet = new HashSet<>();
+    }
+
+    private void clearMinSCCState()
+    {
+        index = 0;
+        foundSCCs = null;
+        vIndex = null;
+        vLowlink = null;
+        path = null;
+        pathSet = null;
+    }
+
+    private Integer toI(V vertex)
+    {
+        return vToI.get(vertex);
+    }
+
+    private V toV(Integer i)
+    {
+        return iToV[i];
+    }
+
+    private Set<V> getBSet(V v)
+    {
+        // B sets typically not all needed,
+        // so instantiate lazily.
+        return bSets.computeIfAbsent(v, k -> new HashSet<>());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/modern/ModernPluginLoadingStrategy.java b/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/modern/ModernPluginLoadingStrategy.java
new file mode 100644
index 0000000000000000000000000000000000000000..14d896e38f69f850027bfa662463fa510a3fe3fe
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/modern/ModernPluginLoadingStrategy.java
@@ -0,0 +1,139 @@
+package io.papermc.paper.plugin.provider.service.storage.plugin.strategy.impl.modern;
+
+import com.google.common.collect.Lists;
+import com.google.common.graph.GraphBuilder;
+import com.google.common.graph.MutableGraph;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import io.papermc.paper.plugin.provider.service.storage.plugin.strategy.PluginLoadingStrategy;
+import org.bukkit.plugin.UnknownDependencyException;
+import org.bukkit.plugin.java.JavaPlugin;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class ModernPluginLoadingStrategy implements PluginLoadingStrategy {
+
+    private static final Logger LOGGER = Logger.getLogger("ModernPluginLoadingStrategy");
+    public static final ModernPluginLoadingStrategy INSTANCE = new ModernPluginLoadingStrategy();
+
+    @Override
+    public List<JavaPlugin> loadPlugins(List<PluginProvider<JavaPlugin>> plugins) {
+        // Dependency validation
+        List<PluginProvider<JavaPlugin>> validatedProviders = new ArrayList<>();
+        Map<String, PluginProvider<JavaPlugin>> providerMap = new HashMap<>();
+        {
+            // Populate dependency set
+            for (PluginProvider<JavaPlugin> provider : plugins) {
+                PluginConfiguration providerConfig = provider.getConfiguration();
+
+                // Populate provided into a map
+                providerMap.put(providerConfig.getIdentifier(), provider);
+                for (String provides : providerConfig.getProvides()) {
+                    providerMap.put(provides, provider);
+                }
+            }
+
+            // Validate
+            for (PluginProvider<JavaPlugin> provider : plugins) {
+                PluginConfiguration providerConfiguration = provider.getConfiguration();
+
+                // Populate missing dependencies to capture if there are multiple missing ones.
+                List<String> missingDependencies = new ArrayList<>();
+                for (String hardDependency : providerConfiguration.getHardDependencies()) {
+                    if (!providerMap.containsKey(hardDependency)) {
+                        missingDependencies.add(hardDependency);
+                    }
+                }
+
+                if (missingDependencies.isEmpty()) {
+                    validatedProviders.add(provider);
+                } else {
+                    LOGGER.log(
+                        Level.SEVERE,
+                        "Could not load '%s' in '%s'".formatted(provider.getSource(), provider.getParentSource()),
+                        new UnknownDependencyException(missingDependencies, providerConfiguration.getIdentifier())); // Paper
+                }
+            }
+        }
+
+        MutableGraph<String> dependencyGraph = GraphBuilder.directed().build();
+        // Build dependency graph
+        // Build the dependencies inorder to generate a load order by topographically sorting the populated graph
+        for (PluginProvider<?> provider : validatedProviders) {
+            PluginConfiguration configuration = provider.getConfiguration();
+            String dependencyIdentifier = configuration.getIdentifier();
+
+            for (String dependency : configuration.getHardDependencies()) {
+                dependencyGraph.putEdge(dependencyIdentifier, dependency);
+            }
+
+            for (String loadBeforeTarget : configuration.getLoadBefore()) {
+                dependencyGraph.putEdge(loadBeforeTarget, dependencyIdentifier);
+            }
+
+            for (String dependency : configuration.getSoftDependencies()) {
+                dependencyGraph.putEdge(dependencyIdentifier, dependency);
+            }
+
+            dependencyGraph.addNode(dependencyIdentifier); // Make sure dependencies at least have a node
+        }
+
+        // Reverse the topographic search to let us see which providers we can load first.
+        List<String> reversedTopographicSort;
+        try {
+            reversedTopographicSort = Lists.reverse(TopographicGraphSorter.sortGraph(dependencyGraph));
+        } catch (GraphCycleException e) {
+            List<String> logMessages = new ArrayList<>();
+            for (List<String> list : new JohnsonSimpleCycles<>(dependencyGraph).findSimpleCycles()) {
+                // CoolPlugin depends on Dependency depends on CoolPlugin...
+                for (int i = 0; i < list.size(); i++) {
+                    String dependency = list.get(0);
+                    if (providerMap.containsKey(dependency)) {
+                        list.set(0, "[PLUGIN] " + dependency);
+                    }
+
+                }
+                logMessages.add(String.join(" depends on ", list) + " depends on " + list.get(0) + "...");
+            }
+
+            LOGGER.log(Level.SEVERE, "Circular dependencies detected!");
+            LOGGER.log(Level.SEVERE, "You have a plugin that is depending on a plugin which refers back to that plugin. Your server will shut down until these are resolved, or the strategy is changed.");
+            LOGGER.log(Level.SEVERE, "Circular dependencies:");
+            for (String message : logMessages) {
+                LOGGER.log(Level.SEVERE, message);
+            }
+            LOGGER.log(Level.SEVERE, "If you would like to still load these plugins, acknowledging that there may be unexpected plugin loading issues, change plugin-loading-strategy in paper-global.yml to LEGACY.");
+
+            System.exit(-1);
+            return List.of();
+        }
+
+        List<JavaPlugin> loadedPlugins = new ArrayList<>();
+        System.out.println(reversedTopographicSort);
+        for (String providerIdentifier : reversedTopographicSort) {
+            // It's possible that this will be null because the above dependencies for soft/load before aren't validated if they exist.
+            // The graph could be MutableGraph<PluginProvider<JavaPlugin>>, but we would have to check if each dependency exists there... just
+            // nicer to do it here TBH.
+            PluginProvider<JavaPlugin> retrievedProvider = providerMap.get(providerIdentifier);
+            if (retrievedProvider == null) {
+                continue; // Skip provider that doesn't exist....
+            }
+
+            try {
+                JavaPlugin plugin = retrievedProvider.createInstance();
+                plugin.getLogger().info(String.format("Loading server plugin %s", plugin.getConfiguration().getDisplayName()));
+                plugin.onLoad();
+                loadedPlugins.add(plugin);
+            } catch (Throwable ex) {
+                LOGGER.log(Level.WARNING, "Could not load server plugin '%s' in folder '%s' (Is it up to date?)".formatted(retrievedProvider.getFileName(), retrievedProvider.getParentSource()), ex);
+            }
+        }
+
+        return loadedPlugins;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/modern/TopographicGraphSorter.java b/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/modern/TopographicGraphSorter.java
new file mode 100644
index 0000000000000000000000000000000000000000..a586cfee69a2ddfb67dc98b72fe8fb12ce87386e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/service/storage/plugin/strategy/impl/modern/TopographicGraphSorter.java
@@ -0,0 +1,57 @@
+package io.papermc.paper.plugin.provider.service.storage.plugin.strategy.impl.modern;
+
+import com.google.common.graph.Graph;
+
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class TopographicGraphSorter {
+
+    // Topographically sort dependencies
+    public static <N> List<N> sortGraph(Graph<N> graph) throws GraphCycleException {
+        List<N> sorted = new ArrayList<>();
+        Deque<N> roots = new ArrayDeque<>();
+        Map<N, Integer> nonRoots = new HashMap<>();
+
+        for (N node : graph.nodes()) {
+            // Is a node being referred to by any other nodes?
+            int degree = graph.inDegree(node);
+            if (degree == 0) {
+                // Is a root
+                roots.add(node);
+            } else {
+                // Isn't a root, the number represents how many nodes connect to it.
+                nonRoots.put(node, degree);
+            }
+        }
+
+        // Pick from nodes that aren't referred to anywhere else
+        while (!roots.isEmpty()) {
+            N next = roots.remove();
+
+            for (N successor : graph.successors(next)) {
+                // Traverse through, moving down a degree
+                int newInDegree = nonRoots.get(successor) - 1;
+
+                if (newInDegree == 0) {
+                    nonRoots.remove(successor);
+                    roots.add(successor);
+                } else {
+                    nonRoots.put(successor, newInDegree);
+                }
+
+            }
+            sorted.add(next);
+        }
+
+        if (!nonRoots.isEmpty()) {
+            throw new GraphCycleException();
+        }
+
+        return sorted;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/ProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/ProviderSource.java
new file mode 100644
index 0000000000000000000000000000000000000000..d8e800ca1823f83bfea061487b9c2cfb6f4e263b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/ProviderSource.java
@@ -0,0 +1,6 @@
+package io.papermc.paper.plugin.provider.source;
+
+public interface ProviderSource<C> {
+
+    void registerProviders(C context) throws Throwable;
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/Providers.java b/src/main/java/io/papermc/paper/plugin/provider/source/Providers.java
new file mode 100644
index 0000000000000000000000000000000000000000..50517236e785db42de550393fd7b32531296bb43
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/Providers.java
@@ -0,0 +1,22 @@
+package io.papermc.paper.plugin.provider.source;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/*
+A simple class for handling the registration of plugin providers.
+ */
+public class Providers {
+
+    private static final Logger LOGGER = Logger.getLogger("PluginLoading"); // Name for easier understanding
+    public static final Providers INSTANCE = new Providers();
+
+    public <C> void addProviders(ProviderSource<C> source, C context) {
+        try {
+            source.registerProviders(context);
+        } catch (Throwable e) {
+            LOGGER.log(Level.SEVERE, e.getMessage(), e);
+        }
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/impl/DirectoryProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/impl/DirectoryProviderSource.java
new file mode 100644
index 0000000000000000000000000000000000000000..51137b8c02b3f4e744efd03587b3a43ac31dc397
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/impl/DirectoryProviderSource.java
@@ -0,0 +1,34 @@
+package io.papermc.paper.plugin.provider.source.impl;
+
+import io.papermc.paper.plugin.provider.source.ProviderSource;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class DirectoryProviderSource implements ProviderSource<Path> {
+
+    private static final Logger LOGGER = Logger.getLogger("DirectoryProviderSource");
+    public static final DirectoryProviderSource INSTANCE = new DirectoryProviderSource();
+
+    private final FileProviderSource providerSource = new FileProviderSource(false);
+
+    @Override
+    public void registerProviders(Path context) throws Exception {
+        // Sym link happy, create file if missing.
+        if (!Files.isDirectory(context)) {
+            Files.createDirectories(context);
+        }
+
+        Files.walk(context, 1).filter(Files::isRegularFile).forEach((path) -> {
+            try {
+                this.providerSource.registerProviders(path);
+            } catch (IllegalArgumentException ignored) {
+                // Ignore initial argument exceptions
+            } catch (Exception e) {
+                LOGGER.log(Level.SEVERE, "Error loading plugin: " + e.getMessage(), e);
+            }
+        });
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/impl/FileProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/impl/FileProviderSource.java
new file mode 100644
index 0000000000000000000000000000000000000000..cef457e2d92905c9abbea473d341e5855febdae8
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/impl/FileProviderSource.java
@@ -0,0 +1,47 @@
+package io.papermc.paper.plugin.provider.source.impl;
+
+import io.papermc.paper.plugin.provider.source.ProviderSource;
+import io.papermc.paper.plugin.provider.type.PluginFileType;
+
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.jar.JarFile;
+
+public class FileProviderSource implements ProviderSource<Path> {
+
+    private final boolean addPluginProvider;
+
+    public FileProviderSource(boolean addPluginProvider) {
+        this.addPluginProvider = addPluginProvider;
+    }
+
+    @Override
+    public void registerProviders(Path context) throws Exception {
+        String source = this.addPluginProvider ? "File '%s' specified through 'add-plugin' argument" : "File '%s'";
+        source = source.formatted(context);
+
+        if (Files.notExists(context)) {
+            throw new IllegalArgumentException(source + " does not exist, cannot load a plugin from it!");
+        }
+
+        if (!Files.isRegularFile(context)) {
+            throw new IllegalArgumentException(source + " is not a file, cannot load a plugin from it!");
+        }
+
+        if (!context.getFileName().toString().endsWith(".jar")) {
+            throw new IllegalArgumentException(source + " is not a jar file, cannot load a plugin from it!");
+        }
+
+        try {
+            JarFile file = new JarFile(context.toFile());
+            PluginFileType<?> type = PluginFileType.guessType(file);
+            if (type == null) {
+                throw new IllegalArgumentException(source + " is not a valid plugin file, cannot load a plugin from it!");
+            }
+
+            type.register(file, context);
+        } catch (Exception exception) {
+            throw new RuntimeException(source + " failed to load!", exception);
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/source/impl/PluginFlagProviderSource.java b/src/main/java/io/papermc/paper/plugin/provider/source/impl/PluginFlagProviderSource.java
new file mode 100644
index 0000000000000000000000000000000000000000..41686a0985e03e0177400ee646604b195d32d657
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/source/impl/PluginFlagProviderSource.java
@@ -0,0 +1,27 @@
+package io.papermc.paper.plugin.provider.source.impl;
+
+import io.papermc.paper.plugin.provider.source.ProviderSource;
+
+import java.io.File;
+import java.util.List;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class PluginFlagProviderSource implements ProviderSource<List<File>> {
+
+    private static final Logger LOGGER = Logger.getLogger("PluginFlagProviderSource");
+    public static final PluginFlagProviderSource INSTANCE = new PluginFlagProviderSource();
+
+    private final FileProviderSource providerSource = new FileProviderSource(true);
+
+    @Override
+    public void registerProviders(List<File> context) throws Throwable {
+        for (File file : context) {
+            try {
+                this.providerSource.registerProviders(file.toPath());
+            } catch (Exception e) {
+                LOGGER.log(Level.SEVERE, "Error loading plugin: " + e.getMessage(), e);
+            }
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/JavaPluginProvider.java b/src/main/java/io/papermc/paper/plugin/provider/type/JavaPluginProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..c7b16e25a140e51ef4dfbba3d036acf68dfb88b5
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/JavaPluginProvider.java
@@ -0,0 +1,7 @@
+package io.papermc.paper.plugin.provider.type;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+import org.bukkit.plugin.java.JavaPlugin;
+
+public abstract class JavaPluginProvider implements PluginProvider<JavaPlugin> {
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/PluginFileType.java b/src/main/java/io/papermc/paper/plugin/provider/type/PluginFileType.java
new file mode 100644
index 0000000000000000000000000000000000000000..9c7df4d6301b461e18d397b7e290c304b38cb422
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/PluginFileType.java
@@ -0,0 +1,66 @@
+package io.papermc.paper.plugin.provider.type;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.service.storage.PreInitProviderStorage;
+import io.papermc.paper.plugin.provider.service.storage.plugin.ServerPluginProviderStorage;
+import io.papermc.paper.plugin.provider.type.paper.PaperPluginProvider;
+import io.papermc.paper.plugin.provider.type.paper.PaperParentProvider;
+import io.papermc.paper.plugin.provider.type.spigot.SpigotPluginProvider;
+import org.jetbrains.annotations.Nullable;
+
+import java.nio.file.Path;
+import java.util.List;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+
+public abstract class PluginFileType<T extends PluginProvider<?>> {
+
+    public static final PluginFileType<PaperParentProvider> PAPER = new PluginFileType<>("paper-plugin.yml", PaperParentProvider.FACTORY) {
+        @Override
+        protected void register(PaperParentProvider provider) {
+            PaperPluginProvider parent = provider.createInstance();
+            if (parent.shouldCreateBootstrap()) {
+                PaperPluginProvider.PaperBootstrapProvider bootstrapPluginProvider = parent.createBootstrapProvider();
+
+                PreInitProviderStorage.INSTANCE.register(bootstrapPluginProvider);
+                ServerPluginProviderStorage.INSTANCE.register(parent.createPluginProvider(bootstrapPluginProvider));
+            } else {
+                ServerPluginProviderStorage.INSTANCE.register(parent.createPluginProvider());
+            }
+        }
+    };
+    public static final PluginFileType<SpigotPluginProvider> SPIGOT = new PluginFileType<>("plugin.yml", SpigotPluginProvider.FACTORY) {
+        @Override
+        protected void register(SpigotPluginProvider provider) {
+            ServerPluginProviderStorage.INSTANCE.register(provider);
+        }
+    };
+
+    private static final List<PluginFileType<?>> VALUES = List.of(PAPER, SPIGOT);
+
+    private final String config;
+    private final PluginProviderFactory<T> factory;
+
+    PluginFileType(String config, PluginProviderFactory<T> factory) {
+        this.config = config;
+        this.factory = factory;
+    }
+
+    public void register(JarFile file, Path context) throws Exception  {
+        this.register(this.factory.build(file, file.getJarEntry(this.config), context));
+    }
+
+    protected abstract void register(T provider);
+
+    @Nullable
+    public static PluginFileType<?> guessType(JarFile file) {
+        for (PluginFileType<?> type : VALUES) {
+            JarEntry entry = file.getJarEntry(type.config);
+            if (entry != null) {
+                return type;
+            }
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/PluginProviderFactory.java b/src/main/java/io/papermc/paper/plugin/provider/type/PluginProviderFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab31b1c635f91c51b4740492817e43878b2413cf
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/PluginProviderFactory.java
@@ -0,0 +1,12 @@
+package io.papermc.paper.plugin.provider.type;
+
+import io.papermc.paper.plugin.provider.PluginProvider;
+
+import java.nio.file.Path;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+
+public interface PluginProviderFactory<T extends PluginProvider<?>> {
+
+    T build(JarFile file, JarEntry config, Path source) throws Exception;
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperParentProvider.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperParentProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..a4b222396b45589c0749761b977e9d5a35246668
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperParentProvider.java
@@ -0,0 +1,73 @@
+package io.papermc.paper.plugin.provider.type.paper;
+
+import com.destroystokyo.paper.utils.PaperPluginLogger;
+import io.papermc.paper.plugin.loader.PluginLoader;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.configuration.PaperPluginConfiguration;
+import io.papermc.paper.plugin.provider.loader.PaperClasspathBuilder;
+import io.papermc.paper.plugin.provider.service.classloader.PaperSimplePluginClassLoader;
+import io.papermc.paper.plugin.provider.type.PluginProviderFactory;
+import io.papermc.paper.plugin.provider.util.ProviderUtil;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.jar.JarFile;
+import java.util.logging.Logger;
+
+public class PaperParentProvider implements PluginProvider<PaperPluginProvider> {
+
+    public static final PluginProviderFactory<PaperParentProvider> FACTORY = new PaperPluginProviderFactory();
+
+    private final Path path;
+    private final PaperPluginConfiguration description;
+    private final JarFile jarFile;
+
+    private final Logger logger;
+
+    PaperParentProvider(Path path, JarFile file, PaperPluginConfiguration configuration) throws IOException {
+        this.path = path;
+        this.jarFile = file;
+        this.description = configuration;
+        this.logger = PaperPluginLogger.getLogger(configuration);
+    }
+
+    @Override
+    public @NotNull Path getSource() {
+        return this.path;
+    }
+
+    @Override
+    public JarFile file() {
+        return this.jarFile;
+    }
+
+    @Override
+    public PaperPluginProvider createInstance() {
+        PaperClasspathBuilder builder = new PaperClasspathBuilder();
+
+        if (this.description.getLoader() != null) {
+            try (
+                PaperSimplePluginClassLoader simplePluginClassLoader = new PaperSimplePluginClassLoader(this.path, this.jarFile, this.description, this.getClass().getClassLoader())
+            ) {
+                PluginLoader loader = ProviderUtil.loadClass(this.description.getLoader(), PluginLoader.class, simplePluginClassLoader);
+                loader.classloader(builder);
+
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        }
+
+        return new PaperPluginProvider(this.path, this.jarFile, this.description, builder.buildClassLoader(this), this.logger);
+    }
+
+    public PaperPluginConfiguration getConfiguration() {
+        return this.description;
+    }
+
+    @Override
+    public Logger getLogger() {
+        return this.logger;
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProvider.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..7adc2d17d38a4a528d0091bcf9c3c828f71271d4
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProvider.java
@@ -0,0 +1,193 @@
+package io.papermc.paper.plugin.provider.type.paper;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+import io.papermc.paper.plugin.bootstrap.PluginBootstrap;
+import io.papermc.paper.plugin.bootstrap.PluginBootstrapContextImpl;
+import io.papermc.paper.plugin.provider.PluginProvider;
+import io.papermc.paper.plugin.provider.ProviderStatus;
+import io.papermc.paper.plugin.provider.ProviderStatusHolder;
+import io.papermc.paper.plugin.provider.configuration.PaperPluginConfiguration;
+import io.papermc.paper.plugin.provider.configuration.PluginConfiguration;
+import io.papermc.paper.plugin.provider.service.classloader.PaperPluginClassLoader;
+import io.papermc.paper.plugin.provider.service.classloader.PaperPluginClassLoaderStorage;
+import io.papermc.paper.plugin.provider.type.JavaPluginProvider;
+import io.papermc.paper.plugin.provider.util.ProviderUtil;
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoader;
+import org.bukkit.plugin.SimplePluginManager;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.io.File;
+import java.nio.file.Path;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.jar.JarFile;
+import java.util.logging.Logger;
+
+public class PaperPluginProvider {
+
+    private final Path path;
+    private final JarFile jarFile;
+
+    private final PaperPluginConfiguration description;
+    private final PaperPluginClassLoader classLoader;
+
+    private final Logger logger;
+
+    public PaperPluginProvider(Path path, JarFile jarFile, PaperPluginConfiguration description, PaperPluginClassLoader classLoader, Logger logger) {
+        this.path = path;
+        this.jarFile = jarFile;
+        this.description = description;
+        this.classLoader = classLoader;
+        this.logger = logger;
+    }
+
+    public boolean shouldCreateBootstrap() {
+        return this.description.getBootstrapper() != null;
+    }
+
+    public PaperBootstrapProvider createBootstrapProvider() {
+        return new PaperBootstrapProvider();
+    }
+
+    public class PaperBootstrapProvider implements PluginProvider<PluginBootstrap>, ProviderStatusHolder {
+
+        private ProviderStatus status;
+        private PluginBootstrap lastProvided;
+
+        @Override
+        public @NotNull Path getSource() {
+            return PaperPluginProvider.this.path;
+        }
+
+        @Override
+        public JarFile file() {
+            return PaperPluginProvider.this.jarFile;
+        }
+
+        @Override
+        public PluginBootstrap createInstance() {
+            PluginBootstrap bootstrap = ProviderUtil.loadClass(PaperPluginProvider.this.description.getBootstrapper(),
+                PluginBootstrap.class, PaperPluginProvider.this.classLoader, () -> this.status = ProviderStatus.ERRORED);
+            this.status = ProviderStatus.INITIALIZED;
+            this.lastProvided = bootstrap;
+            return bootstrap;
+        }
+
+        @Override
+        public PaperPluginConfiguration getConfiguration() {
+            return PaperPluginProvider.this.description;
+        }
+
+        @Override
+        public Logger getLogger() {
+            return PaperPluginProvider.this.logger;
+        }
+
+        @Override
+        public ProviderStatus getLastProvidedStatus() {
+            return this.status;
+        }
+
+        @Override
+        public void setStatus(ProviderStatus status) {
+            this.status = status;
+        }
+
+        public PluginBootstrap getLastProvided() {
+            return this.lastProvided;
+        }
+    }
+
+    public PaperServerPluginProvider createPluginProvider() {
+        return new PaperServerPluginProvider(null);
+    }
+
+    public PaperServerPluginProvider createPluginProvider(PaperBootstrapProvider provider) {
+        return new PaperServerPluginProvider(provider);
+    }
+
+    public class PaperServerPluginProvider extends JavaPluginProvider implements ProviderStatusHolder {
+
+        private final PaperBootstrapProvider bootstrapProvider;
+
+        private ProviderStatus status;
+
+        PaperServerPluginProvider(PaperBootstrapProvider bootstrapProvider) {
+            this.bootstrapProvider = bootstrapProvider;
+        }
+
+        @Override
+        public @NotNull Path getSource() {
+            return PaperPluginProvider.this.path;
+        }
+
+        @Override
+        public JarFile file() {
+            return PaperPluginProvider.this.jarFile;
+        }
+
+        @Override
+        public JavaPlugin createInstance() {
+            PluginBootstrap bootstrap = null;
+            if (this.bootstrapProvider != null && this.bootstrapProvider.getLastProvided() != null) {
+                bootstrap = this.bootstrapProvider.getLastProvided();
+            }
+
+            try {
+                JavaPlugin plugin;
+                if (bootstrap == null) {
+                    plugin = ProviderUtil.loadClass(PaperPluginProvider.this.description.getMain(), JavaPlugin.class, PaperPluginProvider.this.classLoader);
+                } else {
+                    plugin = bootstrap.createPlugin(PluginBootstrapContextImpl.of(this, Bukkit.getPluginsFolder().toPath()));
+                }
+
+                // Don't allow plugins to load plugins other than the one defined in main. This restriction might not be necessary.
+                if (!plugin.getClass().isAssignableFrom(Class.forName(PaperPluginProvider.this.description.getMain(), true, plugin.getClass().getClassLoader()))) {
+                    throw new IllegalArgumentException("Plugin provided must be the same type as main defined in plugin configuration!");
+                }
+
+                this.status = ProviderStatus.INITIALIZED;
+                return plugin;
+            } catch (Throwable throwable) {
+                this.status = ProviderStatus.ERRORED;
+                SneakyThrow.sneaky(throwable);
+            }
+
+            throw new AssertionError(); // Impossible
+        }
+
+        @Override
+        public PaperPluginConfiguration getConfiguration() {
+            return PaperPluginProvider.this.description;
+        }
+
+        @Override
+        public Logger getLogger() {
+            return PaperPluginProvider.this.logger;
+        }
+
+        @Override
+        public ProviderStatus getLastProvidedStatus() {
+            return this.status;
+        }
+
+        @Override
+        public void setStatus(ProviderStatus status) {
+            this.status = status;
+        }
+
+        public boolean shouldSkipCreation() {
+            if (this.bootstrapProvider == null) {
+                return false;
+            }
+
+            return this.bootstrapProvider.getLastProvidedStatus() == ProviderStatus.ERRORED;
+        }
+
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProviderFactory.java b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProviderFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..9868be521c0fe0d9a060bee78d1b28efe1550f32
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/paper/PaperPluginProviderFactory.java
@@ -0,0 +1,28 @@
+package io.papermc.paper.plugin.provider.type.paper;
+
+import io.papermc.paper.plugin.provider.configuration.PaperPluginConfiguration;
+import io.papermc.paper.plugin.provider.type.PluginProviderFactory;
+import org.bukkit.plugin.InvalidDescriptionException;
+import org.yaml.snakeyaml.error.YAMLException;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.nio.file.Path;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+
+class PaperPluginProviderFactory implements PluginProviderFactory<PaperParentProvider> {
+
+    @Override
+    public PaperParentProvider build(JarFile file, JarEntry config, Path source) throws Exception {
+        PaperPluginConfiguration configuration;
+        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(file.getInputStream(config)))) {
+            configuration = PaperPluginConfiguration.create(bufferedReader);
+        } catch (IOException | YAMLException ex) {
+            throw new InvalidDescriptionException(ex);
+        }
+
+        return new PaperParentProvider(source, file, configuration);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProvider.java b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProvider.java
new file mode 100644
index 0000000000000000000000000000000000000000..a3a72f19f7035e7fde374ff9f0a7d26657452a12
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProvider.java
@@ -0,0 +1,88 @@
+package io.papermc.paper.plugin.provider.type.spigot;
+
+import com.destroystokyo.paper.util.SneakyThrow;
+import com.destroystokyo.paper.utils.PaperPluginLogger;
+import io.papermc.paper.plugin.provider.ProviderStatus;
+import io.papermc.paper.plugin.provider.ProviderStatusHolder;
+import io.papermc.paper.plugin.provider.type.JavaPluginProvider;
+import io.papermc.paper.plugin.provider.type.PluginProviderFactory;
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.InvalidPluginException;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.SimplePluginManager;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+
+import java.nio.file.Path;
+import java.util.jar.JarFile;
+import java.util.logging.Logger;
+
+public class SpigotPluginProvider extends JavaPluginProvider implements ProviderStatusHolder {
+
+    public static final PluginProviderFactory<SpigotPluginProvider> FACTORY = new SpigotPluginProviderFactory();
+
+    private ProviderStatus status;
+
+    private final Path path;
+    private final PluginDescriptionFile description;
+    private final JarFile jarFile;
+
+    private final Logger logger;
+
+    SpigotPluginProvider(Path path, JarFile file, PluginDescriptionFile description) {
+        this.path = path;
+        this.jarFile = file;
+        this.description = description;
+        this.logger = PaperPluginLogger.getLogger(description);
+    }
+
+    @Override
+    public @NotNull Path getSource() {
+        return this.path;
+    }
+
+    @Override
+    public JarFile file() {
+        return this.jarFile;
+    }
+
+    @Override
+    public JavaPlugin createInstance() {
+        try {
+            SimplePluginManager simplePluginManager = (SimplePluginManager) Bukkit.getPluginManager();
+            JavaPlugin plugin = (JavaPlugin) simplePluginManager.loader.loadPlugin(this.description, this.path.toFile());
+
+            this.status = ProviderStatus.INITIALIZED;
+            return plugin;
+        } catch (Throwable ex) {
+            this.status = ProviderStatus.ERRORED;
+            SneakyThrow.sneaky(ex);
+        }
+
+        throw new AssertionError(); // Shouldn't happen
+    }
+
+    @Override
+    public PluginDescriptionFile getConfiguration() {
+        return this.description;
+    }
+
+    @Override
+    public Logger getLogger() {
+        return this.logger;
+    }
+
+    @Override
+    public ProviderStatus getLastProvidedStatus() {
+        return this.status;
+    }
+
+    @Override
+    public void setStatus(ProviderStatus status) {
+        this.status = status;
+    }
+
+    public boolean isLegacy() {
+        return !Bukkit.getUnsafe().isSupportedApiVersion(this.description.getAPIVersion());
+    }
+}
diff --git a/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProviderFactory.java b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProviderFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..e856f7900026e508a1076c28ccace58acb461c23
--- /dev/null
+++ b/src/main/java/io/papermc/paper/plugin/provider/type/spigot/SpigotPluginProviderFactory.java
@@ -0,0 +1,40 @@
+package io.papermc.paper.plugin.provider.type.spigot;
+
+import io.papermc.paper.plugin.provider.configuration.serializer.constraints.PluginConfigConstraints;
+import io.papermc.paper.plugin.provider.type.PluginProviderFactory;
+import org.bukkit.plugin.InvalidDescriptionException;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.yaml.snakeyaml.error.YAMLException;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.nio.file.Path;
+import java.util.Locale;
+import java.util.jar.JarEntry;
+import java.util.jar.JarFile;
+
+class SpigotPluginProviderFactory implements PluginProviderFactory<SpigotPluginProvider> {
+
+    @Override
+    public SpigotPluginProvider build(JarFile file, JarEntry config, Path source) throws Exception {
+        PluginDescriptionFile descriptionFile;
+        try (InputStream inputStream = file.getInputStream(config)) {
+            descriptionFile = new PluginDescriptionFile(inputStream);
+        } catch (IOException | YAMLException ex) {
+            throw new InvalidDescriptionException(ex);
+        }
+
+        // Copied from SimplePluginManager#loadPlugins
+        // Spigot doesn't validate the name when the config is created, and instead when the plugin is loaded.
+        // Paper plugin configuration will do these checks in config serializer instead of when this is created.
+        String name = descriptionFile.getRawName();
+        if (PluginConfigConstraints.RESERVED_KEYS.contains(name.toLowerCase(Locale.ROOT))) {
+            throw new InvalidDescriptionException("Restricted name, cannot use %s as a plugin name.".formatted(name));
+        } else if (name.indexOf(' ') != -1) {
+            throw new InvalidDescriptionException("Restricted name, cannot use 0x20 (space character) in a plugin name.");
+        }
+
+        return new SpigotPluginProvider(source, file, descriptionFile);
+    }
+}
+
diff --git a/src/main/java/net/minecraft/server/Main.java b/src/main/java/net/minecraft/server/Main.java
index 0a843e0afbcb1af8e2641515eb244b791b819b8c..9aa21ccd5a04ea1bd59063e48845c1a5abeb541b 100644
--- a/src/main/java/net/minecraft/server/Main.java
+++ b/src/main/java/net/minecraft/server/Main.java
@@ -105,6 +105,17 @@ public class Main {
             }
 
             Bootstrap.bootStrap();
+            // Paper start
+            io.papermc.paper.plugin.provider.service.classloader.PaperClassloaderBytecodeModifier.init();
+            io.papermc.paper.plugin.provider.source.Providers provider = io.papermc.paper.plugin.provider.source.Providers.INSTANCE;
+            File pluginfile = (File) optionset.valueOf("plugins");
+            provider.addProviders(io.papermc.paper.plugin.provider.source.impl.DirectoryProviderSource.INSTANCE, pluginfile.toPath());
+
+            @SuppressWarnings("unchecked")
+            java.util.List<File> files = (java.util.List<File>) optionset.valuesOf("add-plugin");
+            provider.addProviders(io.papermc.paper.plugin.provider.source.impl.PluginFlagProviderSource.INSTANCE, files);
+            io.papermc.paper.plugin.provider.service.storage.PreInitProviderStorage.INSTANCE.init(pluginfile.toPath());
+            // Paper end
             Bootstrap.validate();
             Util.startTimerHackThread();
             Path path = Paths.get("server.properties");
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index a8cf1ab9d7504dfdb2310f1dca82324a225bea7d..ba5180b6fdee2819fdf001be537d83d18b0834db 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -410,7 +410,8 @@ public final class CraftServer implements Server {
 
     public void loadPlugins() {
         this.pluginManager.registerInterface(JavaPluginLoader.class);
-
+        io.papermc.paper.plugin.provider.service.storage.plugin.ServerPluginProviderStorage.INSTANCE.loadAll();
+        if (true) return;
         File pluginFolder = this.getPluginsFolder(); // Paper
 
         // Paper start
diff --git a/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java b/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
index 909b2c98e7a9117d2f737245e4661792ffafb744..0aadfacf70adc48be64a8129e8a2f499f967abbc 100644
--- a/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
+++ b/src/main/java/org/bukkit/craftbukkit/scheduler/MinecraftInternalPlugin.java
@@ -42,6 +42,12 @@ public class MinecraftInternalPlugin extends PluginBase {
     public PluginDescriptionFile getDescription() {
         return pdf;
     }
+    // Paper start
+    @Override
+    public io.papermc.paper.plugin.provider.configuration.PluginConfiguration getConfiguration() {
+        return pdf;
+    }
+    // Paper end
 
     @Override
     public FileConfiguration getConfig() {

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Owen1212055 <23108066+Owen1212055@users.noreply.github.com>
Date: Mon, 29 Nov 2021 21:57:05 -0500
Subject: [PATCH] WIP Brain API


diff --git a/src/main/java/io/papermc/paper/entity/brain/PaperBrainHandler.java b/src/main/java/io/papermc/paper/entity/brain/PaperBrainHandler.java
new file mode 100644
index 0000000000000000000000000000000000000000..af24b5530fc2b4059fbc85ffabc364115b3df596
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/PaperBrainHandler.java
@@ -0,0 +1,245 @@
+package io.papermc.paper.entity.brain;
+
+import com.google.common.collect.ImmutableList;
+import com.mojang.datafixers.util.Pair;
+import io.papermc.paper.entity.brain.activity.ActivityKey;
+import io.papermc.paper.entity.brain.activity.PaperCustomBehavior;
+import io.papermc.paper.entity.brain.activity.PaperVanillaBehavior;
+import io.papermc.paper.entity.brain.activity.behavior.Behavior;
+import io.papermc.paper.entity.brain.activity.behavior.BehaviorPair;
+import io.papermc.paper.entity.brain.memory.MemoryManager;
+import io.papermc.paper.entity.brain.memory.MemoryPair;
+import io.papermc.paper.entity.brain.memory.PaperMemoryManager;
+import io.papermc.paper.entity.brain.sensor.PaperCustomSensor;
+import io.papermc.paper.entity.brain.sensor.PaperVanillaSensor;
+import io.papermc.paper.entity.brain.sensor.Sensor;
+import io.papermc.paper.entity.brain.sensor.SensorKey;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.ai.Brain;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+import net.minecraft.world.entity.ai.sensing.SensorType;
+import net.minecraft.world.entity.schedule.Activity;
+import org.bukkit.craftbukkit.entity.CraftLivingEntity;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.memory.MemoryKey;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.*;
+
+import static io.papermc.paper.entity.brain.PaperBrainUtil.getBrain;
+
+/*
+So although every entity "has a brain"
+Not every entity uses it!
+ */
+public class PaperBrainHandler implements BrainManager {
+
+    public static final PaperBrainHandler INSTANCE = new PaperBrainHandler();
+
+    private static net.minecraft.world.entity.LivingEntity getHandle(LivingEntity livingEntity) {
+        return ((CraftLivingEntity) livingEntity).getHandle();
+    }
+
+    @Override
+    public void clearActivities(@NotNull LivingEntity livingEntity) {
+        Brain<?> brain = getBrain(livingEntity);
+
+        // Clear predefined core activities
+        brain.coreActivities = new HashSet<>();
+        brain.activeActivities.clear();
+
+        brain.activityRequirements.clear();
+        brain.activityMemoriesToEraseWhenStopped.clear();
+        brain.availableBehaviorsByPriority.clear();
+    }
+
+    private static List<ActivityKey> transformActivities(Collection<Activity> activities) {
+        List<ActivityKey> keys = new ArrayList<>(activities.size());
+        for (Activity activity : activities) {
+            keys.add(PaperBrainUtil.toBukkit(activity));
+        }
+
+        return keys;
+    }
+
+    @Override
+    public @NotNull Map<Integer, Collection<ActivityKey>> getPrioritizedActivities(@NotNull LivingEntity livingEntity) {
+        Map<Integer, Collection<ActivityKey>> activities = new HashMap<>();
+        for (var entry : getBrain(livingEntity).availableBehaviorsByPriority.entrySet()) {
+            activities.put(entry.getKey(), transformActivities(entry.getValue().keySet()));
+        }
+
+        return activities;
+    }
+
+    @Override
+    public @NotNull Collection<ActivityKey> getActiveActivities(@NotNull LivingEntity livingEntity) {
+        return transformActivities(getBrain(livingEntity).activeActivities);
+    }
+
+    @Override
+    public @NotNull Collection<ActivityKey> getCoreActivities(@NotNull LivingEntity livingEntity) {
+        return transformActivities(getBrain(livingEntity).coreActivities);
+    }
+
+    @Override
+    public void startActivity(@NotNull LivingEntity livingEntity, @NotNull ActivityKey key) {
+        getBrain(livingEntity).setActiveActivityIfPossible(PaperBrainUtil.getHandle(key));
+    }
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    @Override
+    public void stopActivity(@NotNull LivingEntity livingEntity, @NotNull ActivityKey key) {
+        Activity activity = PaperBrainUtil.getHandle(key);
+        Brain<?> brain = getBrain(livingEntity);
+
+        if (brain.isActive(activity)) {
+            brain.activeActivities.remove(activity);
+
+            net.minecraft.world.entity.LivingEntity handle = getHandle(livingEntity);
+            ServerLevel level = (ServerLevel) handle.level;
+            Map<Integer, Map<Activity, Set<net.minecraft.world.entity.ai.behavior.Behavior>>> map = (Map<Integer, Map<Activity, Set<net.minecraft.world.entity.ai.behavior.Behavior>>>) brain.availableBehaviorsByPriority.values();
+
+            for(var behaviorsMap : map.values()) {
+                Set<net.minecraft.world.entity.ai.behavior.Behavior> behaviors = behaviorsMap.get(activity);
+
+                if (behaviors != null) {
+                    for(var behavior : behaviors) {
+                        if (behavior.getStatus() == net.minecraft.world.entity.ai.behavior.Behavior.Status.RUNNING) {
+                            behavior.doStop(level, handle, level.getGameTime());
+                        }
+                    }
+                }
+
+            }
+        }
+    }
+
+    @Override
+    public void startFirstValidActivity(@NotNull LivingEntity livingEntity, @NotNull Collection<ActivityKey> keys) {
+        List<Activity> activites = new ArrayList<>(keys.size());
+        for (ActivityKey key : keys) {
+            activites.add(PaperBrainUtil.getHandle(key));
+        }
+
+        getBrain(livingEntity).setActiveActivityToFirstValid(activites);
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    @Override
+    public <T extends LivingEntity> void addActivity(@NotNull LivingEntity livingEntity, @NotNull ActivityKey key, @NotNull Collection<BehaviorPair<? super T>> behaviorPairs, @NotNull Collection<MemoryPair> requiredMemories, @NotNull Collection<io.papermc.paper.entity.brain.memory.MemoryModuleType<?>> keysToRemoveOnFinish) {
+        Brain<?> brain = getBrain(livingEntity);
+
+        ImmutableList.Builder behaviorPairList = ImmutableList.builderWithExpectedSize(behaviorPairs.size());
+        for (BehaviorPair<? super T> pair : behaviorPairs) {
+
+            net.minecraft.world.entity.ai.behavior.Behavior mcBehavior;
+            Behavior<?> paperBehavior = pair.behavior();
+            if (paperBehavior instanceof PaperVanillaBehavior vanillaBehavior) { // Don't surround vanilla behaviors
+                mcBehavior = vanillaBehavior.getHandle();
+            } else {
+                mcBehavior = new PaperCustomBehavior<>(pair.behavior());
+            }
+
+            behaviorPairList.add(new Pair<>(pair.priority(), mcBehavior));
+        }
+
+        Set<Pair<MemoryModuleType<?>, MemoryStatus>> memoryPairSet = new HashSet<>(requiredMemories.size());
+        for (MemoryPair pair : requiredMemories) {
+            memoryPairSet.add(new Pair<>(PaperBrainUtil.getHandle(pair.key()), PaperBrainUtil.getHandle(pair.requiredStatus())));
+        }
+
+        Set<MemoryModuleType<?>> removeSet = new HashSet<>(keysToRemoveOnFinish.size());
+        for (io.papermc.paper.entity.brain.memory.MemoryModuleType<?> memoryKey : keysToRemoveOnFinish) {
+            removeSet.add(PaperBrainUtil.getHandle(memoryKey));
+        }
+
+        brain.addActivityAndRemoveMemoriesWhenStopped(PaperBrainUtil.getHandle(key),
+            behaviorPairList.build(),
+            memoryPairSet,
+            removeSet
+        );
+    }
+
+    @Override
+    public @NotNull ActivityKey getDefaultActivity(@NotNull LivingEntity livingEntity) {
+        return PaperBrainUtil.toBukkit(getBrain(livingEntity).defaultActivity);
+    }
+
+    @Override
+    public void setDefaultActivity(@NotNull LivingEntity livingEntity, @NotNull ActivityKey key) {
+        getBrain(livingEntity).setDefaultActivity(PaperBrainUtil.getHandle(key));
+    }
+
+    @Override
+    public void setCoreActivities(@NotNull LivingEntity livingEntity, @NotNull Collection<ActivityKey> keys) {
+        Set<Activity> activites = new HashSet<>(keys.size());
+        for (ActivityKey key : keys) {
+            activites.add(PaperBrainUtil.getHandle(key));
+        }
+
+        getBrain(livingEntity).setCoreActivities(activites);
+    }
+
+    @SuppressWarnings({"unchecked", "rawtypes"})
+    @Override
+    public <T extends LivingEntity> void addSensor(@NotNull LivingEntity livingEntity, @NotNull SensorKey key, Sensor<? super T> sensor) {
+        Brain<?> brain = getBrain(livingEntity);
+
+        // See brain constructor
+        net.minecraft.world.entity.ai.sensing.Sensor mcSensor;
+        if (sensor instanceof PaperVanillaSensor vanillaSensor) { // Don't surround vanilla sensors
+            mcSensor = vanillaSensor.getHandle();
+        } else {
+            mcSensor = new PaperCustomSensor(sensor);
+        }
+
+        SensorType ignoreGenericType = PaperBrainUtil.getHandle(key);
+        // Register sensor
+        brain.sensors.put(ignoreGenericType, mcSensor);
+
+        // Register any required memories
+        Set<MemoryModuleType<?>> thanksIntellij = mcSensor.requires(); // Intellij wants to have this set iterate objects ???????????????????????????
+        for (MemoryModuleType<?> memoryType : thanksIntellij) {
+            brain.memories.putIfAbsent(memoryType, Optional.empty());
+        }
+    }
+
+    @Override
+    public void clearSensors(@NotNull LivingEntity livingEntity) {
+        Brain<?> brain = getBrain(livingEntity);
+        brain.sensors.clear();
+    }
+
+    @Override
+    public void removeSensor(@NotNull LivingEntity livingEntity, @NotNull SensorKey key) {
+        Brain<?> brain = getBrain(livingEntity);
+        brain.sensors.remove(PaperBrainUtil.getHandle(key));
+    }
+
+    @Nullable
+    @Override
+    public Sensor<? extends LivingEntity> getSensor(@NotNull LivingEntity livingEntity, @NotNull SensorKey key) {
+        Brain<?> brain = getBrain(livingEntity);
+        return brain.sensors.get(PaperBrainUtil.getHandle(key)).getPaperSensor();
+    }
+
+    @Override
+    public @NotNull Collection<Sensor<? extends LivingEntity>> getSensors(@NotNull LivingEntity livingEntity) {
+        Brain<?> brain = getBrain(livingEntity);
+
+        List<Sensor<? extends org.bukkit.entity.LivingEntity>> sensors = new ArrayList<>(brain.sensors.size());
+        for (net.minecraft.world.entity.ai.sensing.Sensor<?> sensor : brain.sensors.values()) {
+            sensors.add(sensor.getPaperSensor());
+        }
+
+        return sensors;
+    }
+
+    @Override
+    public @NotNull MemoryManager getMemoryManager() {
+        return PaperMemoryManager.INSTANCE;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/PaperBrainUtil.java b/src/main/java/io/papermc/paper/entity/brain/PaperBrainUtil.java
new file mode 100644
index 0000000000000000000000000000000000000000..8fea60244bcf38b2cc10abaab1635d0507b8e9df
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/PaperBrainUtil.java
@@ -0,0 +1,97 @@
+package io.papermc.paper.entity.brain;
+
+import io.papermc.paper.entity.brain.activity.ActivityKey;
+import io.papermc.paper.entity.brain.activity.PaperActivity;
+import io.papermc.paper.entity.brain.activity.VanillaActivityKey;
+import io.papermc.paper.entity.brain.memory.MemoryModuleType;
+import io.papermc.paper.entity.brain.memory.MemoryTypeStatus;
+import io.papermc.paper.entity.brain.memory.PaperMemoryManager;
+import io.papermc.paper.entity.brain.memory.PaperMemoryModuleType;
+import io.papermc.paper.entity.brain.sensor.PaperSensor;
+import io.papermc.paper.entity.brain.sensor.SensorKey;
+import io.papermc.paper.entity.brain.sensor.VanillaSensorKey;
+import net.minecraft.core.Registry;
+import net.minecraft.world.entity.ai.Brain;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+import net.minecraft.world.entity.ai.sensing.SensorType;
+import net.minecraft.world.entity.schedule.Activity;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.entity.CraftLivingEntity;
+import org.bukkit.craftbukkit.entity.memory.CraftMemoryKey;
+import org.bukkit.craftbukkit.entity.memory.CraftMemoryMapper;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.bukkit.entity.LivingEntity;
+
+public class PaperBrainUtil {
+
+    public static Brain<?> getBrain(LivingEntity livingEntity) {
+        return ((CraftLivingEntity) livingEntity).getHandle().getBrain();
+    }
+
+    public static <U> net.minecraft.world.entity.ai.memory.MemoryModuleType<U> getHandle(MemoryModuleType<U> type) {
+        return (net.minecraft.world.entity.ai.memory.MemoryModuleType<U>) ((PaperMemoryModuleType<U>) type).getHandle();
+    }
+
+    public static SensorType<?> getHandle(SensorKey key) {
+        if (key == null) { // Null check to prevent confusing exception
+            throw new NullPointerException("Null key provided");
+        }
+
+        if (key instanceof VanillaSensorKey) {
+            return Registry.SENSOR_TYPE.getOptional(CraftNamespacedKey.toMinecraft(key.getKey())).get();
+        } else if (key instanceof PaperSensor paperSensor) {
+            return paperSensor;
+        }
+
+        throw new UnsupportedOperationException("You cannot use your own implementation of SensorKey!");
+    }
+
+    public static MemoryStatus getHandle(MemoryTypeStatus status) {
+        return switch (status) {
+            case ABSENT -> MemoryStatus.VALUE_ABSENT;
+            case PRESENT -> MemoryStatus.VALUE_PRESENT;
+            case REGISTERED -> MemoryStatus.REGISTERED;
+        };
+    }
+
+    public static Activity getHandle(ActivityKey key) {
+        if (key == null) { // Null check to prevent confusing exception
+            throw new NullPointerException("Null key provided");
+        }
+
+        if (key instanceof VanillaActivityKey) {
+            return Registry.ACTIVITY.getOptional(CraftNamespacedKey.toMinecraft(key.getKey())).get();
+        } else if (key instanceof PaperActivity paperActivity) {
+            return paperActivity;
+        }
+
+        throw new UnsupportedOperationException("You cannot use your own implementation of ActivityKey!");
+    }
+
+    public static PaperMemoryModuleType<?> toPaper(net.minecraft.world.entity.ai.memory.MemoryModuleType<?> nms) {
+        // custom types actually register in NMS Registry, that's why we are getting them from it.
+        final PaperMemoryModuleType<?> customMemoryType = (PaperMemoryModuleType<?>) PaperMemoryManager.INSTANCE.getTypeByKey(CraftNamespacedKey.fromMinecraft(Registry.MEMORY_MODULE_TYPE.getKey(nms)));
+        return customMemoryType == null ? PaperMemoryModuleType.of(CraftMemoryKey.toMemoryKey(nms)) : customMemoryType;
+    }
+
+    public static MemoryTypeStatus toBukkit(MemoryStatus status) {
+        return switch (status) {
+            case VALUE_ABSENT -> MemoryTypeStatus.ABSENT;
+            case VALUE_PRESENT -> MemoryTypeStatus.PRESENT;
+            case REGISTERED -> MemoryTypeStatus.REGISTERED;
+        };
+    }
+
+    public static ActivityKey toBukkit(Activity activity) {
+        if (activity instanceof PaperActivity paperActivity) {
+            return paperActivity;
+        }
+
+        return VanillaActivityKey.getByKey(NamespacedKey.minecraft(activity.getName()));
+    }
+
+    public static <U> U handleIfVanilla(MemoryModuleType<U> type, U u) {
+        return ((PaperMemoryModuleType<?>) type).getMemoryKey().isPresent() ? (U) CraftMemoryMapper.toNms(u) : u;
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/activity/PaperActivity.java b/src/main/java/io/papermc/paper/entity/brain/activity/PaperActivity.java
new file mode 100644
index 0000000000000000000000000000000000000000..3fa39f0e499b981f007616a9bc821fcb2217ec76
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/activity/PaperActivity.java
@@ -0,0 +1,20 @@
+package io.papermc.paper.entity.brain.activity;
+
+import net.minecraft.world.entity.schedule.Activity;
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.NotNull;
+
+public class PaperActivity extends Activity implements ActivityKey {
+
+    private final NamespacedKey key;
+
+    public PaperActivity(NamespacedKey key) {
+        super(key.toString());
+        this.key = key;
+    }
+
+    @Override
+    public @NotNull NamespacedKey getKey() {
+        return key;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/activity/PaperCustomBehavior.java b/src/main/java/io/papermc/paper/entity/brain/activity/PaperCustomBehavior.java
new file mode 100644
index 0000000000000000000000000000000000000000..1f8d16a82f4f2bdb4b6a973e815119dfffad0862
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/activity/PaperCustomBehavior.java
@@ -0,0 +1,61 @@
+package io.papermc.paper.entity.brain.activity;
+
+import io.papermc.paper.entity.brain.PaperBrainUtil;
+import io.papermc.paper.entity.brain.memory.MemoryPair;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.ai.behavior.Behavior;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+
+public class PaperCustomBehavior<T extends LivingEntity> extends Behavior<T> {
+
+    private final io.papermc.paper.entity.brain.activity.behavior.Behavior<org.bukkit.entity.LivingEntity> behavior;
+
+    public PaperCustomBehavior(io.papermc.paper.entity.brain.activity.behavior.Behavior behavior) {
+        super(toMinecraft(behavior), behavior.getMinRuntime(), behavior.getMaxRuntime());
+        this.behavior = behavior;
+    }
+
+    @Override
+    protected void start(ServerLevel world, T entity, long time) {
+        behavior.start(entity.getBukkitLivingEntity());
+    }
+
+    @Override
+    protected void tick(ServerLevel world, T entity, long time) {
+        behavior.tick(entity.getBukkitLivingEntity());
+    }
+
+    @Override
+    protected void stop(ServerLevel world, T entity, long time) {
+        behavior.stop(entity.getBukkitLivingEntity());
+    }
+
+    @Override
+    protected boolean checkExtraStartConditions(ServerLevel world, T entity) {
+        return behavior.canStart(entity.getBukkitLivingEntity());
+    }
+
+    @Override
+    protected boolean canStillUse(ServerLevel world, T entity, long time) {
+        return behavior.canStillRun(entity.getBukkitLivingEntity());
+    }
+
+    private static Map<MemoryModuleType<?>, MemoryStatus> toMinecraft(io.papermc.paper.entity.brain.activity.behavior.Behavior behavior) {
+        Collection<MemoryPair> requirement = behavior.getMemoryRequirements();
+
+        Map<MemoryModuleType<?>, MemoryStatus> map = new HashMap<>(requirement.size());
+        for (MemoryPair pair : requirement) {
+            map.put(PaperBrainUtil.getHandle(pair.key()), PaperBrainUtil.getHandle(pair.requiredStatus()));
+        }
+
+        return map;
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/activity/PaperVanillaBehavior.java b/src/main/java/io/papermc/paper/entity/brain/activity/PaperVanillaBehavior.java
new file mode 100644
index 0000000000000000000000000000000000000000..ab874543062b79af052b34e878e9bc3e737ffa4b
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/activity/PaperVanillaBehavior.java
@@ -0,0 +1,81 @@
+package io.papermc.paper.entity.brain.activity;
+
+import io.papermc.paper.entity.brain.PaperBrainUtil;
+import io.papermc.paper.entity.brain.activity.behavior.Behavior;
+import io.papermc.paper.entity.brain.memory.MemoryTypeStatus;
+import io.papermc.paper.entity.brain.memory.MemoryPair;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import net.minecraft.world.entity.ai.memory.MemoryStatus;
+import org.bukkit.craftbukkit.entity.CraftLivingEntity;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.memory.MemoryKey;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+public class PaperVanillaBehavior implements Behavior<LivingEntity> {
+
+    private final net.minecraft.world.entity.ai.behavior.Behavior<net.minecraft.world.entity.LivingEntity> handle;
+    private final Collection<MemoryPair> memoryRequirements;
+
+    public PaperVanillaBehavior(net.minecraft.world.entity.ai.behavior.Behavior<net.minecraft.world.entity.LivingEntity> handle) {
+        this.handle = handle;
+
+        List<MemoryPair> memoryRequirements = new ArrayList<>(handle.entryCondition.size());
+        for (Map.Entry<MemoryModuleType<?>, MemoryStatus> type : handle.entryCondition.entrySet()) {
+
+            io.papermc.paper.entity.brain.memory.MemoryModuleType<?> key = PaperBrainUtil.toPaper(type.getKey());
+            if (key != null) {
+                MemoryTypeStatus status = PaperBrainUtil.toBukkit(type.getValue());
+
+                memoryRequirements.add(new MemoryPair(status, key));
+            }
+        }
+
+        this.memoryRequirements = memoryRequirements;
+    }
+
+    @Override
+    public void start(LivingEntity entity) {
+        net.minecraft.world.entity.LivingEntity entityHandle = ((CraftLivingEntity) entity).getHandle();
+
+        handle.tryStart((ServerLevel) entityHandle.level, entityHandle, entityHandle.level.getGameTime());
+    }
+
+    @Override
+    public void tick(LivingEntity entity) {
+        net.minecraft.world.entity.LivingEntity entityHandle = ((CraftLivingEntity) entity).getHandle();
+
+        handle.tickOrStop((ServerLevel) entityHandle.level, entityHandle, entityHandle.level.getGameTime());
+    }
+
+    @Override
+    public void stop(LivingEntity entity) {
+        net.minecraft.world.entity.LivingEntity entityHandle = ((CraftLivingEntity) entity).getHandle();
+
+        handle.doStop((ServerLevel) entityHandle.level, entityHandle, entityHandle.level.getGameTime());
+    }
+
+    @Override
+    public int getMinRuntime() {
+        return handle.minDuration;
+    }
+
+    @Override
+    public int getMaxRuntime() {
+        return handle.maxDuration;
+    }
+
+    @Override
+    public Collection<MemoryPair> getMemoryRequirements() {
+        return memoryRequirements;
+    }
+
+    public net.minecraft.world.entity.ai.behavior.Behavior<net.minecraft.world.entity.LivingEntity> getHandle() {
+        return handle;
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/memory/PaperMemoryManager.java b/src/main/java/io/papermc/paper/entity/brain/memory/PaperMemoryManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..a4c0ca56748e56bb477483a3b82aec66a8d976b3
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/memory/PaperMemoryManager.java
@@ -0,0 +1,111 @@
+package io.papermc.paper.entity.brain.memory;
+
+import com.google.common.collect.BiMap;
+import com.google.common.collect.HashBiMap;
+import io.papermc.paper.entity.brain.PaperBrainUtil;
+import net.minecraft.core.Registry;
+import net.minecraft.world.entity.ai.Brain;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.bukkit.entity.LivingEntity;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Optional;
+
+import static io.papermc.paper.entity.brain.PaperBrainUtil.getBrain;
+import org.bukkit.entity.memory.MemoryKey;
+
+public class PaperMemoryManager implements MemoryManager {
+    public static final PaperMemoryManager INSTANCE = new PaperMemoryManager();
+
+    private PaperMemoryManager() {}
+
+    private final BiMap<NamespacedKey, io.papermc.paper.entity.brain.memory.MemoryModuleType<?>> customMemoryTypeRegistry = HashBiMap.create();
+    public final BiMap<MemoryKey<?>, PaperMemoryModuleType<?>> vanillaMemoryModuleTypeCache = HashBiMap.create();
+    
+    @Override
+    public void registerMemoryType(@NotNull LivingEntity livingEntity, @NotNull io.papermc.paper.entity.brain.memory.MemoryModuleType<?> memoryModuleType) {
+        getBrain(livingEntity).memories.put(PaperBrainUtil.getHandle(memoryModuleType), Optional.empty());
+    }
+
+    @Override
+    public <U> void setMemory(@NotNull LivingEntity livingEntity, @NotNull io.papermc.paper.entity.brain.memory.MemoryModuleType<U> memoryModuleType, @Nullable U value, long expireIn) {
+        getBrain(livingEntity).setMemoryWithExpiry(PaperBrainUtil.getHandle(memoryModuleType), PaperBrainUtil.handleIfVanilla(memoryModuleType, value), expireIn);
+    }
+
+    @Override
+    public <U> void setMemory(@NotNull LivingEntity livingEntity, io.papermc.paper.entity.brain.memory.@NotNull MemoryModuleType<U> memoryModuleType, U value) {
+        getBrain(livingEntity).setMemory(PaperBrainUtil.getHandle(memoryModuleType), PaperBrainUtil.handleIfVanilla(memoryModuleType, value));
+    }
+
+    @Override
+    public <U> Optional<U> getMemory(@NotNull LivingEntity livingEntity, io.papermc.paper.entity.brain.memory.@NotNull MemoryModuleType<U> memoryModuleType) {
+        return getBrain(livingEntity).getMemory(PaperBrainUtil.getHandle(memoryModuleType));
+    }
+
+    @Override
+    public <U> long getTimeUntilExpiry(@NotNull LivingEntity livingEntity, io.papermc.paper.entity.brain.memory.@NotNull MemoryModuleType<U> memoryModuleType) {
+        return getBrain(livingEntity).getTimeUntilExpiry(PaperBrainUtil.getHandle(memoryModuleType));
+    }
+
+    @Override
+    public boolean memoryStatusMatches(@NotNull LivingEntity livingEntity, @NotNull io.papermc.paper.entity.brain.memory.MemoryModuleType<?> memoryModuleType, @NotNull MemoryTypeStatus status) {
+        return getBrain(livingEntity).checkMemory(PaperBrainUtil.getHandle(memoryModuleType), PaperBrainUtil.getHandle(status));
+    }
+
+    @Override
+    public void eraseMemory(@NotNull LivingEntity livingEntity, @NotNull io.papermc.paper.entity.brain.memory.MemoryModuleType<?> memoryModuleType) {
+        getBrain(livingEntity).eraseMemory(PaperBrainUtil.getHandle(memoryModuleType));
+    }
+
+    @Override
+    public void unregisterMemoryType(@NotNull LivingEntity livingEntity, @NotNull io.papermc.paper.entity.brain.memory.MemoryModuleType<?> memoryKey) {
+        getBrain(livingEntity).memories.remove(PaperBrainUtil.getHandle(memoryKey));
+    }
+
+    @Override
+    public @NotNull Collection<io.papermc.paper.entity.brain.memory.MemoryModuleType<?>> getMemoryTypes(@NotNull LivingEntity livingEntity) {
+        Brain<?> brain = getBrain(livingEntity);
+
+        List<io.papermc.paper.entity.brain.memory.MemoryModuleType<?>> memories = new ArrayList<>(); // Don't specify initial size since keys can be null due to this being a separate api
+        for (net.minecraft.world.entity.ai.memory.MemoryModuleType<?> memory : brain.memories.keySet()) {
+            MemoryModuleType<?> key = PaperBrainUtil.toPaper(memory);
+            if (key != null)
+                memories.add(key);
+        }
+
+        return memories;
+    }
+
+    @Override
+    public void unregisterMemories(@NotNull LivingEntity livingEntity) {
+        getBrain(livingEntity).memories.clear();
+    }
+
+    // Custom memory type registry methods.
+
+    public void registerType(NamespacedKey key, MemoryModuleType<?> type) {
+        if (customMemoryTypeRegistry.putIfAbsent(key, type) != null) throw new IllegalStateException("Memory type with this key is already registered!");
+        Registry.register(Registry.MEMORY_MODULE_TYPE, CraftNamespacedKey.toMinecraft(key), PaperBrainUtil.getHandle(type));
+    }
+
+    public boolean isTypeRegistered(MemoryModuleType<?> type) {
+        return customMemoryTypeRegistry.containsValue(type);
+    }
+
+    public boolean isKeyRegistered(NamespacedKey key) {
+        return customMemoryTypeRegistry.containsKey(key);
+    }
+
+    public MemoryModuleType<?> getTypeByKey(NamespacedKey key) {
+        return customMemoryTypeRegistry.get(key);
+    }
+
+    public NamespacedKey getKeyByType(MemoryModuleType<?> type) {
+        return customMemoryTypeRegistry.inverse().get(type);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/memory/PaperMemoryModuleType.java b/src/main/java/io/papermc/paper/entity/brain/memory/PaperMemoryModuleType.java
new file mode 100644
index 0000000000000000000000000000000000000000..e9cf2d40f51abe34d51b7f65c7ff760531e6ab37
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/memory/PaperMemoryModuleType.java
@@ -0,0 +1,69 @@
+package io.papermc.paper.entity.brain.memory;
+
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.entity.memory.CraftMemoryKey;
+import org.bukkit.entity.memory.MemoryKey;
+
+import java.util.Objects;
+import java.util.Optional;
+
+public class PaperMemoryModuleType<U> implements MemoryModuleType<U> {
+    private final net.minecraft.world.entity.ai.memory.MemoryModuleType<?> handle;
+    private final NamespacedKey key;
+    private MemoryKey<U> memoryKey;
+
+    private PaperMemoryModuleType(MemoryKey<U> key) {
+        this.key = key.getKey();
+        this.memoryKey = key;
+        this.handle = CraftMemoryKey.fromMemoryKey(key);
+    }
+
+    private PaperMemoryModuleType(NamespacedKey key) {
+        this.key = key;
+        this.handle = new net.minecraft.world.entity.ai.memory.MemoryModuleType<>(Optional.empty()); // No codec, no serialization :<
+        PaperMemoryManager.INSTANCE.registerType(key, this);
+    }
+
+    public static <U> PaperMemoryModuleType<U> of(MemoryKey<U> key) {
+	if (key == null) return null;
+        PaperMemoryModuleType cached = PaperMemoryManager.INSTANCE.vanillaMemoryModuleTypeCache.get(key);
+        if (cached != null) return cached;
+        PaperMemoryModuleType vanillaMemoryType = new PaperMemoryModuleType<>(key);
+        PaperMemoryManager.INSTANCE.vanillaMemoryModuleTypeCache.putIfAbsent(key, vanillaMemoryType);
+        return vanillaMemoryType;
+    }
+
+    public static <U> PaperMemoryModuleType<U> of(NamespacedKey key) {
+        return new PaperMemoryModuleType<>(key);
+    }
+
+    @Override
+    public Optional<MemoryKey<U>> getMemoryKey() {
+        return Optional.ofNullable(memoryKey);
+    }
+
+    @Override
+    public NamespacedKey getKey() {
+        return key;
+    }
+
+    public net.minecraft.world.entity.ai.memory.MemoryModuleType<?> getHandle() {
+        return handle;
+    }
+
+    /**
+     * @return same as usual equals, but also returns true if NMS MemoryModuleType is equal.
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        PaperMemoryModuleType<?> that = (PaperMemoryModuleType<?>) o;
+        return handle.equals(that.handle);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(handle);
+    }
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/sensor/PaperCustomSensor.java b/src/main/java/io/papermc/paper/entity/brain/sensor/PaperCustomSensor.java
new file mode 100644
index 0000000000000000000000000000000000000000..9309e63e8c2e33139b637ee9e7d8ffc4309e3c71
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/sensor/PaperCustomSensor.java
@@ -0,0 +1,46 @@
+package io.papermc.paper.entity.brain.sensor;
+
+import io.papermc.paper.entity.brain.PaperBrainUtil;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.memory.MemoryKey;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+public class PaperCustomSensor extends net.minecraft.world.entity.ai.sensing.Sensor<net.minecraft.world.entity.LivingEntity> {
+
+    private final Sensor<LivingEntity> sensor;
+    private final Set<MemoryModuleType<?>> requiredMemories;
+
+    @SuppressWarnings("unchecked")
+    public PaperCustomSensor(Sensor<? extends LivingEntity> sensor) {
+        super(sensor.getInterval());
+        this.sensor = (Sensor<LivingEntity>) sensor;
+
+        Set<MemoryModuleType<?>> minecraftRequiredMemories = new HashSet<>(sensor.requiredMemories().size());
+        Collection<io.papermc.paper.entity.brain.memory.MemoryModuleType<?>> setupidIntellij = sensor.requiredMemories();
+        for (io.papermc.paper.entity.brain.memory.MemoryModuleType<?> key : setupidIntellij) {
+            minecraftRequiredMemories.add(PaperBrainUtil.getHandle(key));
+        }
+
+        this.requiredMemories = minecraftRequiredMemories;
+    }
+
+    @Override
+    protected void doTick(ServerLevel world, net.minecraft.world.entity.LivingEntity entity) {
+        sensor.tick(entity.getBukkitLivingEntity());
+    }
+
+    @Override
+    public Set<MemoryModuleType<?>> requires() {
+        return requiredMemories;
+    }
+
+    @Override
+    public Sensor<? extends LivingEntity> getPaperSensor() {
+        return sensor;
+    }
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/sensor/PaperSensor.java b/src/main/java/io/papermc/paper/entity/brain/sensor/PaperSensor.java
new file mode 100644
index 0000000000000000000000000000000000000000..0e0940b73771bb981a2baca17bfde2eafd48270e
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/sensor/PaperSensor.java
@@ -0,0 +1,21 @@
+package io.papermc.paper.entity.brain.sensor;
+
+import net.minecraft.world.entity.ai.sensing.SensorType;
+import org.bukkit.NamespacedKey;
+import org.jetbrains.annotations.NotNull;
+
+public class PaperSensor extends SensorType implements SensorKey {
+
+    private final NamespacedKey key;
+
+    public PaperSensor(NamespacedKey key) {
+        super(null);
+        this.key = key;
+    }
+
+    @Override
+    public @NotNull NamespacedKey getKey() {
+        return key;
+    }
+
+}
diff --git a/src/main/java/io/papermc/paper/entity/brain/sensor/PaperVanillaSensor.java b/src/main/java/io/papermc/paper/entity/brain/sensor/PaperVanillaSensor.java
new file mode 100644
index 0000000000000000000000000000000000000000..875c0e7b9a6a4ce9499410769fd5e264954bc1bf
--- /dev/null
+++ b/src/main/java/io/papermc/paper/entity/brain/sensor/PaperVanillaSensor.java
@@ -0,0 +1,60 @@
+package io.papermc.paper.entity.brain.sensor;
+
+import io.papermc.paper.entity.brain.PaperBrainUtil;
+import io.papermc.paper.entity.brain.memory.PaperMemoryManager;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.entity.ai.memory.MemoryModuleType;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.entity.CraftLivingEntity;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.memory.MemoryKey;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public class PaperVanillaSensor implements Sensor<LivingEntity> {
+
+    private final net.minecraft.world.entity.ai.sensing.Sensor<net.minecraft.world.entity.LivingEntity> handle;
+
+    // temp
+    @SuppressWarnings("unchecked")
+    public PaperVanillaSensor(net.minecraft.world.entity.ai.sensing.Sensor<?> handle) {
+        this.handle = (net.minecraft.world.entity.ai.sensing.Sensor<net.minecraft.world.entity.LivingEntity>) handle;
+    }
+
+    @Override
+    public int getInterval() {
+        return handle.scanRate;
+    }
+
+    @Override
+    public void tick(LivingEntity entity) {
+        net.minecraft.world.entity.LivingEntity livingEntityHandle = ((CraftLivingEntity) entity).getHandle();
+
+        handle.tick((ServerLevel) livingEntityHandle.level, livingEntityHandle);
+    }
+
+    @Override
+    public Set<io.papermc.paper.entity.brain.memory.MemoryModuleType<?>> requiredMemories() {
+        Set<io.papermc.paper.entity.brain.memory.MemoryModuleType<?>> keys = new HashSet<>(handle.requires().size());
+        for (MemoryModuleType<?> type : handle.requires()) {
+            io.papermc.paper.entity.brain.memory.MemoryModuleType<?> key = PaperBrainUtil.toPaper(type);//MemoryKey.getByKey(NamespacedKey.minecraft(type.toString()));
+            if (key != null) {
+                keys.add(key);
+            }
+        }
+
+        return keys;
+    }
+
+    public net.minecraft.world.entity.ai.sensing.Sensor<net.minecraft.world.entity.LivingEntity> getHandle() {
+        return handle;
+    }
+
+    @Override
+    public String toString() {
+        return "PaperVanillaSensor{" +
+            "handle=" + handle +
+            '}';
+    }
+}
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java b/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java
index c24ff2ef1054523e58892c2b35080cffb6ab744a..2d530de8cb463c023d42d43cfc491ea672cfe7f6 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/Behavior.java
@@ -9,11 +9,11 @@ import net.minecraft.world.entity.ai.memory.MemoryStatus;
 
 public abstract class Behavior<E extends LivingEntity> {
     private static final int DEFAULT_DURATION = 60;
-    protected final Map<MemoryModuleType<?>, MemoryStatus> entryCondition;
+    public final Map<MemoryModuleType<?>, MemoryStatus> entryCondition;
     private Behavior.Status status = Behavior.Status.STOPPED;
     private long endTimestamp;
-    private final int minDuration;
-    private final int maxDuration;
+    public final int minDuration;
+    public final int maxDuration;
     // Paper start - configurable behavior tick rate and timings
     private final String configKey;
     private final co.aikar.timings.Timing timing;
diff --git a/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java b/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java
index f3b8e253a5bfc3f68121dbe656ae7e2ac0f0eb1c..33948d8387df1e422875a7edc24c3359a7c66026 100644
--- a/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java
+++ b/src/main/java/net/minecraft/world/entity/ai/sensing/Sensor.java
@@ -17,7 +17,7 @@ public abstract class Sensor<E extends LivingEntity> {
     private static final TargetingConditions ATTACK_TARGET_CONDITIONS_IGNORE_INVISIBILITY_TESTING = TargetingConditions.forCombat().range(16.0D).ignoreInvisibilityTesting();
     private static final TargetingConditions ATTACK_TARGET_CONDITIONS_IGNORE_LINE_OF_SIGHT = TargetingConditions.forCombat().range(16.0D).ignoreLineOfSight();
     private static final TargetingConditions ATTACK_TARGET_CONDITIONS_IGNORE_INVISIBILITY_AND_LINE_OF_SIGHT = TargetingConditions.forCombat().range(16.0D).ignoreLineOfSight().ignoreInvisibilityTesting();
-    private final int scanRate;
+    public final int scanRate;
     private long timeToTick;
     // Paper start - configurable sensor tick rate and timings
     private final String configKey;
@@ -69,4 +69,16 @@ public abstract class Sensor<E extends LivingEntity> {
     public static boolean isEntityAttackableIgnoringLineOfSight(LivingEntity entity, LivingEntity target) {
         return entity.getBrain().isMemoryValue(MemoryModuleType.ATTACK_TARGET, target) ? ATTACK_TARGET_CONDITIONS_IGNORE_INVISIBILITY_AND_LINE_OF_SIGHT.test(entity, target) : ATTACK_TARGET_CONDITIONS_IGNORE_LINE_OF_SIGHT.test(entity, target);
     }
+
+    // Paper start - mob goal api
+    private io.papermc.paper.entity.brain.sensor.Sensor<? extends org.bukkit.entity.LivingEntity> paperSensor = null;
+
+    public io.papermc.paper.entity.brain.sensor.Sensor<? extends org.bukkit.entity.LivingEntity> getPaperSensor() {
+        if (this.paperSensor == null) {
+            this.paperSensor = new io.papermc.paper.entity.brain.sensor.PaperVanillaSensor(this);
+        }
+
+        return this.paperSensor;
+    }
+    // Paper end - mob goal api
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index ba7023e7ca5d29375ff53c2951892138d155f69f..221ff83fc285c17bb99b7c271983430b1d2292bb 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -18,6 +18,7 @@ import com.mojang.serialization.Lifecycle;
 import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufOutputStream;
 import io.netty.buffer.Unpooled;
+import io.papermc.paper.entity.brain.memory.PaperMemoryModuleType;
 import io.papermc.paper.logging.SysoutCatcher;
 import it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap;
 import java.awt.image.BufferedImage;
@@ -199,6 +200,7 @@ import org.bukkit.craftbukkit.util.Versioning;
 import org.bukkit.craftbukkit.util.permissions.CraftDefaultPermissions;
 import org.bukkit.entity.Entity;
 import org.bukkit.entity.Player;
+import org.bukkit.entity.memory.MemoryKey;
 import org.bukkit.event.inventory.InventoryType;
 import org.bukkit.event.player.PlayerChatTabCompleteEvent;
 import org.bukkit.event.server.BroadcastMessageEvent;
@@ -2815,5 +2817,29 @@ public final class CraftServer implements Server {
         return datapackManager;
     }
 
+    @Override
+    public io.papermc.paper.entity.brain.activity.ActivityKey createActivityKey(NamespacedKey key) {
+        return new io.papermc.paper.entity.brain.activity.PaperActivity(key);
+    }
+
+    @Override
+    public io.papermc.paper.entity.brain.sensor.SensorKey createSensorKey(NamespacedKey key) {
+        return new io.papermc.paper.entity.brain.sensor.PaperSensor(key);
+    }
+
+    @Override
+    public <U> io.papermc.paper.entity.brain.memory.MemoryModuleType<U> createMemoryModuleType(NamespacedKey key) {
+        return PaperMemoryModuleType.of(key);
+    }
+
+    @Override
+    public <U> io.papermc.paper.entity.brain.memory.MemoryModuleType<U> createMemoryModuleType(MemoryKey<U> key) {
+        return PaperMemoryModuleType.of(key);
+    }
+
+    @Override
+    public io.papermc.paper.entity.brain.BrainManager getBrainManager() {
+        return io.papermc.paper.entity.brain.PaperBrainHandler.INSTANCE;
+    }
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftGoat.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftGoat.java
index 436aa41563b8fab112d03c8cc516cf6ff37587bd..91d0d78453f4679c691493131b5da6b5dded1a24 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftGoat.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftGoat.java
@@ -1,6 +1,7 @@
 package org.bukkit.craftbukkit.entity;
 
 import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.entity.Axolotl;
 import org.bukkit.entity.EntityType;
 import org.bukkit.entity.Goat;
 
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftHoglin.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftHoglin.java
index d5b31e4051f22fee4b91eb0e6be25d72e0471eff..49a22a20229ac6e4c4ebaf825814c3c384b3f35b 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftHoglin.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftHoglin.java
@@ -3,6 +3,7 @@ package org.bukkit.craftbukkit.entity;
 import com.google.common.base.Preconditions;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Goat;
 import org.bukkit.entity.Hoglin;
 
 public class CraftHoglin extends CraftAnimals implements Hoglin {
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftPiglin.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftPiglin.java
index aeda5fc001fe4ce55ee467240b275b6050a29f98..257637b7fbdf80427343629d12ad74076d18dc92 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftPiglin.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftPiglin.java
@@ -10,11 +10,11 @@ import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.inventory.CraftInventory;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Hoglin;
 import org.bukkit.entity.Piglin;
 import org.bukkit.inventory.Inventory;
 
-public class CraftPiglin extends CraftPiglinAbstract implements Piglin, com.destroystokyo.paper.entity.CraftRangedEntity<net.minecraft.world.entity.monster.piglin.Piglin> { // Paper
-
+public class CraftPiglin extends CraftPiglinAbstract implements Piglin, com.destroystokyo.paper.entity.CraftRangedEntity<net.minecraft.world.entity.monster.piglin.Piglin> {
     public CraftPiglin(CraftServer server, net.minecraft.world.entity.monster.piglin.Piglin entity) {
         super(server, entity);
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftZoglin.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftZoglin.java
index 611e794d86ff63d725de9bb843802ec868f4b1fd..eb15a997fa855f90bab7eb159ac2342f77578e94 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftZoglin.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftZoglin.java
@@ -2,6 +2,7 @@ package org.bukkit.craftbukkit.entity;
 
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Villager;
 import org.bukkit.entity.Zoglin;
 
 public class CraftZoglin extends CraftMonster implements Zoglin {
diff --git a/src/test/java/io/papermc/paper/entity/brain/MissingBrainAPITest.java b/src/test/java/io/papermc/paper/entity/brain/MissingBrainAPITest.java
new file mode 100644
index 0000000000000000000000000000000000000000..99e68796afbd0b121adb55bb1a7580b3252f2ef3
--- /dev/null
+++ b/src/test/java/io/papermc/paper/entity/brain/MissingBrainAPITest.java
@@ -0,0 +1,57 @@
+package io.papermc.paper.entity.brain;
+
+import com.google.common.base.Joiner;
+import io.papermc.paper.entity.brain.activity.ActivityKey;
+import io.papermc.paper.entity.brain.activity.VanillaActivityKey;
+import io.papermc.paper.entity.brain.sensor.SensorKey;
+import io.papermc.paper.entity.brain.sensor.VanillaSensorKey;
+import net.minecraft.core.Registry;
+import net.minecraft.resources.ResourceLocation;
+import org.bukkit.NamespacedKey;
+import org.bukkit.craftbukkit.util.CraftNamespacedKey;
+import org.junit.Test;
+
+import java.lang.reflect.Field;
+import java.util.HashSet;
+import java.util.Set;
+
+import static org.junit.Assert.assertTrue;
+
+public class MissingBrainAPITest {
+
+    @Test
+    public void missingActivities() throws IllegalAccessException {
+        Set<NamespacedKey> activities = new HashSet<>();
+        for (ResourceLocation minecraftRegistered : Registry.ACTIVITY.keySet()) {
+            activities.add(CraftNamespacedKey.fromMinecraft(minecraftRegistered));
+        }
+
+        for (Field field : VanillaActivityKey.class.getDeclaredFields()) {
+            if (field.getType() == ActivityKey.class) {
+                activities.remove(((ActivityKey) field.get(null)).getKey());
+            }
+        }
+
+
+        assertTrue(ActivityKey.class.getName() + " instance(s): " + Joiner.on(", ").join(activities) + " do not have bukkit equivalents", activities.size() == 0);
+    }
+
+    @Test
+    public void missingSensors() throws IllegalAccessException {
+        Set<NamespacedKey> sensors = new HashSet<>();
+        for (ResourceLocation minecraftRegistered : Registry.SENSOR_TYPE.keySet()) {
+            sensors.add(CraftNamespacedKey.fromMinecraft(minecraftRegistered));
+        }
+        sensors.remove(NamespacedKey.minecraft("dummy"));
+
+        for (Field field : VanillaSensorKey.class.getDeclaredFields()) {
+            if (field.getType() == SensorKey.class) {
+                sensors.remove(((SensorKey) field.get(null)).getKey());
+            }
+        }
+
+
+        assertTrue(SensorKey.class.getName() + " instance(s): " + Joiner.on(", ").join(sensors) + " do not have bukkit equivalents", sensors.size() == 0);
+    }
+
+}
